<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  NathanCHEN
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        <li id="menu_item_index"><a href="index.html">HOME</a></li>
        <li id="menu_item_archives"><a href="archives.html">Archives</a></li>
        <li id="menu_item_about"><a href="about.html">ABOUT</a></li>
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" action="http://google.com/search" method="get">
    <input type="hidden" name="q" value="site:nathanchen.github.io" />
    <input tabindex="1" type="search" name="q"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; NathanCHEN</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="JavaScript.html">JavaScript</a></li>
        
            <li><a href="Ngnix.html">Ngnix</a></li>
        
            <li><a href="tomcat.html">tomcat</a></li>
        
            <li><a href="spring.html">spring</a></li>
        
            <li><a href="RabbitMQ.html">RabbitMQ</a></li>
        
            <li><a href="ELK.html">ELK</a></li>
        
            <li><a href="TCP/IP.html">TCP/IP</a></li>
        
            <li><a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html">源码阅读</a></li>
        
            <li><a href="others.html">others</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="PAXOS.html">PAXOS</a></li>
        
            <li><a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html">深入分析Java Web技术内幕</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14457412438030.html">
                
                  <h1>Redis杂</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">为什么Redis不支持回滚（rollback）</h4>

<ul>
<li>Redis命令只会因为错误的语法而失败，或者是命令用在了错误类型的键上</li>
<li>因为不需要对回滚进行支持，所以Redis的内部可以保持简单而快速</li>
</ul>

<p>在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</p>

<p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>

<hr/>

<h4 id="toc_1">watch的作用是什么，跟直接用multi有什么区别</h4>

<p><a href="http://stackoverflow.com/questions/10750626/transactions-and-watch-statement-in-redis">http://stackoverflow.com/questions/10750626/transactions-and-watch-statement-in-redis</a></p>

<h4 id="toc_2">Redis持久化</h4>

<p>Redis提供了多种不同级别的持久化方式：</p>

<ul>
<li><strong>RDB持久化</strong>可以在指定的时间间隔内生成数据集的<strong>时间点快照</strong>（point-in-time snapshot）</li>
<li><strong>AOF持久化记录服务器执行的所有写操作命令</strong>，并在<strong>服务器启动时</strong>，通过<strong>重新执行这些命令来还原数据集</strong>。AOF文件中的命令全部以Redis协议的格式来保存，新命令会被追加到文件的末尾。Redis还可以在后台对AOF文件进行重写，使得AOF文件的体积不会超出保存数据集状态所需的实际大小。</li>
<li>Redis还可以同时使用AOF持久化和RDB持久化。在这种情况下，当Redis重启时，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。</li>
<li>持久化功能可以被关闭，数据只在服务器运行时存在。</li>
</ul>

<h5 id="toc_3">RDB的优点</h5>

<ul>
<li>RDB是一个非常紧凑（compact）的文件，它保存了Redis在某个时间点上的数据集。这种文件非常适合于进行备份。</li>
<li>RDB非常适合用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心</li>
<li>RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无需执行任何磁盘I/O操作。</li>
<li>RDB在恢复大数据集时的速度比AOF的恢复速度要快。</li>
</ul>

<h5 id="toc_4">RDB的缺点</h5>

<ul>
<li>如果你需要尽量避免在服务器故障时丢失数据，那么RDB不适合你。因为RDB文件需要保存整个数据集的状态，所以它并不是一个轻松的操作。因此可能会至少5分钟才保存一次RDB文件。在这种情况下，一旦发生故障停机，你就可能会丢失几分钟的数据。</li>
<li>每次保存RDB的时候，Redis都要fork（）出一个子进程，并由子进程来进行实际的持久化工作。当数据集比较庞大时，fork（）可能非常耗时，造成服务器可能长达一秒停止处理客户端。</li>
</ul>

<h5 id="toc_5">AOF的优点</h5>

<ul>
<li>使用AOF持久化会让Redis变得非常耐久（much more durable）：你可以设置不同的fsync策略，比如无fsync，每秒钟一次fsync，或者每次执行写入命令时fsync。AOF的默认策略为每秒钟fsync一次，在这种配置下，Redis仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒种的数据。</li>
<li>AOF文件是一个只进行追加操作的日志文件（append only log），因此对AOF文件的写入不需要进行seek，即使日志因为某些原因而包含了未写入完整的命令（比如磁盘已满），redis-check-aof工具也可以轻易地修复这种问题。</li>
<li><p>Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写：重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建新AOF文件的过程中，会继续将命令追加到现有的AOF里面，即使重写过程中发生停机，现有的AOF文件也不会丢失。一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作。</p>

<p>举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。</p>

<p>然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p>

<p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。</p></li>
<li><p>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。导出（export）AOF文件也非常简单。</p>

<p>举个例子，如果你不小心执行了FLUSHALL命令，只要AOF文件未被重写，那么只要停止服务器，移除AOF文件末尾的FLUSHALL命令，并重启Redis，就可以将数据集恢复到FLUSHALL执行之前的状态。</p></li>
</ul>

<h5 id="toc_6">AOF的缺点</h5>

<ul>
<li>对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积</li>
<li>根据所使用的fsync策略，AOF的速度可能会慢于RDB。在一般情况下，每秒fsync的性能依然非常高，而关闭fsync可以让AOF的速度和RDB一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB可以提供更有保证的最大延迟时间（latency）</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/10/25</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14457412437888.html">
                
                  <h1>NIO入门</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">NIO入门</h2>

<h5 id="toc_1">I/O简介</h5>

<p>I/O指的是计算机与外部世界或者一个程序与计算机的其余部分之间的接口。</p>

<p>在Java编程中，直到最近一直使用流的方式完成I/O。所有I/O都被视为单个的字节的流动，通过一个称为Stream的对象一次移动一个字节。流I/O用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。</p>

<p>NIO与原来的I/O有同样的作用和目的，但是它使用不同的方式：块I/O</p>

<p>块I/O的效率比流I/O高很多</p>

<h5 id="toc_2">流与块的比较</h5>

<p>面向流的I/O系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分。不利的一面是，面向流的I/O通常相当慢。</p>

<p>一个面向块的I/O系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据库。按块处理数据比按（流式的）字节处理数据要快得多。但是面向块的I/O缺少一些面向流的I/O所具有的优雅型和简单性。</p>

<p>通道和缓冲区是NIO中的核心对象，几乎在每一个I/O操作中都要使用它们。</p>

<p>通道是对原I/O包中的流的模拟。到任何目的地的所有数据都必须通过一个Channel对象。一个Buffer实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p>

<h4 id="toc_3">什么是缓冲区</h4>

<p>Buffer是一个对象，它包含一些要写入或者刚读出的数据。</p>

<p>在面向流的I/O中，你是将数据直接写入或者将数据直接读到Stream对象中。</p>

<p>在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入缓冲区中的。</p>

<p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>

<h4 id="toc_4">什么是通道</h4>

<p>Channel是一个对象，可以通过它读取和写入数据。</p>

<p>所有数据都通过Buffer对象来处理。你不会将字节直接写入通道中，相反，你是将数据写入包含一个或者多个字节的缓冲区。</p>

<p>通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动（一个流必须是InputStream或者OutputStream的子类），而通道可以用于读、写或者同时用于读写。</p>

<h4 id="toc_5">从文件中读取</h4>

<p>我们将从一个文件中读取一些数据。如果使用原来的 I/O，那么我们只需创建一个 FileInputStream 并从它那里读取。而在 NIO 中，情况稍有不同：我们首先从 FileInputStream 获取一个 Channel 对象，然后使用这个通道来读取数据。</p>

<p>在 NIO 系统中，任何时候执行一个读操作，您都是从通道中读取，但是您不是 直接 从通道读取。因为所有数据最终都驻留在缓冲区中，所以您是从通道读到缓冲区中。</p>

<p>因此读取文件涉及三个步骤：(1) 从 FileInputStream 获取 Channel，(2) 创建 Buffer，(3) 将数据从 Channel 读到 Buffer 中。</p>

<h5 id="toc_6">读文件</h5>

<p>第一步是获取通道。我们从 FileInputStream 获取通道：</p>

<pre><code>FileInputStream fin = new FileInputStream( &quot;readandshow.txt&quot; );
FileChannel fc = fin.getChannel();
</code></pre>

<p>下一步是创建缓冲区：</p>

<pre><code>ByteBuffer buffer = ByteBuffer.allocate( 1024 );
</code></pre>

<p>最后，需要将数据从通道读到缓冲区中，如下所示：</p>

<pre><code>fc.read( buffer );
</code></pre>

<p>我们不需要告诉通道要读多少数据到缓冲区中。</p>

<h5 id="toc_7">写入文件</h5>

<p>首先从 FileOutputStream 获取一个通道：</p>

<pre><code>FileOutputStream fout = new FileOutputStream( &quot;writesomebytes.txt&quot; );
FileChannel fc = fout.getChannel();
</code></pre>

<p>下一步是创建一个缓冲区并在其中放入一些数据 - 在这里，数据将从一个名为 message 的数组中取出，这个数组包含字符串 <q>Some bytes</q> 的 ASCII 字节(本教程后面将会解释 buffer.flip() 和 buffer.put() 调用)。</p>

<pre><code>ByteBuffer buffer = ByteBuffer.allocate( 1024 );

for (int i=0; i&lt;message.length; ++i) {
     buffer.put( message[i] );
}
buffer.flip();
</code></pre>

<p>最后一步是写入缓冲区中：</p>

<pre><code>fc.write( buffer );
</code></pre>

<p>不需要告诉通道要写入多数据。</p>

<h4 id="toc_8">缓冲区内部细节</h4>

<p>每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就能内部地管理自己的资源</p>

<h6 id="toc_9">状态变量</h6>

<p>可以用三个值指定缓冲区在任意时刻的状态：</p>

<ul>
<li>position</li>
<li>limit</li>
<li>capacity</li>
</ul>

<p>这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。</p>

<h5 id="toc_10">Position</h5>

<p>缓冲区实际上就是美化了的数组。在从通道读取是，你将所读取的数据放到底层的数组中。position变量跟踪已经写了多少数据，即它制定了下一个字节将放到数组的哪一个元素中。</p>

<h5 id="toc_11">limit</h5>

<p>limit变量表面还有多少数据需要取出，或者还有多少空间可以放入数据</p>

<p>position 总是小于或者等于 limit</p>

<h5 id="toc_12">capacity</h5>

<p>缓冲区的capacity表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小，或者至少指定了准许我们使用的底层数组的容量</p>

<p>limit绝不能大于capacity</p>

<h5 id="toc_13">flip</h5>

<p>flip() 方法。这个方法做两件非常重要的事：</p>

<ul>
<li>它将 limit 设置为当前 position</li>
<li>它将 position 设置为 0</li>
</ul>

<p><img src="/img/nio1.png" alt=""/></p>

<h5 id="toc_14">clear</h5>

<p>clear() 方法。这个方法重设缓冲区以便接收更多的字节。 Clear 做两种非常重要的事情：</p>

<ul>
<li>它将 limit 设置为与 capacity 相同。</li>
<li>它设置 position 为 0。</li>
</ul>

<p><img src="/img/nio2.png" alt=""/></p>

<h5 id="toc_15">缓冲区分配和包装</h5>

<p>在能够读和写之前，必须有一个缓冲区。要创建缓冲区，您必须 分配 它。我们使用静态方法 allocate() 来分配缓冲区：</p>

<pre><code>ByteBuffer buffer = ByteBuffer.allocate( 1024 );
</code></pre>

<p>allocate() 方法分配一个具有指定大小的底层数组，并将它包装到一个缓冲区对象中 ― 在本例中是一个 ByteBuffer。<br/>
您还可以将一个现有的数组转换为缓冲区，如下所示：</p>

<pre><code>byte array[] = new byte[1024];
ByteBuffer buffer = ByteBuffer.wrap( array );
</code></pre>

<h5 id="toc_16">缓冲区分片</h5>

<p>slice()方法根据现有的缓冲区创建一种子缓冲区。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。</p>

<p>我们首先创建一个长度为 10 的 ByteBuffer：</p>

<pre><code>ByteBuffer buffer = ByteBuffer.allocate( 10 );
</code></pre>

<p>然后使用数据来填充这个缓冲区，在第 n 个槽中放入数字 n：</p>

<pre><code>for (int i=0; i&lt;buffer.capacity(); ++i) {
     buffer.put( (byte)i );
}
</code></pre>

<p>现在我们对这个缓冲区 分片 ，以创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个 窗口 。<br/>
窗口的起始和结束位置通过设置 position 和 limit 值来指定，然后调用 Buffer 的 slice() 方法：</p>

<pre><code>buffer.position( 3 );
buffer.limit( 7 );
ByteBuffer slice = buffer.slice();
</code></pre>

<p>片 是缓冲区的 子缓冲区 。不过， 片段 和 缓冲区 共享同一个底层数据数组</p>

<h5 id="toc_17">缓冲区分片和数据共享</h5>

<p>我们遍历子缓冲区，将每一个元素乘以 11 来改变它。例如，5 会变成 55。</p>

<pre><code>for (int i=0; i&lt;slice.capacity(); ++i) {
     byte b = slice.get( i );
     b *= 11;
     slice.put( i, b );
}
</code></pre>

<p>最后，再看一下原缓冲区中的内容：</p>

<pre><code>buffer.position( 0 );
buffer.limit( buffer.capacity() );

while (buffer.remaining()&gt;0) {
     System.out.println( buffer.get() );
}
</code></pre>

<p>结果表明只有在子缓冲区窗口中的元素被改变了：</p>

<pre><code>$ java SliceBuffer
0
1
2
33
44
55
66
7
8
9
</code></pre>

<h5 id="toc_18">只读缓冲区</h5>

<p>通过调用缓冲区的 asReadOnlyBuffer() 方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。</p>

<h5 id="toc_19">直接和间接缓冲区</h5>

<p>直接缓冲区 是为加快 I/O 速度，而以一种特殊的方式分配其内存的缓冲区。</p>

<h5 id="toc_20">内存映射文件I/O</h5>

<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>

<h5 id="toc_21">将文件映射到内存</h5>

<p>下面代码行将文件的前 1024 个字节映射到内存中：</p>

<pre><code>MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE,
    0, 1024 );
</code></pre>

<p>map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类</p>

<h4 id="toc_22">分散和聚集</h4>

<p>分散/聚集 I/O 是使用多个而不是单个缓冲区来保存数据的读写方法。</p>

<h4 id="toc_23">文件锁定</h4>

<p>要获取文件的一部分上的锁，您要调用一个打开的 FileChannel 上的 lock() 方法。注意，如果要获取一个排它锁，您必须以写方式打开文件。</p>

<pre><code>RandomAccessFile raf = new RandomAccessFile( &quot;usefilelocks.txt&quot;, &quot;rw&quot; );
FileChannel fc = raf.getChannel();
FileLock lock = fc.lock( start, end, false );
</code></pre>

<p>在拥有锁之后，您可以执行需要的任何敏感操作，然后再释放锁：</p>

<pre><code>lock.release();
</code></pre>

<p>在释放锁后，尝试获得锁的其他任何程序都有机会获得它。</p>

<h5 id="toc_24">异步I/O</h5>

<p><strong>异步 I/O 是一种没有阻塞地读写数据的方法</strong>。通常，在代码进行 read() 调用时，代码会阻塞直至有可供读取的数据。同样， write() 调用将会阻塞直至数据能够写入。</p>

<p><strong>异步 I/O 的一个优势在于，它允许您同时根据大量的输入和输出执行 I/O</strong>。同步程序常常要求助于轮询，或者创建许许多多的线程以处理大量的连接。<strong>使用异步 I/O，您可以监听任何数量的通道上的事件，不用轮询，也不用额外的线程</strong>。</p>

<p>异步 I/O 中的核心对象名为 Selector。Selector 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。</p>

<p>我们需要做的第一件事就是创建一个 Selector：</p>

<pre><code>Selector selector = Selector.open();
</code></pre>

<p>然后，我们将对不同的通道对象调用 register() 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。register() 的第一个参数总是这个 Selector。</p>

<p>为了接收连接，我们需要一个 ServerSocketChannel。事实上，我们要监听的每一个端口都需要有一个 ServerSocketChannel 。对于每一个端口，我们打开一个 ServerSocketChannel，如下所示：</p>

<pre><code>ServerSocketChannel ssc = ServerSocketChannel.open();
ssc.configureBlocking( false );

ServerSocket ss = ssc.socket();
InetSocketAddress address = new InetSocketAddress( ports[i] );
ss.bind( address );
</code></pre>

<p>第一行创建一个新的 ServerSocketChannel ，最后三行将它绑定到给定的端口。第二行将 ServerSocketChannel 设置为 非阻塞的 。</p>

<p>下一步是将新打开的 ServerSocketChannels 注册到 Selector上。为此我们使用 ServerSocketChannel.register() 方法，如下所示：</p>

<pre><code>SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );
</code></pre>

<p>SelectionKey 代表这个通道在此 Selector 上的这个注册。当某个 Selector 通知您某个传入事件时，它是通过提供对应于该事件的 SelectionKey 来进行的。SelectionKey 还可以用于取消通道的注册。</p>

<p>现在已经注册了我们对一些 I/O 事件的兴趣，下面将进入主循环。使用 Selectors 的几乎每个程序都像下面这样使用内部循环：</p>

<pre><code>int num = selector.select();

Set selectedKeys = selector.selectedKeys();
Iterator it = selectedKeys.iterator();

while (it.hasNext()) {
     SelectionKey key = (SelectionKey)it.next();
     // ... deal with I/O event ...
}
</code></pre>

<p>首先，我们调用 Selector 的 select() 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时， select() 方法将返回所发生的事件的数量。<br/>
接下来，我们调用 Selector 的 selectedKeys() 方法，它返回发生了事件的 SelectionKey 对象的一个 集合 。<br/>
我们通过迭代 SelectionKeys 并依次处理每个 SelectionKey 来处理事件。对于每一个 SelectionKey，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p>

<p>因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 accept() 操作会阻塞：</p>

<pre><code>ServerSocketChannel ssc = (ServerSocketChannel)key.channel();
SocketChannel sc = ssc.accept();
</code></pre>

<p>下一步是将新连接的 SocketChannel 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 SocketChannel 注册到 Selector上，如下所示：</p>

<pre><code>sc.configureBlocking( false );
SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );
</code></pre>

<h4 id="toc_25">Reference</h4>

<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section3.html">http://www.ibm.com/developerworks/cn/education/java/j-nio/section3.html</a></p>

<p><a href="http://blog.csdn.net/sgbfblog/article/details/7904757">http://blog.csdn.net/sgbfblog/article/details/7904757</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/10/25</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14457412437753.html">
                
                  <h1>Tomcat源码阅读</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Tomcat</h2>

<h5 id="toc_1">Server</h5>

<p>Server是Tomcat中最顶层的组件，它可以包含多个Service组件。</p>

<p>在Tomcat源码中Server组件对应源码中的<code>org.apache.catalina.core.StandardServer</code>类</p>

<p>StandardServer的继承关系图如下图所示：</p>

<p><img src="/img/tomcat1.jpg" alt=""/></p>

<h5 id="toc_2">Service</h5>

<p>Service组件相当于Connector和Engine组件的包装器，它将一个或者多个Connector组件和一个Engine建立关联。</p>

<p>在缺省的配置文件中，定义了一个叫Catalina的Service，并将Http，AJP这两个Connector关联到了一个名为Catalina的Engine。</p>

<p>Service组件对应Tomcat源码中的<code>org.apache.catalina.core.StandardService</code></p>

<p>StandardService的继承关系图如下图所示：</p>

<p><img src="/img/tomcat2.png" alt=""/></p>

<h5 id="toc_3">Connector</h5>

<p>Connector是Tomcat中监听TCP网络连接的组件，一个Connector会监听一个独立的端口来处理来自客户端的连接。</p>

<p>缺省的情况下Tomcat提供了如下两个Connector：</p>

<ul>
<li><p>HTTP/1.1</p>

<pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;
</code></pre>

<p>上面定义了一个Connector，它缺省监听端口8080,这个端口我们可以根据具体情况进行改动。connectionTimeout定义了连接超时时间，单位是毫秒，redirectPort定义了ssl的重定向接口，根据缺省的配置，Connector会将ssl请求重定向到8443端口。</p></li>
<li><p>AJP/1.3</p>

<p>AJP表示Apache Jserv Protocol,此连接器将处理Tomcat和Aapache http服务器之间的交互，这个连机器是用来处理我们将Tomcat和Apache http服务器结合使用的情况。假如在同样的一台物理Server上面部署了一台Apache http服务器和多台Tomcat服务器，通过Apache服务器来处理静态资源以及负载均衡的时候，针对不同的Tomcat实例需要AJP监听不同的端口。</p></li>
</ul>

<p>Connector对应源代码中的<code>org.apache.catalina.connector.Connector</code></p>

<p>它的继承关系图如下所示：<br/>
<img src="/img/tomcat3.png" alt=""/></p>

<h5 id="toc_4">Engine</h5>

<p>Tomcat中有一个容器的概念，而Engine，Host，Context都属于Container。</p>

<p>一个Engine可以包含一个或者多个Host，也就是说我们一个Tomcat的实例可以配置多个虚拟主机。</p>

<p>缺省的情况下<code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</code>定义了一个名称为Cataline的Engine。</p>

<p>Engine对应源代码中的<code>org.apache.catalina.core.StandardEngine</code></p>

<p>它的继承关系图如下图所示：</p>

<p><img src="/img/tomcat4.png" alt=""/></p>

<h5 id="toc_5">Host</h5>

<p>Host定义了一个虚拟主机，一个虚拟主机可以有多个Context。</p>

<p>缺省的配置为<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;….&lt;/Host&gt;</code></p>

<p>其中appBase为webapps，也就是<code>&lt;CATALINA_HOME&gt;\webapps</code>目录</p>

<p>unpackingWARS属性指定在appBase指定的目录中的war包都自动的解压，缺省配置为true</p>

<p>autoDeploy属性指定是否对加入到appBase目录的war包进行自动的部署，缺省为true。</p>

<p>Host对应源代码中的<code>org.apache.catalina.core.StandardHost</code>,它的继承关系图如下所示：</p>

<p><img src="/img/tomcat5.png" alt=""/></p>

<h5 id="toc_6">Context</h5>

<p>在Tomcat中，每一个运行的webapp其实最终都是以Context的形成存在，每个Context都有一个根路径和请求URL路径。</p>

<p>Context对应源代码中的<code>org.apache.catalina.core.StandardContext</code>。</p>

<p>它的继承关系图如下图所示：</p>

<p><img src="/img/tomcat6.png" alt=""/></p>

<p>在Tomcat中我们通常采用如下的两种方式创建一个Context</p>

<ul>
<li><p>在CATALINA-HOME\webapps目录中创建一个目录，这个时候将自动创建一个context，默认context的访问url为<a href="http://host:port/dirname,%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%9C%A8ContextRoot%5CMETA-INF%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAcontext.xml%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E5%A6%82%E4%B8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E6%9D%A5%E6%8C%87%E5%AE%9A%E5%BA%94%E7%94%A8%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E3%80%82">http://host:port/dirname,你也可以通过在ContextRoot\META-INF中创建一个context.xml的文件，其中包含如下的内容来指定应用的访问路径。</a></p>

<pre><code>&lt;Context path=&quot;/yourUrlPath&quot; /&gt;
</code></pre></li>
<li><p>conf\server.xml文件中增加context元素。 第二种创建context的方法，我们可以选择在server.xml文件的<code>&lt;Host&gt;</code>元素，比如我们在server.xml文件中增加如下内容：</p>

<pre><code>    ......
    ......
    &lt;Context path=&quot;/mypath&quot; docBase=&quot;/Users/tiger/develop/xxx&quot; reloadable=&quot;true&quot;&gt;
    &lt;/Context&gt;
  &lt;/Host&gt;
&lt;/Engine&gt;
  &lt;/Service&gt;
&lt;/Server&gt;
</code></pre></li>
</ul>

<p>这样的话，我们就可以通过<a href="http://host:port/mypath%E8%AE%BF%E9%97%AE%E4%B8%8A%E9%9D%A2%E9%85%8D%E7%BD%AE%E7%9A%84context%E4%BA%86%E3%80%82">http://host:port/mypath访问上面配置的context了。</a></p>

<h5 id="toc_7">Valve</h5>

<p>Valve是Tomcat中责任链模式的实现，通过链接多个Valve对请求进行处理。</p>

<p>其中Valve可以定义在任何的Container（Engine，Host，Context）中。</p>

<p>默认定义了一个名为<code>org.apache.catalina.valves.AccessLogValve</code>的Valve，这个Valve负责拦截每个请求，然后记录一条访问日志。</p>

<p>通过上面的分析，我们发现Server，Service，Engine，Host，Context都实现了<code>org.apache.catalina.Lifecycle</code>接口，通过这个接口管理了这些核心组件的生命周期。</p>

<p>生命周期方法的总体的骨架，如果用伪代码来表示可以简化为如下：<br/>
<code>org.apache.catalina.util.LifecycleBase#lifeCycleMethod</code></p>

<pre><code>public final synchronized void lfieCycleMethod() throws LifecycleException {
    stateCheck();//状态检查
    //设置为进入相应的生命周期之前的状态
    setStateInternal(LifecycleState.BEFORE_STATE, null, false);
    lfieCycleMethodInternal();//钩子方法
    //进入相应的生命周期之后的状态
    setStateInternal(LifecycleState.AFTER_STATE, null, false);
}
</code></pre>

<p>通用调用过程：</p>

<pre><code>org.apache.catalina.core.StandardServer#init
-&gt;org.apache.catalina.core.StandardService#init
--&gt;org.apache.catalina.connector.Connector#init
--&gt;org.apache.catalina.core.StandardEngine#init
</code></pre>

<p>StandardEngine#init方法的时候，发现并没有进行StandardHost的初始化</p>

<p><img src="/img/tomcat7.png" alt=""/></p>

<p>StarndardHost的init方法是在调用start方法的时候被初始化</p>

<pre><code>org.apache.catalina.startup.Bootstrap#start
-&gt;org.apache.catalina.startup.Catalina#start 通过反射调用
--&gt;org.apache.catalina.core.StandardServer#start
---&gt;org.apache.catalina.core.StandardService#start
----&gt;org.apache.catalina.core.StandardEngine#start
----&gt;org.apache.catalina.Executor#start
----&gt;org.apache.catalina.connector.Connector#start


org.apache.catalina.startup.Bootstrap#main
-&gt;org.apache.catalina.startup.Bootstrap#init
-&gt;org.apache.catalina.startup.Bootstrap#load
--&gt;org.apache.catalina.startup.Catalina#load
---&gt;org.apache.catalina.core.StandardServer#init
----&gt;org.apache.catalina.core.StandardService#init
-----&gt;org.apache.catalina.connector.Connector#init
-----&gt;org.apache.catalina.core.StandardEngine#init
-&gt;org.apache.catalina.startup.Bootstrap#start
--&gt;org.apache.catalina.startup.Catalina#start 通过反射调用
---&gt;org.apache.catalina.core.StandardServer#start
----&gt;org.apache.catalina.core.StandardService#start
-----&gt;org.apache.catalina.core.StandardEngine#start
-----&gt;org.apache.catalina.Executor#start
-----&gt;org.apache.catalina.connector.Connector#start
</code></pre>

<p><code>StandardEngine</code>初始化的时候，也是初始化了一个线程池；而<code>StandardHost</code>也初始化了一个线程池。他们的不同点在与创建线程的工厂方法不同，在采用缺省配置的情况下，<code>StandardEngine</code>的线程池中的线程是以<code>Catalina-startStop</code>的形式命名的，而<code>StandardHost</code>是以<code>localhost-startStop</code>的方式进行命名的。</p>

<p>对于<code>StandardEngine</code>，<code>StandardHost</code>的启动，父容器在<code>init</code>的时候创建一个启动和停止子容器的线程池，然后父容器启动的时候首先通过异步的方式将子容器的启动通过<code>org.apache.catalina.core.ContainerBase.StartChild</code>提交到父容器中对应的线程池中进行启动，而子容器启动的时候首先会初始化，然后再启动。</p>

<p><code>webapps</code>目录的应用又是如何启动的呢？webapps目录下面的应用其实是属于<code>Context</code>的，而<code>Context</code>对应<code>Tomcat</code>中的<code>StandardContext</code>类。</p>

<p><code>webapps</code>目录中应用的启动在<code>StandardHost#start</code>的时候，通过<code>Lifecycle.START_EVENT</code>这个事件的监听器<code>HostConfig</code>进行进一步的启动。</p>

<h5 id="toc_8">Dameon线程</h5>

<p><code>Dameon线程</code>又叫后台或者守护线程，它负责在程序运行期提供一种通用服务的线程，比如垃圾收集线程。</p>

<p><code>非Dameon线程</code>和<code>Dameon线程</code>的区别就在于当程序中所有的<code>非Daemon线程</code>都终止的时候，Jvm会杀死余下的<code>Dameon线程</code>，然后退出。</p>

<h5 id="toc_9">Tomcat启动以后，会启动6条线程，他们分别如下：</h5>

<pre><code>&quot;ajp-bio-8009-AsyncTimeout&quot; daemon prio=5 tid=7f8738afe000 nid=0x115ad6000 waiting on condition [115ad5000]

&quot;ajp-bio-8009-Acceptor-0&quot; daemon prio=5 tid=7f8738b05800 nid=0x1159d3000 runnable [1159d2000]

&quot;http-bio-8080-AsyncTimeout&quot; daemon prio=5 tid=7f8735acb800 nid=0x1158d0000 waiting on condition [1158cf000]

&quot;http-bio-8080-Acceptor-0&quot; daemon prio=5 tid=7f8735acd000 nid=0x1157cd000 runnable [1157cc000]

&quot;ContainerBackgroundProcessor[StandardEngine[Catalina]]&quot; daemon prio=5 tid=7f8732850800 nid=0x111203000 waiting on condition [111202000]

&quot;main&quot; prio=5 tid=7f8735000800 nid=0x10843e000 runnable [10843c000]
</code></pre>

<p>其中5条是<code>Dameon线程</code>，而对于Java程序来说，当所有<code>非Dameon程序</code>都终止的时候，Jvm就会退出，因此要想终止Tomcat就只需要将<code>main</code>这一条<code>非Dameon线程</code>终止了即可。</p>

<p>Tomcat启动的时候的主线程会在8005端口（默认配置，可以更改）上建立socket监听，当关闭的时候，最终其实就是新起了一个进程然后向Tomcat主线程监听的8005端口发送了一个<code>SHUTDOWN</code>字符串，这样主线程就会结束了，主线程结束了以后，因为其它的线程都是<code>dameon线程</code>，这样依赖Jvm就会退出了。</p>

<p><img src="/img/tomcat8.png" alt=""/></p>

<p>当用户请求服务器的时候，<code>Connector</code>会接受请求，从Socket连接中根据http协议解析出对应的数据，构造<code>Request</code>和<code>Response</code>对象，然后传递给后面的容器处理，顶层容器是<code>StandardEngine</code>，<code>StandardEngine</code>处理请求其实是通过容器的Pipeline进行的，而Pipeline其实最终是通过管道上的各个阀门进行的，当请求到达<code>StandardEngineValve</code>的时候，此阀门<strong>会将请求转发</strong>给对应<code>StandardHost</code>的Pipeline的<strong>第一个阀门处理</strong>，然后以此最终到达<code>StandardHostValve阀门</code>，它<strong>又会将请求转发</strong>给<code>StandardContext</code>的Pipeline的<strong>第一个阀门</strong>，这样以此类推，最后到达<code>StandardWrapperValve</code>，此阀门会根据Request来构建对应的Servelt，并将请求转发给对应的<code>HttpServlet</code>处理。</p>

<h4 id="toc_10">HTTP请求行和请求头</h4>

<pre><code>GET /contextpath/querystring HTTP/1.1

Host: 127.0.0.1:8080

User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:23.0) Gecko/20100101 Firefox/23.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-US,en;q=0.5

Accept-Encoding: gzip, deflate

Cookie: JSESSIONID=9F5897FEF3CDBCB234C050C132DCAE52; __atuvc=384%7C39; __utma=96992031.358732763.1380383869.1381468490.1381554710.38; __utmz=96992031.1380383869.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); Hm_lvt_21e144d0df165d6556d664e2836dadfe=1381330561,1381368826,1381395666,1381554711

Connection: keep-alive

Cache-Control: max-age=0
</code></pre>

<p>其中请求行就是第一行，<code>GET /contextpath/querystring HTTP/1.1</code>,余下的都是请求头。</p>

<p>请求行末尾必须是CRLF，而请求行与请求头，以及请求头之间必须用空行隔开，而空行也必须只包含CRLF。</p>

<p>一个请求解析流程：</p>

<pre><code>org.apache.tomcat.util.net.JIoEndpoint.Acceptor#run
-&gt;org.apache.tomcat.util.net.JIoEndpoint.SocketProcessor#run(请求处理线程池中运行)
--&gt;org.apache.coyote.AbstractProtocol.AbstractConnectionHandler#process
---&gt;org.apache.coyote.http11.AbstractHttp11Processor#process
----&gt;org.apache.coyote.http11.InternalInputBuffer#parseRequestLine
----&gt;org.apache.coyote.http11.InternalInputBuffer#parseHeaders
----&gt;org.apache.catalina.connector.CoyoteAdapter#service
</code></pre>

<p>对于StandardEngine来说有一个与之对应的StandardEngineValve，对于StandardHost有一个StandardHostValve与之对应，StandardContext有一个StandardContextValve与之对应，StandardWrapper与StandardWrapperValve对应</p>

<p>调用链</p>

<pre><code>-&gt;org.apache.catalina.core.StandardEngineValve#invoke
--&gt;org.apache.catalina.valves.AccessLogValve#invoke
---&gt;org.apache.catalina.valves.ErrorReportValve#invoke
----&gt;org.apache.catalina.core.StandardHostValve#invoke
-----&gt;org.apache.catalina.authenticator.AuthenticatorBase#invoke
------&gt;org.apache.catalina.core.StandardContextValve#invoke
-------&gt;org.apache.catalina.core.StandardWrapperValve#invoke
</code></pre>

<p>最后会调用到StandardWrapperValve，它其实也是最终调用Servlet的地方</p>

<p>一个请求过来以后，Tomcat是如何一步步处理的：</p>

<ul>
<li>用户浏览器发送请求，请求会发送到对应的Connector监听的Socket端口。</li>
<li>Connector从Socket流中获取数据，然后根据Http协议将其解析为Request和Reponse对象</li>
<li>找到Request对象对应的Host,Context,Wrapper</li>
<li>调用最终的Servelt的service进行处理。</li>
</ul>

<h5 id="toc_11">Tomcat中ClassLoader的总体结构，</h5>

<p>总结如下： </p>

<ul>
<li><p>在Tomcat存在common,cataina,shared三个公共的classloader，</p>

<p>默认情况下，这三个classloader其实是同一个，都是common classloader,</p></li>
<li><p>而针对每个webapp，也就是context（对应代码中的StandardContext类），都有自己的WebappClassLoader来加载每个应用自己的类。</p></li>
</ul>

<p><img src="/img/tomcat9.png" alt=""/></p>

<p>Tomcat在加载webapp级别的类的时候，<strong>默认是不遵守parent-first</strong>的，这样做的好处是更好的实现了应用的隔离，但是坏处就是加大了内存浪费，同样的类库要在不同的app中都要加载一份。</p>

<p><img src="/img/tomcat10.jpg" alt=""/></p>

<p>们可以看出每一个<code>StandardContext</code>会关联一个Manager,默认情况下Manager的实现类是<code>StandardManager</code>，而<code>StandardManager</code>内部会聚合多个Session，其中<code>StandardSession</code>是Session的默认实现类，当我们调用<code>Request.getSession</code>的时候，Tomcat通过<code>StandardSessionFacade</code>这个外观类将<code>StandardSession</code>包装以后返回。</p>

<p>如果采用<code>LAST_ACCESS_AT_START</code>的时候，那么请求本身的处理时间将不算在内。比如一个请求处理开始的时候是10:00,请求处理花了1分钟，那么如果<code>LAST_ACCESS_AT_START</code>为<code>true</code>，则算是否超期的时候，是从10:00算起，而不是10:01</p>

<p><img src="/img/tomcat11.png" alt=""/></p>

<p>每一个容器都有一个pipeline，而一个pipeline又有多个Valve阀门，其中<code>StandardEngine</code>对应的阀门是<code>StandardEngineValve</code>，<code>StandardHost</code>对应的阀门是<code>StandardHostValve</code>，<code>StandardContext</code>对应的阀门是<code>StandardContextValve</code>，<code>StandardWrapper</code>对应的阀门是<code>StandardWrapperValve</code>。</p>

<p>对于阀门来说有两种，一种阀门在处理完自己的事情以后，只需要将工作委托给下一个和自己在同一管道的阀门，第二种阀门是负责衔接各个管道的，它负责将请求传递给下个管道的第一个阀门处理，这种阀门叫<code>Basic阀门</code>，它是每个管道中最后一个阀门，上面的<code>Standard*Valve</code>都属于第二种阀门。</p>

<h4 id="toc_12">Reference:</h4>

<p><a href="http://imtiger.net/blog/2013/10/16/tomcat-architecture/">http://imtiger.net/blog/2013/10/16/tomcat-architecture/</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/10/25</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14457412437619.html">
                
                  <h1>---</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>layout: post<br/>
title: <q>JVM內存管理</q><br/>
category: Reading Notes</p>

<h2 id="toc_0">tags: [<q>读文章</q>, <q>Java</q>, <q>JVM</q>]</h2>

<p>{% include JB/setup %}</p>

<h2 id="toc_1">JVM內存管理</h2>

<h3 id="toc_2">JVM內存分配</h3>

<p>JVM的內存分配大致如下圖：</p>

<p><img src="/img/JVM%E5%85%A7%E5%AD%98%E7%AE%A1%E7%90%861.png" alt="JVM內存管理"/></p>

<p>其中黃色的是線程共享的，白色是線程私有的。</p>

<p>Memory blocks can be reached in one of two ways if the use program holds a reference to that block in a root, or if there is a reference to that block held in another reachable block.</p>

<h4 id="toc_3">程序計數器（program counter register）</h4>

<p>這個可以認為是一個運行指針，指向下一個要運行的命令。用來實現循環、判讀、線程切換等功能。</p>

<h4 id="toc_4">Java虛擬機棧（Java stack）</h4>

<p>用來存放函數運行狀態，比如函數的變量、返回值類型、動態鏈接等。每個函數開始運行，就會創建一個<code>棧幀</code>，<code>栈帧</code>中包含了局部变量表，操作数栈，方法出口等信息。<code>栈帧</code>然後隨著函數返回，而消亡。</p>

<h4 id="toc_5">本地方法棧（native method stack）</h4>

<p>用來存放native函數的棧，和Java stack功能差不多</p>

<h4 id="toc_6">堆（heap）</h4>

<p>存放幾乎所有object的地方，是一個非常打的內存區域，可以不連續。是GC的主戰場。</p>

<h4 id="toc_7">方法區（method area）</h4>

<p>這部分是存放類的類型數據，比如一個class 的子父類、接口等，以及常量和靜態變量。這部分比較少變化，有人稱他為永久代。GC也會在這裡做一些收集，但是效果一般。</p>

<p>方法区中有一块非常重要的区域<code>运行时常量池</code>，Java Class的文件结构中有一个叫<code>常量池</code>的结构，它主要存放了编译器生成的各种字面常量和符号引用，这部分的内容也将放到<code>运行时常量池</code>。</p>

<h3 id="toc_8">HotSpot JVM内存实现模型</h3>

<p><img src="/img/jvm2.jpg" alt="JVM內存管理"/></p>

<p>HotSpot JVM将堆分成如下三部分：</p>

<ul>
<li><p>新生代（Young）</p>

<p>新生代被划分成三部分，<code>Eden区</code>和两个大小严格相同的<code>Survivor区</code>，其中<code>Survivor区间</code>，某一时刻只有其中一个是被使用的，另一个留作垃圾收集时复制对象用。在<code>Young区间</code>变满的时候，<code>minor GC</code>就会将存活的对象移到空闲的<code>Survivor区间中</code>，根据JVM的策略，在经过几次垃圾收集后，仍然存活于<code>Survivor</code>的对象将被移动到Tenured区间。</p></li>
<li><p>老年代（Tenured）</p>

<p><code>Tenured区</code>主要保存生命周期长的对象，一般是一些老的对象，当一些对象在<code>Young</code>复制转移一定的次数以后，对象就会被转移到<code>Tenured区</code>，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p></li>
<li><p>持久代（Perm）</p>

<p><code>Perm代</code>主要保存<code>class</code>，<code>method</code>，<code>filed</code>对象，这部分的空间一般不会溢出，除非一次性加载了很多的类，不过在设计到热部署的应用服务器的时候，有时候会遇到<code>java.lang.OutOfMemoryError : PermGen space</code>的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的<code>class</code>没有被卸载掉，这样就造成了大量的<code>class</code>对象保存在了<code>perm</code>中，这种情况下，一般重新启动应用服务器可以解决问题。</p></li>
</ul>

<p>HotSpot JVM提供的参数来对内存进行配置：</p>

<ul>
<li><p>配置总内存</p>

<p><code>-Xms</code>：指定了JVM初始启动以后初始化内存</p>

<p><code>-Xmx</code>：指定了JVM堆的最大内存，在JVM启动以后，会分配<code>-Xmx</code>参数指定大小的内存给JVM，但是不一定全部使用，JVM会根据<code>-Xms</code>参数来调节真正用于JVM的内存</p></li>
<li><p>配置新生代 </p>

<p><code>-Xmn</code>: 参数设置了年轻代的大小 </p>

<p><code>-XX:SurvivorRatio</code>: 表示<code>eden</code>和一个<code>surivivor</code>的比例，缺省值为8。假如<code>-XX:SurvivorRatio=32</code>意味着<code>eden</code>和一个<code>survivor</code>的比值是32：1，这样一个<code>Survivor</code>就占<code>Young区</code>的1/34.</p></li>
<li><p>配置老年代 </p>

<p><code>-XX:NewRatio</code>: 表示<code>年老年代</code>和<code>新生代</code>内存的比例，缺省值为2.假如<code>-XX:NewRatio=8</code>意味着<code>tenured</code>和<code>young</code>的比值8：1</p></li>
<li><p>配置持久代</p>

<p><code>-XX:MaxPermSize</code>：表示持久代的最大值</p></li>
</ul>

<h3 id="toc_9">GC</h3>

<h4 id="toc_10">GC方法</h4>

<p>Java採用了根搜索方法GC，一般是從GC根開始全部搜索一遍，沒有被搜索到的，都是垃圾，可以被清理。這種算法可以消除循環引用造成的影響。也就是循環引用的對象依然會被GC。GC root包括以下四種：</p>

<ul>
<li>棧中的變量引用的對象</li>
<li>方法區中的靜態屬性引用的對象</li>
<li>方法區中的常量引用的對象</li>
<li>JNI引用的對象</li>
</ul>

<h4 id="toc_11">垃圾收集策略</h4>

<ul>
<li><p>Reference Counting（引用计数）</p>

<p>这种方式在每一个对象中增加一个引用的计数，这个计数代表当前程序有多少个引用引用了此对象，如果此对象的引用计数变为0，那么此对象就可以作为垃圾收集器的目标对象来收集。</p>

<p>Each object has an associated reference count the number of active references to that object. Each time a pointer reference is modified, such as through an assignment statement, or when a reference goes out of scope, the compiler must generate code to update the referenced object&#39;s reference count.</p>

<p>优点：简单，直接，不需要暂停整个应用</p>

<p>缺点：需要编译器的配合，编译器要生成特殊的指令来进行计数的操作，比如每次将对象赋值给新的引用，或者对象的引用超出了作用域等。</p>

<p>None of the standard garbage collectors in the JDK uses reference counting; instead, they all use come form of tracing collector.</p></li>
<li><p>跟踪收集器</p>

<p>跟踪收集器<strong>首先要暂停整个应用程序</strong>，然后开始<strong>从根对象扫描整个堆，判断扫描的对象是否有对象引用</strong>。 如果每次扫描整个堆，那么势必让GC的时间变长，从而影响了应用本身的执行。因此在JVM里面采用了<strong>分代收集</strong>，在新生代收集的时候<code>minor gc</code>只需要扫描新生代，而不需要扫描老生代。</p>

<p>JVM采用了分代收集以后，<code>minor gc</code>只扫描新生代，但是<code>minor gc</code>怎么判断是否有老生代的对象引用了新生代的对象，JVM采用了卡片标记的策略，<strong>卡片标记</strong>将老生代分成了一块一块的，划分以后的每一个块就叫做一个卡片，JVM采用卡表维护了每一个块的状态，当JAVA程序运行的时候，<strong>如果发现老生代对象引用或者释放了新生代对象的引用，那么就JVM就将卡表的状态设置为脏状态，这样每次minor gc的时候就会只扫描被标记为脏状态的卡片，而不需要扫描整个堆</strong>。</p></li>
</ul>

<p><img src="/img/jvm3.png" alt="JVM內存管理"/></p>

<h5 id="toc_12">在Java中的引用可以分为一下几种：</h5>

<ol>
<li>Strong Reference(强引用)</li>
</ol>

<p>强引用是JAVA中默认采用的一种方式，我们平时创建的引用都属于强引用。如果一个对象没有强引用，那么对象就会被回收。</p>

<ol>
<li>Soft Reference(软引用) </li>
</ol>

<p>软引用的对象在GC的时候不会被回收，只有当内存不够用的时候才会真正的回收，因此软引用适合缓存的场合，这样使得缓存中的对象可以尽量的再内存中待长久一点。 </p>

<ol>
<li>Weak Reference(弱引用)</li>
</ol>

<p>弱引用有利于对象更快的被回收，假如一个对象没有强引用只有弱引用，那么在GC后，这个对象肯定会被回收。</p>

<ol>
<li>Phantom reference(幽灵引用) </li>
</ol>

<p>幽灵引用说是引用，但是你不能通过幽灵引用来获取对象实例，它主要目的是为了当设置了幽灵引用的对象在被回收的时候可以收到通知。 </p>

<h4 id="toc_13">GC算法</h4>

<p>GC有多個算法，適用不同的環境</p>

<h5 id="toc_14">標記清除</h5>

<p>the most basic form of tracing collector</p>

<p>也就是標記垃圾，然後全部清除。缺點是：效率不高、空間碎片</p>

<p>从根扫描每个活跃的对象，然后标记扫描过的对象，标记完成以后，清除那些没有被标记的对象。</p>

<p>the world is stopped and the collector visits each live node, starting from the roots, and marks each node it visits</p>

<p>When there are no more references to follow, collection is complete, and then the heap is swept (every object in the heap is examined), and any object not marked is reclaimed as garbage and returned to the free list.</p>

<p><img src="/img/jvm7.png" alt=""/></p>

<p>优点：解决循环引用的问题；不需要编译器的配合</p>

<p>缺点：每个活跃的对象都要进行扫描 (every active object, whether reachable or not, is visited during the sweep phase)，收集暂停的时间比较长。</p>

<p>Because a significant percentage of objects are likely to be garbage, this means that the collector is spending considerable effort examining and handling garbage.</p>

<p>Mark-sweep collectors also tend to have the heap fragmented, which can cause locality issues and can also cause allocation failures even when sufficient free memory appears to be available.</p>

<h5 id="toc_15">複製</h5>

<p>another form of tracing collector.</p>

<p>內存一分為二，只使用一塊（某一时刻，只有一个空间处于活跃的状态），然後在GC時把一塊內容中存活的對象拷貝到另一個區域。缺點是浪費了一半內存</p>

<p>When the active space fills up, the world is stopped and live objects are copied from the active space into the inactive space. The roles of the spaces are then flipped, with the old inactive space becoming the new active space.</p>

<p>优点：只扫描可以到达的对象，不需要扫描所有的对象，从而减少了应用暂停的时间</p>

<p>only visiting live objects, which means garbage objects will not be examined, nor will they need to be paged into memory or brought into the cache.</p>

<p>the set of live objects are compacted into the bottom of the heap. This not only improves locality of reference of the user program and eliminates heap fragmentation, but also greatly reduces the cost of object allocation object allocation becomes a simple pointer addition on the top-of-heap pointer.</p>

<p>缺点：需要额外的空间消耗，某一时刻，总是有一块内存处于未使用状态；复制对象需要一定的开销</p>

<h5 id="toc_16">標記整理</h5>

<p>The copying algorithm has excellent performance characteristics, but it has the drawback of requiring twice as much memory as a mark sweep collector.</p>

<p>和標記清除類似，但是不清除，而是把存活的對象向一邊移動，這樣就避免了碎片化。</p>

<p>它分两个阶段执行，在第一个阶段，首先扫描所有活跃的对象，并标记所有活跃的对象，第二个阶段首先清除未标记的对象，然后将活跃的对象复制到堆的底部。</p>

<p>Mark-compact is a two phase process, where each live object is visited and marked in the marking phase. Then, marked objects are copied such that all the live objects are compacted at the bottom of the heap. If a complete compaction is performed at every collection, the resulting heap is similar to the result of a copying collector  there is a clear demarcation between the active portion of the heap and the free area, so that allocation costs are comparable to a copying collector. Long-lived objects tend to accumulate at the bottom of the heap, so they are not copied repeatedly as they are in a copying collector.</p>

<h5 id="toc_17">分代收集</h5>

<p>意思就是堆分成多個區域，每個區域採用不同的算法。一般分為新生代和老年代。新生就是存活不久的對象，老年代反之。</p>

<p>新生代一般採用複製算法，老年代採用標記整理或者標記清除算法。</p>

<h4 id="toc_18">HotSpot JVM垃圾收集策略</h4>

<p>GC执行时要耗费一定的CPU资源和时间</p>

<h5 id="toc_19">串行收集器（Serial Collector）</h5>

<p>Serial Collector是指任何时刻都只有一个线程进行垃圾收集。</p>

<p>它需要停止整个应用的执行。这种类型的收集器适合于单CPU的机器。</p>

<p>Serial Collector有如下两个：</p>

<ul>
<li><p>Serial Copying Collector：</p>

<p>此种GC用<code>-XX:UseSerialGC</code>选项配置，它只用于<code>新生代</code>对象的收集。</p>

<p><code>-XX:MaxTenuringThreshold</code>来设置对象复制的次数。当<code>eden空间</code>不够的时候，GC会将<code>eden</code>的活跃对象和一个名叫<code>From survivor空间</code>中尚不够资格放入<code>Old代</code>的对象复制到另外一个名字叫<code>To Survivor空间</code>。而此参数就是用来说明到底<code>From survivor</code>中的哪些对象不够资格，假如这个参数设置为31，那么也就是说只有对象复制31次以后才算是有资格的对象。</p></li>
</ul>

<blockquote>
<p><code>From Survivor</code>和<code>To Survivor</code>的角色是不断的变化的，同一时间只有一块空间处于使用状态，这个空间就叫做<code>From Survivor</code>区，当复制一次后角色就发生了变化。</p>

<p>如果复制的过程中发现<code>To Survivor</code>空间已经满了，那么就直接复制到<code>Old Generation</code></p>

<p>比较大的对象也会直接复制到<code>Old Generation</code>，在开发中，我们应该尽量避免这种情况的发生。</p>
</blockquote>

<h4 id="toc_20">并行收集器（Parallel Collector）</h4>

<p>Parallel Collector主要是为了应对多CPU，大数据量的环境</p>

<p>Parallel Collector又可以分为以下三种：</p>

<ul>
<li><p>Parallel Copying Collector</p>

<p>此种GC用<code>-XX:UseParNewGC</code>参数配置,它主要用于新生代的收集,此GC可以配合CMS一起使用</p></li>
<li><p>Parallel Mark-Compact Collector</p>

<p>此种GC用<code>-XX:UseParallelOldGC</code>参数配置，此GC主要用于老生代对象的收集。</p></li>
<li><p>Parallel scavenging Collector</p>

<p>此种GC用<code>-XX:UseParallelGC</code>参数配置，它是对新生代对象的垃圾收集器，但是它不能和CMS配合使用，它适合于比较大新生代的情况</p></li>
</ul>

<p><img src="/img/jvm4.png" alt=""/></p>

<h5 id="toc_21">并发收集器（Concurrent Collector)</h5>

<p><code>Concurrent Collector</code>通过并行的方式进行垃圾收集，这样就减少了垃圾收集器收集一次的时间，在HotSpot JVM中，我们称之为CMS GC，这种GC在实时性要求高于吞吐量的时候比较有用。此种GC可以用参数<code>-XX:UseConcMarkSweepGC</code>配置，此GC主要用于老生代和Perm代的收集。</p>

<p><img src="/img/jvm5.png" alt=""/></p>

<p>CMS GC有可能出现并发模型失败：</p>

<blockquote>
<p>并发模型失败：我们CMS GC在运行的时候，用户线程也在运行，当gc的速度比新增对象的速度慢的时候，或者说当正在GC的时候，老年代的空间不能满足用户线程内存分配的需求的时候，就会出现并发模型失败，出现并发模型失败的时候，JVM会触发一次<code>stop-the-world</code>的Full GC这将导致暂停时间过长。不过CMS GC提供了一个参数<code>-XX:CMSInitiatingOccupancyFraction</code>来指定当老年代的空间超过某个值的时候即触发GC。因此如果此参数设置的过高，可能会导致更多的并发模型失败。</p>
</blockquote>

<p>并发和并行收集器区别：</p>

<blockquote>
<p>对于并发和并行收集器，我们需要注意一点：并发收集器是指垃圾收集器线程和应用线程可以并发的执行，也就是清除的时候不需要<code>stop the world</code>，但是并行收集器指的的是可以多个线程并行的进行垃圾收集，并行收集器还是要暂停应用的（即所谓的<code>stop the world</code>）</p>
</blockquote>

<p>下面我们通过下图来形象的描述一下哪些收集器可以配对使用</p>

<p><img src="/img/jvm6.png" alt=""/></p>

<h4 id="toc_22">不同情况下的垃圾收集配置策略</h4>

<h5 id="toc_23">吞吐量优先</h5>

<p>吞吐量是指GC的时间与运行总时间的比值，比如系统运行了100分钟，而GC占用了一分钟，那么吞吐量就是99%。</p>

<p>吞吐量优先一般运用于对响应性要求不高的场合，比如web应用，因为网络传输本来就有延迟的问题，GC造成的短暂的暂停使得用户以为是网络阻塞所致。</p>

<p>吞吐量优先可以通过<code>-XX:GCTimeRatio</code>来指定。当通过<code>-XX:GCTimeRatio</code>不能满足系统的要求以后，我们可以更加细致的来对JVM进行调优。</p>

<p>首先因为要求高吞吐量，这样就需要一个较大的<code>Young generation</code>，此时就需要引入<code>Parallel scavenging Collector</code>,可以通过参数：<code>-XX:UseParallelGC</code>来配置。</p>

<pre><code>java -server -Xms3072m -Xmx3072m -XX:NewSize=2560m -XX:MaxNewSize=2560 XX:SurvivorRatio=2 - XX:+UseParallelGC
</code></pre>

<p><strong>控制并行的线程数</strong></p>

<p>缺省情况下，<code>Parallel scavenging Collector</code>会开启与cpu数量相同的线程进行并行的收集，但是也可以调节并行的线程数。假如你想用4个并行的线程去收集<code>Young generation</code>的话，那么就可以配置<code>-XX:ParallelGCThreads=4</code>,此时JVM的配置参数如下：</p>

<pre><code>java -server -Xms3072m -Xmx3072m -XX:NewSize=2560m -XX:MaxNewSize=2560 XX:SurvivorRatio=2 -XX:+UseParallelGC -XX:ParallelGCThreads=4
</code></pre>

<p><strong>自动调节新生代</strong></p>

<p>在采用了<code>Parallel scavenge collector</code>后，此GC会根据运行时的情况自动调节survivor ratio来使得性能最优，因此<code>Parallel scavenge collector</code>应该总是开启此参数。此时JVM的参数配置如下：</p>

<pre><code>java -server -Xms3072m -Xmx3072m -XX:+UseParallelGC -XX:ParallelGCThreads=4 -XX:+UseAdaptiveSizePolicy
</code></pre>

<h5 id="toc_24">响应时间优先</h5>

<p>响应时间优先是指GC每次运行的时间不能太久，这种情况一般使用与对及时性要求很高的系统，比如股票系统等。</p>

<p>响应时间优先可以通过参数<code>-XX:MaxGCPauseMillis</code>来配置，配置以后JVM将会自动调节年轻代，老生代的内存分配来满足参数设置。</p>

<p>在一般情况下，JVM的默认配置就可以满足要求，只有默认配置不能满足系统的要求时候，才会根据具体的情况来对JVM进行性能调优。如果采用默认的配置不能满足系统的要求，那么此时就可以自己动手来调节。此时<br/>
<code>Young generation</code>可以采用<br/>
<code>Parallel copying collector</code>，而<code>Old generation</code>则可以采用<code>Concurrent Collector</code>.</p>

<p>举个例子来说，以下参数设置了新生代用<code>Parallel Copying Collector</code>，老生代采用CMS收集器。</p>

<pre><code>java -server -Xms512m -Xmx512m  -XX:NewSize=64m -XX:MaxNewSize=64m -XX:SurvivorRatio=2  -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
</code></pre>

<blockquote>
<p>此时需要注意两个问题：</p>

<p>1.如果没有指定<code>-XX:+UseParNewGC</code>，则采用默认的非并行版本的copy collector.</p>

<p>2.如果在一个单CPU的系统上设置了<code>-XX:+UseParNewGC</code> ,则默认还是采用缺省的copy collector.</p>
</blockquote>

<p><strong>控制并行的线程数</strong></p>

<p>默认情况下，Parallel copy collector启动和CPU数量一样的线程，也可以通过参数<code>-XX:ParallelGCThreads</code>来指定，比如你想用3个线程去进行并发的复制收集，那么可以改变上述参数如下：</p>

<pre><code>java -server -Xms512m -Xmx512m -XX:NewSize=64m  -XX:MaxNewSize=64m -XX:SurvivorRatio=2        -XX:ParallelGCThreads=4 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
</code></pre>

<p><strong>控制并发收集的临界值</strong></p>

<p>默认情况下，CMS gc在<code>old generation</code>空间占用率高于68%的时候，就会进行垃圾收集，而如果想控制收集的临界值，可以通过参数：<code>-XX:CMSInitiatingOccupancyFraction</code>来控制，比如改变上述的JVM配置如下：</p>

<pre><code>java -server -Xms512m -Xmx512m -XX:NewSize=64m -XX:MaxNewSize=64m -XX:SurvivorRatio=2  -XX:ParallelGCThreads=4 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:CMSInitiatingOccupancyFraction=35
</code></pre>

<p>此外顺便说一个参数：<code>-XX:+PrintCommandLineFlags</code>通过此参数可以知道在没有显示指定内存配置和垃圾收集算法的情况下，JVM采用的默认配置。</p>

<p>When it comes to garbage collection we play with 3 major variables that set targets for collectors:</p>

<ul>
<li>Throughput: The amount of work done by an application as a ratio of time spent in GC. Target throughput with <code>-XX:GCTimeRatio = 99</code>; 99 is the default equating to 1% GC time</li>
<li>Latency: The time taken by systems in responding to events which is impacted by pauses introduced by garbage collection. Target latency for GC pauses with <code>-XX:MaxGCPauseMillis = &lt;n&gt;</code></li>
<li>Memory: The amount of memory our systems use to store state, which is often copied and moved around when being managed. The set of active objects remained by the application at any point in time is known as the Live Set. </li>
</ul>

<p>We should not interpret the term &#39;real-time&#39; to mean the lowest possible latency; rather real time refers to having deterministic latency regardless of throughput.</p>

<p>Tradeoffs often play out as follows:</p>

<ul>
<li>To a large extent the cost of garbage collection, as an amortized cost, can be reduced by providing the garbage collection algorithms with more memory</li>
<li>The observed worst case latency inducing pauses due to garbage collecting can be reduced by containing the live set and keeping the heap size small</li>
<li>The frequency with which pauses occur can be reduced by managing the heap and generation sizes, and by controlling the application&#39;s object allocation rate</li>
<li>The frequency of large pauses can be reduced by concurrently running the GC with the application, sometimes at the expense of throughput</li>
</ul>

<p>Garbage colletion algorithms are often optimised with the expectation that most objects live for a very short period of time, while relatively few live for very long.</p>

<p>Hotspot garbage collectors record the age of an object in terms of the number of GC cycles survived.</p>

<p>Older generations are less sparse, and as a result the efficiency of older generation collection algorithms tends to be much lower. Generational garbage collectors tend to operate in two distinct collection cycles: Minor collections, when short lived objects are collected, and the less frequent Major collections, when the older regions are collected.</p>

<h4 id="toc_25">Stop-The-World Events</h4>

<p>For garbage collectors to operate &#39;Stop-The-World Event&#39; is necessary, for practical engineering reasons, to periodically stop the running application so that memory can be managed.</p>

<p>To bring an application to a total stop it is necessary to pause all the running threads. Garbage collectors do this by signaling the threads to stop when they come to a &#39;safepoint&#39;, which is a point during program execution at which all GC roots are known and all heap object contents are consistent.</p>

<p>Depending on what a thread is doing it may take some time to reach a safepoint. Safepoint checks are normally performed on method returns and loop back edges, but can be optimized away in some places making them more dynamically rare. </p>

<p>Time To Safepoint (TTSP) is an important consideration in low-latency applications. This time can be surfaced by enabling the <code>-XX:+PrintGCApplicationStoppedTime</code> flag in addition to the other GC flags</p>

<p>Eden is the region where most objects are initially allocated. The survivor spaces are a temporary store for objects that have survived a collection of the Eden space. Collectively Eden and Survivor spaces are known as the &#39;young&#39; and &#39;new&#39; generation.</p>

<p>Objects that live long enough are eventually promoted to the tenured space.</p>

<p>The perm generation is where the runtime stores objects it &#39;knows&#39; to be effectively immortal, such as Classes and static Strings. </p>

<h4 id="toc_26">Object Allocation</h4>

<p>To avoid contention each thread is assigned a Thread Local Allocation Buffer (TLAB) from which it allocates objects. Using TLABs allows object allocation to scale with number of threads by avoiding contention on a single memory resource. </p>

<p>When a TLAB is exhausted a thread simply requests a new one from the Eden space. When Eden has been filled a minor collection commences. </p>

<p><img src="/img/jvm8.png" alt=""/></p>

<h4 id="toc_27">Minor Collections</h4>

<p>A minor collection is triggered when Eden becomes full. This is done by copying all the live objects in the new generation to either a survivor space or the tenured space as appropriate.Copying to the tenured space is known as promotion or tenuring. Promotion occurs for objects that are sufficiently old (<code>-XX:MaxTenuringThreshold=&lt;n&gt;</code>), or when the survivor space overflows.</p>

<p>Live objects are objects that are reachable by the application, any other objects cannot be reached and can therefore be considered dead. In a minor collection, the copying of live objects is performed by first following what are known as GC Roots, and iteratively copying anything reachable to the survivor space.</p>

<p>In generational collection, the GC Roots for the new generation&#39;s reachable object graph also include any references from the old generation to the new generation. These references must also be processed to make sure all reachable objects in the new generation survive the minor collection. Identifying these cross-generational references is achieved by use of a &#39;card table&#39;.</p>

<p>There are two survivor spaces in the Hotspot new generation, which alternate in their &#39;to-space&#39; and &#39;from-space&#39; roles. At the beginning of a minor collction, the to-space survivor space is always empty, and acts as a target copy area for the minor collection. The previous minor collection&#39;s target survivor space is part of the from-space, which also includes Eden, where live objects that need to be copied may be found.</p>

<p>The cost of a minor GC collection is usually dominated by the cost of copying obejcts to the survivor and tenured spaces. The work done during a minor collection is directly proportional to the number of live objects found, and not to the size of the new generation. The totla time spent doing mimor collections can be almost be halved each time the Eden size is doubled. Memory can therefore be traded for throughput. A doubling of Eden size will result in an increase in collection time per-collection cycle, but this is relatively small if both the number of objects being promoted and size of the old generation is constant.</p>

<h4 id="toc_28">Major collections</h4>

<p>Major collections collect the old generation so that objects can be promoted from the young generation.</p>

<p>The old generation collector will try to predict when it needs to collect to avoid a promotion failure from the young generation. The collectors track a fill threshold for the old generation and begin collection when this threshold is passed. If this threshold is not sufficient to meet promotion requirements then a &#39;FullGC&#39; is triggered. A FullGC involves promoting all live objects from the young generations followed by a collection and compaction of the old generation.</p>

<p>To avoid promotion failure you will need to tune the padding that the old generation allows to accommodate promotions (<code>-XX:PromotedPadding=&lt;n&gt;</code>)</p>

<h4 id="toc_29">Serial Collector</h4>

<p>It uses a single thread for both minor and major collections. Objects are allocated in the tenured space using a simple bump the pointer algorithem. Major collections are triggered when the tenured space is full.</p>

<h4 id="toc_30">Reference:</h4>

<p><a href="http://imtiger.net/blog/2010/02/21/jvm-memory-and-gc-2/">http://imtiger.net/blog/2010/02/21/jvm-memory-and-gc-2/</a></p>

<p><a href="http://imtiger.net/blog/2010/02/21/jvm-memory-and-gc-1/">http://imtiger.net/blog/2010/02/21/jvm-memory-and-gc-1/</a></p>

<p><a href="http://www.ibm.com/developerworks/library/j-jtp10283/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j">http://www.ibm.com/developerworks/library/j-jtp10283/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/10/25</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14457412437495.html">
                
                  <h1>---</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>layout: post<br/>
title: <q>Java Classloader机制</q><br/>
category: Reading Notes</p>

<h2 id="toc_0">tags: [<q>读文章</q>, “Java”]</h2>

<p>{% include JB/setup %}</p>

<h2 id="toc_1">Java Classloader机制</h2>

<p>Java类加载器基于三个机制：委托、可见性和单一性。</p>

<ul>
<li>委托机制是指将加载一个类的请求交给父类加载器，如果这个父类加载器不能够找到或者加载这个类，那么再加载它。</li>
<li>可见性的原理是子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类。</li>
<li>单一性原理是值仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。</li>
</ul>

<h4 id="toc_2">什么是类加载器</h4>

<p>类加载器是一个用来加载类文件的类。Java源代码通过javac编译器编译成类文件，然后JVM来执行类文件中的字节码来执行程序。类加载器负责加载文件系统、网络或者其他来源的类文件。</p>

<p>有三种默认使用的类加载器：<code>Bootstrap类加载器</code>、<code>Extension类加载器</code>和<code>System类加载器</code>（或者叫做<code>Application类加载器</code>）。每种类加载器都有设定好从哪里加载类。</p>

<p><img src="/img/java_classloader1.png" alt=""/></p>

<h4 id="toc_3">类加载器的工作原理</h4>

<h5 id="toc_4">委托机制</h5>

<p>假设你有一个应用需要的类叫作<code>Abc.class</code>，</p>

<ul>
<li>首先加载这个类的请求由<code>Application类加载器</code>委托给它的父类加载器<code>Extension类加载器</code>，</li>
<li>然后再委托给<code>Bootstrap类加载器</code>。<code>Bootstrap类加载器</code>会先看看<code>rt.jar</code>中有没有这个类，</li>
<li>因为并没有这个类，所以这个请求由回到<code>Extension类加载器</code>，它会查看<code>jre/lib/ext</code>目录下有没有这个类，</li>
<li>如果这个类被<code>Extension类加载器</code>找到了，那么它将被加载，而<code>Application类加载器</code>不会加载这个类；</li>
<li>而如果这个类没有被<code>Extension类加载器</code>找到，那么再由<code>Application类加载器</code>从<code>classpath</code>中寻找。记住<code>classpath</code>定义的是类文件的加载目录，而PATH是定义的是可执行程序如javac，java等的执行路径。</li>
</ul>

<h5 id="toc_5">可见性机制</h5>

<p>根据可见性机制，子类加载器可以看到父类加载器加载的类，而反之则不行。</p>

<p>下面的例子中，当<code>Abc.class</code>已经被<code>Application类加载器</code>加载过了，然后如果想要使用<code>Extension类加载器</code>（<code>ClassLoaderTest.class.getClassLoader().getParent()</code>）加载这个类，将会抛出<code>java.lang.ClassNotFoundException</code>异常。</p>

<pre><code>import java.util.logging.Level;
import java.util.logging.Logger;

/**
* Java program to demonstrate How ClassLoader works in Java,
* in particular about visibility principle of ClassLoader.
*
* @author Javin Paul
*/
public class ClassLoaderTest {
    public static void main(String args[]) {
        try {          
            //printing ClassLoader of this class
            System.out.println(&quot;ClassLoaderTest.getClass().getClassLoader() : &quot;
                             + ClassLoaderTest.class.getClassLoader());

            //trying to explicitly load this class again using Extension class loader
            Class.forName(&quot;test.ClassLoaderTest&quot;, true
                        ,  ClassLoaderTest.class.getClassLoader().getParent());
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(ClassLoaderTest.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
}
</code></pre>

<h5 id="toc_6">单一性机制</h5>

<p>父加载器加载过的类不能被子加载器加载第二次。</p>

<p>Java中<code>ClassLoader</code>的加载采用了双亲委托机制，采用双亲委托机制加载类的时候采用如下的几个步骤：</p>

<ul>
<li><p>当前<code>ClassLoader</code>首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类</p>

<p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</p></li>
<li><p>当前<code>ClassLoader</code>的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到<code>bootstrap ClassLoader</code></p></li>
<li><p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p></li>
</ul>

<h5 id="toc_7">命名空间</h5>

<p>要确定一个类，需要类的全限定名以及加载此类的<code>ClassLoader</code>来共同确定。也就是说即使两个类的全限定名是相同的，但是因为不同的<code>ClassLoader</code>加载了此类，那么在JVM中它是不同的类。</p>

<p>采用了委托模型以后加大了不同的<code>ClassLoader</code>的交互能力，比如<code>hashmap</code>，<code>linkedlist</code>等，这些类由<code>bootstrap</code>类加载器加载了以后，无论你程序中有多少个类加载器，这些类都是可以共享的，这样就避免了不同的类加载器加载了同样名字的不同类以后造成的混乱。</p>

<h4 id="toc_8">自定义ClassLoader</h4>

<h5 id="toc_9">loadClass方法</h5>

<pre><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
     return loadClass(name, false);
}

protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)
  throws ClassNotFoundException
{
    // First, check if the class has already been loaded
    Class c = findLoadedClass(name);//检查class是否已经被加载过了
    if (c == null) {
          try {
          if (parent != null) {
              c = parent.loadClass(name, false); //如果没有被加载，且指定了父类加载器，则委托父加载器加载。
          } else {
              c = findBootstrapClass0(name);//如果没有父类加载器，则委托bootstrap加载器加载
          }
          } catch (ClassNotFoundException e) {
              // If still not found, then invoke findClass in order
              // to find the class.
              c = findClass(name);//如果父类加载没有加载到，则通过自己的findClass来加载。
          }
      }
      if (resolve) {
          resolveClass(c);
      }
      return c;
}
</code></pre>

<p><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>没有被标记为<code>final</code>，也就意味着我们是可以override这个方法的，也就是说双亲委托机制是可以打破的</p>

<h5 id="toc_10">findClass</h5>

<p><code>java.lang.ClassLoader</code>的源代码，我们发现<code>findClass</code>的实现如下：</p>

<pre><code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
  throw new ClassNotFoundException(name);
}
</code></pre>

<p>此方法默认的实现是直接抛出异常，我们可以override这个方法。</p>

<p><strong>我们在写自己的ClassLoader的时候，如果想遵循双亲委托机制，则只需要override findClass</strong></p>

<h5 id="toc_11">defineClass</h5>

<p><code>defineClass</code>的源代码：</p>

<pre><code>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)
  throws ClassFormatError{
      return defineClass(name, b, off, len, null);
}
</code></pre>

<p>从上面的代码我们看出此方法被定义为了<code>final</code>，这也就意味着此方法不能被Override，其实这也是jvm留给我们的唯一的入口，通过这个唯一的入口，j<strong>vm保证了类文件必须符合Java虚拟机规范规定的类的定义。此方法最后会调用native的方法来实现真正的类的加载工作。</strong></p>

<p>你完全可以自己写一个<code>classLoader</code>来加载自己写的<code>java.lang.String</code>类，但是你会发现也不会加载成功，具体就是因为针对<code>java.*</code>开头的类，jvm的实现中已经保证了必须由<code>bootstrp</code>来加载。</p>

<h4 id="toc_12">Reference：</h4>

<p><a href="http://imtiger.net/blog/2009/11/09/java-classloader/">http://imtiger.net/blog/2009/11/09/java-classloader/</a></p>

<p><a href="http://www.importnew.com/6581.html">http://www.importnew.com/6581.html</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/10/25</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_19.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_21.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>NathanCHEN</h1>
                <div class="site-des"></div>
                <div class="social">











  <a class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>
              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="JavaScript.html"><strong>JavaScript</strong></a>
        
            <a href="Ngnix.html"><strong>Ngnix</strong></a>
        
            <a href="tomcat.html"><strong>tomcat</strong></a>
        
            <a href="spring.html"><strong>spring</strong></a>
        
            <a href="RabbitMQ.html"><strong>RabbitMQ</strong></a>
        
            <a href="ELK.html"><strong>ELK</strong></a>
        
            <a href="TCP/IP.html"><strong>TCP/IP</strong></a>
        
            <a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"><strong>源码阅读</strong></a>
        
            <a href="others.html"><strong>others</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="PAXOS.html"><strong>PAXOS</strong></a>
        
            <a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html"><strong>深入分析Java Web技术内幕</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14590098445355.html">应用多级缓存模式支撑海量读服务</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14589988314853.html">浅谈Web缓存</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14588873943004.html">深入分析`Java I/O`的工作机制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14588864645651.html">深入Web请求过程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14588864364518.html">I</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
