<!doctype html>
<html class="no-js" lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>
        
        NathanCHEN
        
    </title>
    
    
    <link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css"/>
    <link rel="stylesheet" href="asset/css/docs.css"/>
    <link rel="stylesheet" href="asset/css/my.css"/>
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>

</head>
<body class="antialiased hide-extras">

<div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">


        <nav class="top-bar docs-bar hide-for-small" data-topbar>


            <section class="top-bar-section">
                <div class="row">
                    <div style="position: relative;width:100%;">
                        <div style="position: absolute; width:100%;">
                            <ul id="main-menu" class="left">
                                <li id="menu_item_index"><a href="index.html">HOME</a></li>
                                <li id="menu_item_archives"><a href="archives.html">Archives</a></li>
                                <li id="menu_item_about"><a href="about.html">ABOUT</a></li>
                            </ul>

                            <ul class="right" id="search-wrap">
                                <li>
                                    <form target="_blank" action="http://google.com/search" method="get">
                                        <input type="hidden" name="q" value="site:nathanchen.github.io"/>
                                        <input tabindex="1" type="search" name="q" placeholder="Search"/>
                                    </form>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

        </nav>

        <nav class="tab-bar show-for-small">
            <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
                <span> &nbsp; NathanCHEN</span>
            </a>
        </nav>

        <aside class="left-off-canvas-menu">
            <ul class="off-canvas-list">

                <li><a href="index.html">HOME</a></li>
                <li><a href="archives.html">Archives</a></li>
                <li><a href="about.html">ABOUT</a></li>

                <li><label>Categories</label></li>

                
                <li><a href="Java.html">Java</a></li>
                
                <li><a href="JavaScript.html">JavaScript</a></li>
                
                <li><a href="Ngnix.html">Ngnix</a></li>
                
                <li><a href="tomcat.html">tomcat</a></li>
                
                <li><a href="spring.html">spring</a></li>
                
                <li><a href="RabbitMQ.html">RabbitMQ</a></li>
                
                <li><a href="ELK.html">ELK</a></li>
                
                <li><a href="TCP/IP.html">TCP/IP</a></li>
                
                <li><a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html">源码阅读</a></li>
                
                <li><a href="others.html">others</a></li>
                
                <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
                
                <li><a href="PAXOS.html">PAXOS</a></li>
                
                <li><a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html">深入分析Java Web技术内幕</a></li>
                

            </ul>
        </aside>

        <a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
 <script type="text/javascript">
    $(function () {
        $('#menu_item_index').addClass('is_active');
    });
</script>
<div class="row">
    <div class="large-8 medium-8 columns">
        <div class="markdown-body home-categories">
            
            <div class="article">
                <a class="clearlink" href="14576660245189.html">
                    
                    <h1>垃圾收集器与内存分配策略</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p>程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性。</p>

<p>而<strong><code>Java</code>堆和方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，<strong>这部分内存的分配和回收都是动态的</strong>，<strong>垃圾收集器所关注的是这部分内存</strong>。</p>

<h4 id="toc_0">引用技术算法</h4>

<p><strong>虚拟机并不是通过引用计数算法来判断对象是否存活的</strong>。</p>

<h4 id="toc_1">根搜索算法</h4>

<p>通过一系列的名为<code>CG Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用连（<code>Reference Chain</code>），<strong>当一个对象到<code>GC Roots</code>没有任何引用连相连时，则证明此对象是不可用的</strong>。</p>

<h4 id="toc_2">再谈引用</h4>

<ul>
<li>强引用：<strong>类似<code>Object obj = new Object()</code>这类的引用</strong>，只要强引用还存在，垃圾收集器永远不会回收掉引用的对象</li>
<li>软引用：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，<strong>在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收</strong>。</li>
<li>弱引用：用来描述非必需对象，它的强度比软引用更弱。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。</li>
<li>虚引用：也称为幽灵引用或者幻影引用。它是最弱的一种引用关系。<strong>为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知</strong>。</li>
</ul>

<h4 id="toc_3">生存还是死亡</h4>

<p>在根搜索算法中不可达的对象，它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被<strong>第一次标记并且进行一次筛选</strong>，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>

<p>如果这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条虚拟机自动建立的，低优先级的<code>Finalizer</code>线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。稍后<code>GC</code>将对<code>F-Queue</code>中的对象<strong>进行第二次小规模的标记</strong>，只要对象能重新与引用链上的任何一个对象建立关联即可。</p>

<h4 id="toc_4">回收方法区</h4>

<p>方法区（或者<code>HotSpot</code>虚拟机中的永久机）的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>

<p>回收废弃常量与回收<code>Java</code>堆中的对象非常类似。例如一个字符串<code>abc</code>已经进入了常量池中，但是没有任何<code>String</code>对象引用常量池中的<code>abc</code>常量，也没有其他地方引用了这个字面量，如果在这个时候发生内存回收，而且必要的话，这个<code>abc</code>常量就会被系统清除出了常量池。</p>

<p>判定一个常量是否是“废弃常量”比较简单，而要<strong>判定一个类是否是“无用的类”的条件</strong>则相对苛刻。类要同时满足下面三个条件才能算是“无用的类”：</p>

<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是<code>Java</code>堆中不存在该类的任何实例</li>
<li><strong>加载该类的<code>ClassLoader</code>已经被回收</strong></li>
<li><strong>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法</li>
</ul>

<h3 id="toc_5">垃圾收集算法</h3>

<h4 id="toc_6">标记 - 清除算法</h4>

<p>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p>

<p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致：当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>

<h4 id="toc_7">复制算法</h4>

<p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<strong>当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉</strong>。</p>

<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。</p>

<p>这种算法的代价是将内存缩小为原来的一半。</p>

<p>新生代的对象98%是朝生夕死的，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为<strong>一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间</strong>，<strong>每次使用<code>Eden</code>和其中的一块<code>Survivor</code></strong>。当回收时，<strong>将<code>Eden</code>和<code>Survivor</code>中还存活着的对象一次性地拷贝到另外一块<code>Survivor</code>空间上</strong>，最后清理掉<code>Eden</code>和刚才用过的<code>Survivor</code>的空间。</p>

<p><code>HotSpot</code>虚拟机默认<code>Eden</code>和<code>Survivor</code>的大小比例是8：1，只有10%的内存会被浪费掉（备用<code>Survivor</code>），但是我们没办法保证每次回收都只有不多于10%的对象存活，当<code>Survivor</code>空间不够用时，需要依赖其他内存（老年代）进行分配担保（<code>Handle Promotion</code>）</p>

<h4 id="toc_8">标记 - 整理算法</h4>

<p>根据老年代的特点，有人提出了另外一种“标记 - 整理”（Mark-Compact）算法，标记过程仍然与“标记-清楚”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>

<h4 id="toc_9">分代收集算法</h4>

<p>根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>

<p><strong>在新生代中</strong>，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就<strong>选用复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p>

<p><strong>老年代</strong>中因为对象存活率高、没有额外空间对它进行担保，就必须<strong>使用“标记-清理”或“标记-整理”算法</strong>来进行回收。</p>

<h3 id="toc_10">内存分配与回收策略</h3>

<p>自动内存管理最终可以归结为自动化地解决了两个问题：</p>

<ul>
<li>给对象分配内存</li>
<li>回收分配给对象的内存</li>
</ul>

<p>对象的内存分配，就是在堆上分配，对象主要分配在新生代的<code>Eden</code>区上，如果启动了本地线程分配缓冲，将按线程优先在<code>TLAB</code>上分配。</p>

<p>几条最普通的内存分配规则。</p>

<h4 id="toc_11">对象优先在Eden分配</h4>

<p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p>

<pre><code>新生态GC（Minor GC）：指发生在新生代的垃圾收集动作，Minor GC非常频繁，一般回收速度也比较快。
老年代GC（Major GC / Full GC）：指发生在老年代的GC。
</code></pre>

<h4 id="toc_12">大对象直接进入老年代</h4>

<p>所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>

<blockquote>
<p>大对象对虚拟机的内存分配来说就是一个坏消息；比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”。</p>
</blockquote>

<h4 id="toc_13">长期存活的对象将进入老年代</h4>

<p>虚拟机给每个对象定义了一个对象年龄（<code>Age</code>）计数器。如果对象在<code>Eden</code>出生并经过第一次<code>Minor GC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，将被移动到<code>Survivor</code>空间中，并将对象年龄设为1。对象在<code>Survivor</code>区中每熬过一个<code>Minor GC</code>，年龄就增加1岁，当它的年龄增加到一定程度（默认是15岁）时，就会被晋升到老年代。</p>

<h4 id="toc_14">动态对象年龄判定</h4>

<p>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到<code>MaxTenuringThreshold</code>才能晋升到老年代；<strong>如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半</strong>，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</p>

<h4 id="toc_15">空间分配担保</h4>

<p>在发生<code>Minor GC</code>时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次<code>Full GC</code>。如果小于，则查看<code>HandlePromotionFailure</code>设置是否允许担保失败；如果允许，那只会进行<code>Minor GC</code>；如果不允许，则也要改为进行一次<code>Full GC</code>。</p>

<p>新生代使用复制收集算法，但为了内存利用率，只使用其中一个<code>Survivor</code>空间来作为轮换备份，因此当出现大量对象在<code>Minor GC</code>后仍然存活的情况时，就需要老年代进行分配担保，让<code>Survivor</code>无法容纳的对象直接进入老年代。</p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/11</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14576116389215.html">
                    
                    <h1>自动内存管理机制</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <h4 id="toc_0">程序计数器</h4>

<p>程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。</p>

<p>字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>

<p>由于<code>Java</code>虚拟机的多线程是通过轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个内核只会执行一条线程中的指令。</p>

<p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，每条线程之间的计数器互不影响，独立存储。<strong>我们称这类内存区域为“线程私有”的内存</strong>。</p>

<p>如果线程正在执行的是一个<code>Java</code>方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。</p>

<h4 id="toc_1"><code>Java</code>虚拟机栈</h4>

<p><code>Java</code>虚拟机栈也是线程私有的，它的生命周期与线程相同。</p>

<p>虚拟机栈描述的是<code>Java</code>方法执行的内存模型：<strong>每个方法被执行的时候都会同时创建一个栈帧（<code>Stack Frame</code>）</strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>

<p>局部变量表存放了编译器可知的各种基本数据类型（<code>boolean、byte、char、short、int、float、long、double</code>）、对象引用和<code>returnAddress</code>类型（指向了一条字节码指令的地址）</p>

<p>其中64位长度的<code>long</code>和<code>double</code>类型的数据会占用两个局部变量空间（<code>slot</code>），其余的数据类型只占用1个。</p>

<p>局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在桢中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>

<h4 id="toc_2">本地方法栈</h4>

<p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行<code>Java</code>方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的<code>Native</code>方法服务。</p>

<h4 id="toc_3"><code>Java</code>堆</h4>

<p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。</p>

<p><strong>Java堆是被所有线程共享</strong>的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例都在这里分配内存</strong>。</p>

<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。</p>

<h4 id="toc_4">方法区（Method Area）</h4>

<p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>

<p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。</p>

<h4 id="toc_5">运行时常量池</h4>

<p>运行时常量池（<code>Runtime Constant Pool</code>）是方法区的一部分。<code>Class</code>文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（<code>Constant Pool Table</code>），<strong>用于存放编译期生成的各种字面量和符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>

<p>运行时常量池相对于<code>Class</code>文件常量池的另外一个重要特征是具备动态性。<code>Java</code>不要求一定只能在编译器产生，也就是并非预置入<code>Class</code>文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特征用得比较多的就是<code>String</code>类的<code>intern()</code>方法。</p>

<h3 id="toc_6">对象访问</h3>

<pre><code class="language-java">Object obj = new Object();
</code></pre>

<p>如果这句代码出现在方法体中，那<code>Object obj</code>这部分的词义将会反映到<code>Java</code>栈的本地变量表中，作为一个<code>reference</code>类型数据出现。</p>

<p>而<code>new Object()</code>这部分的语义将会反映到<code>Java</code>堆中，形成一块存储了<code>Object</code>类型所有实例数据值的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存的长度是不固定的。另外，在<code>Java</code>堆中还必须包含能查找此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</p>

<p>不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。</p>

<ul>
<li>如果使用句柄访问方式，<code>Java</code>堆中将会划分出一块内存来作为句柄池，<code>reference</code>中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</li>
</ul>

<p><img src="media/14576116389215/14576643685296.jpg" alt="使用句柄访问方式"/></p>

<ul>
<li>如果使用直接指针访问方式，<code>Java</code>堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，<code>reference</code>中直接存储的就是地址</li>
</ul>

<p><img src="media/14576116389215/14576643858137.jpg" alt="使用直接指针访问方式"/></p>

<ul>
<li>使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，<strong>在对象被移动时只会改变句柄中的实例数据指针</strong>，而reference本身不需要被修改</li>
<li>使用直接指针访问方式的最大好处就是速度更快，它<strong>节省了一次指针定位的时间开销</strong>，由于对象的访问在Java中非常频繁，因此这类开销积少成多。</li>
</ul>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/10</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14573180475320.html">
                    
                    <h1>该如何创建字符串，使用“ ”还是构造函数</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <h5 id="toc_0">实例一</h5>

<pre><code class="language-java">String a = &quot;abcd&quot;;
String b = &quot;abcd&quot;;
System.out.println(&quot;a == b : &quot;+(a == b)); // true
System.out.println(&quot;a.equals(b) : &quot;+(a.equals(b))); // true
</code></pre>

<p>当相同的字符串常量被多次创建时，只会保存字符串常亮的一份副本，这称为“字符串驻留”。在Java中，所有编译时字符串常亮都是驻留的。</p>

<h5 id="toc_1">实例二</h5>

<pre><code class="language-java">String c = new String(&quot;abcd&quot;);
String d = new String(&quot;abcd&quot;);
System.out.println(&quot;c == d : &quot;+(c == d)); // false
System.out.println(&quot;c.equals(d) : &quot;+(c.equals(d))); // true
</code></pre>

<p><img src="media/14573180475320/14573183300919.jpg" alt=""/></p>

<h3 id="toc_2">运行时字符串驻留</h3>

<pre><code class="language-java">String c = new String(&quot;abcd&quot;).intern();
String d = new String(&quot;abcd&quot;).intern();
System.out.println(&quot;c == d : &quot;+(c == d)); // true
System.out.println(&quot;c.equals(d) : &quot;+(c.equals(d))); // true    （JDK1.7）
</code></pre>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/7</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14571033407551.html">
                    
                    <h1>分布式系统的事务处理</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p>通常，我们会通过两种手段来扩展我们的数据服务：</p>

<ul>
<li>数据分区：把数据分块放在不同的服务器上</li>
<li>数据镜像：让所有的服务器都有相同的数据，提供相当的服务</li>
</ul>

<p>数据服务的高可用性只能通过第二种方法来完成--数据的冗余存储。但是，加入更多的机器，会让我们的数据服务变得很复杂，尤其是跨服务器的事务处理，也就是跨服务器的数据一致性。</p>

<p>数据一致性，简单说有三种类型：</p>

<ul>
<li><code>Weak</code>弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来</li>
<li><code>Eventually</code>最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来</li>
<li><code>Strong</code>强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值</li>
</ul>

<h3 id="toc_0">Master-Slave</h3>

<ul>
<li><p>读写请求都由<code>Master</code>负责。</p></li>
<li><p>写请求写到<code>Master</code>上后，由<code>Master</code>同步到<code>Slave</code>上。</p></li>
</ul>

<p>从<code>Master</code>同步到<code>Slave</code>上，你可以使用异步，也可以使用同步，可以使用<code>Master</code>来<code>push</code>，也可以使用<code>Slave</code>来<code>pull</code>。 通常来说是<code>Slave</code>来周期性的<code>pull</code>，所以，是最终一致性。</p>

<h3 id="toc_1">Master-Master</h3>

<p>一个系统存在两个或多个<code>Master</code>，每个<code>Master</code>都提供<code>read-write</code>服务。这个模型是<code>Master-Slave</code>的加强版，数据间同步一般是通过<code>Master</code>间的异步完成，所以是最终一致性。</p>

<h3 id="toc_2">Two/Three Phase Commit</h3>

<p>在分布式系统中，每个节点虽然可以知晓自己在操作时是成功还是失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点的时候，为了保持事务的<code>ACID</code>特征，需要引入一个座位协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交。</p>

<h5 id="toc_3">第一阶段</h5>

<ul>
<li>协调者会问所有的参与者结点，是否可以执行提交操作。</li>
<li>各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写<code>undo/redo log……</code></li>
<li>参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。</li>
</ul>

<h5 id="toc_4">第二阶段</h5>

<ul>
<li>如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个<code>Global Transaction</code>。</li>
<li>如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个<code>Global Transaction</code>。</li>
</ul>

<p>先尝试再提交</p>

<pre><code>1）牧师分别问新郎和新娘：你是否愿意……不管生老病死……（询问阶段）
2）当新郎和新娘都回答愿意后（锁定一生的资源），牧师就会说：我宣布你们……（事务提交）
</code></pre>

<p>一些问题：</p>

<ul>
<li>其中一个是同步阻塞操作，会非常大地影响性能</li>
<li><code>Timeout</code></li>
<li>如果第一阶段完成后，参与者在第二阶段没有收到决策，那么数据结点会进入不知所措的状态，这个状态会<code>block</code>住整个事务</li>
</ul>

<h3 id="toc_5"><code>Paxis</code>算法</h3>

<p>任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以<code>Paxos</code>算法需要集群中的结点是单数）。</p>

<h3 id="toc_6">Reference</h3>

<p><a href="http://coolshell.cn/articles/10910.html">http://coolshell.cn/articles/10910.html</a></p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/4</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14571011644924.html">
                    
                    <h1>SpringMyBatis 事务管理</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <h4 id="toc_0">框架简介</h4>

<blockquote>
<p><code>Spring</code>是一个轻量级的控制反转(<code>IoC</code>)和面向切面(<code>AOP</code>)的容器框架，具有两个重要模块：Spring 面向切面编程（<code>AOP</code>）和控制反转（<code>IOC</code>）容器。</p>

<ul>
<li><p>控制反转模式（也称作依赖性介入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。</p></li>
<li><p>容器（在<code>Spring 框架中是 IOC 容器）</code>负责将这些联系在一起。在典型的<code>IOC</code>场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。</p></li>
</ul>

<p><code>MyBatis</code>是支持普通<code>SQL</code>查询，存储过程和高级映射的优秀持久层框架，消除了几乎所有的<code>JDBC</code>代码和参数的手工设置以及结果集的检索，使用简单的<code>XML</code>或注解用于配置和原始映射，将接口和<code>Java</code>对象映射成数据库中的记录。</p>
</blockquote>

<h2 id="toc_1">一、什么是事务</h2>

<p>对于一个软件系统来说，需要相应的数据资源(比如，数据库，文件系统等)来保存系统状态，在对系统状态所依托的数据资源进行访问的时候，为了保证系统始终处于一个“正确”的状态，我们就必须对这些访问操作进行一些必要的限定，以此来保证系统状态的完整性。</p>

<p>事务就是以可控的方式对数据资源进行访问的一组操作，为了保证事务执行前后数据资源所承载的系统状态始终处于“正确”状态。</p>

<h2 id="toc_2">二、事务的特性</h2>

<p>原子性(<code>Atomicity</code>)，一致性(<code>Consistency</code>)，隔离性(<code>Isolation</code>)以及持久性(<code>Durability</code>)，也就是常说的事务的<code>ACID</code>属性。</p>

<h4 id="toc_3">1、事务的原子性(<code>Atomicity</code>)</h4>

<p><strong>要么同时成功，要么同时失败</strong></p>

<p>原子性要求事务所包含的全部操作是一个不可分割的整体，这些操作要么全部提交成功，要么只要其中一个操作失败。</p>

<h4 id="toc_4">2、事务的一致性(<code>Consistency</code>)</h4>

<p>一致性要求事务所包含的操作不能违反数据资源的一致性检查，数据资源在事务执行之前处于一个数据的一致性状态，那么，事务执行之后也需要依然保持数据间的一致性状态。</p>

<h4 id="toc_5">3、事务的隔离性(<code>Isolation</code>)</h4>

<p>事务的隔离性主要规定了各个事务之间相互影响的程度。隔离性概念主要面向对数据资源的并发访问(Concurrency)，并兼顾影响事务的一致性。当两个事务或者更多事务同时访问同一数据资源的时候， 不同的隔离级别决定了各个事务对该数据资源访问的不同行为。</p>

<p>不出意外的话，我们可以为事务指定四种类型的隔离级别，隔离程度按照从弱到强分别为<code>Read Uncommitted</code>，<code>Read Committed</code>，<code>Repeatable Read</code>和<code>Serializable</code>:    </p>

<ul>
<li><p><code>Read Uncommitted</code>：最低的隔离级别，<code>Read Uncommitted</code>最直接的效果就是一个事务可以读取另一个事务并未提交的更新结果。</p></li>
<li><p><code>Read Committed</code>：<code>Read Committed</code>通常是大部分数据库采用的默认隔离级别，它在<code>Read Uncommitted</code>隔离级别基础上所做的限定更进一步，在该隔离级别下，一个事务的更新操作结果只有在该事务提交之后，另一个事务才可能读取到同一笔数据更新后的结果。</p></li>
<li><p><code>Repeatable Read</code>：<code>Repeatable Read</code>隔离级别可以保证在整个事务的过程中，对同一笔数据的读取结果是相同的，不管其他事务是否同时在对同一笔数据进行更新，也不管其他事务对同一笔数据的更新提交与否。<code>Repeatable Read</code>隔离级别避免了脏读和不可重复读取的问题，但无法避免幻读。</p></li>
<li><p><code>Serializable</code>：最为严格的隔离级别，所有的事务操作都必须依次顺序执行，可以避免其他隔离级别遇到的所有问题，是最为安全的隔离级别，但同时也是性能最差的隔离级别。</p></li>
</ul>

<h4 id="toc_6">4、事务的持久性(<code>Durability</code>)</h4>

<p>事务的持久性是指一旦整个事务操作成功提交完成，对数据所做的变更将被记载并不可逆转。</p>

<h2 id="toc_7">三、<code>Spring</code>事务性</h2>

<p><code>Spring</code>所有的事务管理策略类都继承自<code>org.springframework.transaction.PlatformTransactionManager</code>接口。</p>

<pre><code class="language-java">public interface PlatformTransactionManager 
{
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
}
</code></pre>

<p>其中<code>TransactionDefinition</code>接口定义以下特性：</p>

<h4 id="toc_8">1、传播行为</h4>

<p>传播行为定义关于客户端和被调用方法的事务边界。在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量：</p>

<table>
<tr><th>传播行为</th><th>意义</th></tr>
<tr><td>PROPAGATION_MANDATORY</td><td>该方法必须运行在一个事务中。如果当前没有事务正在发生，将抛出一个异常。</td></tr>
<tr><td>PROPAGATION_NESTED</td><td>如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于封装事务进行提交或回滚。如果封装事务不存在，行为就像 PROPAGATION_REQUIRES一样。</td></tr>
<tr><td>PROPAGATION_NEVER</td><td>当前的方法不应该在一个事务中运行。如果一个事务正在进行，则会抛出一个异常。</td></tr>
<tr><td>PROPAGATION_NOT_SUPPORTED</td><td>该方法不应该在一个事务中运行。如果一个现有事务正在进行中，它将在该方法的运行期间被挂起。</td></tr>
<tr><td>PROPAGATION_SUPPORTS</td><td>当前方法不需要事务性上下文，但是如果有一个事务已经在运行的话，它也可以在这个事务里运行。</td></tr>
<tr><td>PROPAGATION_REQUIRES_NEW</td><td>当前方法必须在它自己的事务里运行。一个新的事务将被启动，而且如果有一个现有事务在运行的话，则将在这个方法运行期间被挂起。</td></tr>
<tr><td>PROPAGATION_REQUIRES</td><td>当前方法必须在一个事务中运行。如果一个现有事务正在进行中，该方法将在那个事务中运行，否则就要开始一个新事务。</td></tr>
</table>

<p>传播行为回答了这样一个问题，就是一个新的事务应该被启动还是被挂起，或者是一个方法是否应该在事务性上下文中运行。</p>

<h4 id="toc_9">2、隔离级别</h4>

<p>声明式事务的第二个方面是隔离级别。隔离级别定义一个事务可能受其他并发事务活动活动影响的程度。另一种考虑一个事务的隔离级别的方式，是把它想象为那个事务对于事物处理数据的自私程度。</p>

<p>在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。并发虽然是必需的，但是会导致一下问题：</p>

<blockquote>
<ul>
<li><p>脏读（<code>Dirty read</code>）-- 脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。</p></li>
<li><p>不可重复读（<code>Nonrepeatable read</code>）-- 不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。</p></li>
<li><p>幻影读（<code>Phantom reads</code>）-- 幻影读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻影读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。</p></li>
</ul>
</blockquote>

<p>在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全隔离会影响性能，因为隔离经常牵扯到锁定在数据库中的记录（而且有时是锁定完整的数据表）。侵占性的锁定会阻碍并发，要求事务相互等待来完成工作。</p>

<p>考虑到完全隔离会影响性能，而且并不是所有应用程序都要求完全隔离，所以有时可以在事务隔离方面灵活处理。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>

<table>
<tr><th>隔离级别</th><th>含义</th></tr>
<tr><td>ISOLATION_DEFAULT</td><td>使用数据库默认的隔离级别。</td></tr>
<tr><td>ISOLATION_READ_UNCOMMITTED</td><td>允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。</td></tr>
<tr><td>ISOLATION_READ_COMMITTED</td><td>允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。</td></tr>
<tr><td>ISOLATION_REPEATABLE_READ</td><td>对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。</td></tr>
<tr><td>ISOLATION_SERIALIZABLE</td><td>完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td></tr>
</table>

<h4 id="toc_10">3、超时</h4>

<p>为了使一个应用程序很好地执行，它的事务不能运行太长时间。因此，声明式事务的下一个特性就是它的超时。</p>

<p>假设事务的运行时间变得格外的长，由于事务可能涉及对后端数据库的锁定，所以长时间运行的事务会不必要地占用数据库资源。这时就可以声明一个事务在特定秒数后自动回滚，不必等它自己结束。</p>

<p>由于超时时钟在一个事务启动的时候开始的，因此，只有对于那些具有可能启动一个新事务的传播行为（<code>PROPAGATION_REQUIRES_NEW</code>、<code>PROPAGATION_REQUIRED</code>、<code>ROPAGATION_NESTED</code>）的方法来说，声明事务超时才有意义。</p>

<h4 id="toc_11">4、只读</h4>

<p>声明式事务的第四个特性是它是否是一个只读事务。如果一个事务只对后端数据库执行读操作，那么该数据库就可能利用那个事务的只读特性，采取某些优化措施。通过把一个事务声明为只读，可以给后端数据库一个机会来应用那些它认为合适的优化措施。由于只读的优化措施是在一个事务启动时由后端数据库实施的， 因此，只有对于那些具有可能启动一个新事务的传播行为（<code>PROPAGATION_REQUIRES_NEW</code>、<code>PROPAGATION_REQUIRED</code>、 <code>ROPAGATION_NESTED</code>）的方法来说，将事务声明为只读才有意义。</p>

<h4 id="toc_12">5、回滚规则</h4>

<p>指示<code>Spring</code>事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。<code>Spring</code>事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。</p>

<p>默认配置下，<code>Spring</code>只有在抛出的异常为运行时<code>unchecked</code>异常时才回滚该事务，也就是抛出的异常为<code>RuntimeException</code>的子类(<code>Errors</code>也会导致事务回滚)，而抛出 checked 异常则不会导致事务回滚。</p>

<p>可以明确的配置在抛出那些异常时回滚事务，包括<code>checked</code>异常。也可以明确定义那些异常抛出时不回滚事务。</p>

<p>还可以编程性的通过<code>setRollbackOnly()</code>方法来指示一个事务必须回滚，在调用完<code>setRollbackOnly()</code>后你所能执行的唯一操作就是回滚。</p>

<h2 id="toc_13">四、Spring 事务管理</h2>

<p><code>Spring</code>对事务管理提供了一致的抽象，其特点如下：</p>

<blockquote>
<ul>
<li><p>为不同的事务<code>API</code>提供一致的编程模型，比如<code>JTA(Java Transaction API)</code>, <code>JDBC</code>, <code>Hibernate</code>, <code>JPA(Java Persistence API</code>和<code>JDO(Java Data Objects)</code></p></li>
<li><p>支持声明式事务管理，特别是基于注解的声明式事务管理，简单易用</p></li>
<li><p>提供比其他事务<code>API</code>如<code>JTA</code>更简单的编程式事务管理<code>API</code></p></li>
<li><p>与<code>spring</code>数据访问抽象的完美集成</p></li>
</ul>
</blockquote>

<h4 id="toc_14">1、事务管理方式</h4>

<p><code>Spring</code>支持编程式事务管理和声明式事务管理两种方式。</p>

<p>编程式事务管理使用<code>TransactionTemplate</code>或直接使用底层<code>PlatformTransactionManager</code>。<code>Spring</code>推荐使用 <code>TransactionTemplate</code>。</p>

<p>声明式事务管理建立在<code>AOP</code>之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于<code>@Transactional</code>注解的方式)，便可以将事务规则应用到业务逻辑中。</p>

<p>显然，声明式事务管理要优于编程式事务管理，这正是<code>Spring</code>倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的<code>POJO</code>对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。</p>

<p>声明式事务管理也有两种常用的方式，一种是基于<code>tx</code>和<code>aop</code>名字空间的<code>xml</code>配置文件，另一种就是基于 <code>@Transactional</code>注解。显然基于注解的方式更简单易用，更清爽。</p>

<h4 id="toc_15">2、自动提交(<code>AutoCommit</code>)</h4>

<p>默认情况下，数据库处于自动提交模式。每一条语句处于一个单独的事务中，在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果执行失败则隐式的回滚事务。</p>

<p>对于正常的事务管理，是一组相关的操作处于一个事务之中，因此必须关闭数据库的自动提交模式。不过，这个我们不用担心，<code>Spring</code>会将底层连接的自动提交特性设置为<code>false</code>。</p>

<p><code>org/springframework/jdbc/datasource/DataSourceTransactionManager.java</code></p>

<pre><code class="language-java">// switch to manual commit if necessary. this is very expensive in some jdbc drivers,
// so we don&#39;t want to do it unnecessarily (for example if we&#39;ve explicitly
// configured the connection pool to set it already).
if (con.getautocommit()) {
    txobject.setmustrestoreautocommit(true);
    if (logger.isdebugenabled()) {
        logger.debug(&quot;switching jdbc connection [&quot; + con + &quot;] to manual commit&quot;);
    }
    con.setautocommit(false);
}
</code></pre>

<h2 id="toc_16">五、基于<code>@Transactional</code>注解的<code>AOP</code>事务管理</h2>

<p>Spring 配置文件里需要：</p>

<p><code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></p>

<p><code>&lt;aop:aspectj-autoproxy/&gt;</code></p>

<p><code>tx:annotation-driven</code>是注解驱动的事务管理支持的核心。 </p>

<p>标签属性： </p>

<p>a、<code>transaction-manager</code>：指定到现有的 <code>PlatformTransactionManager bean</code>的引用，通知会使用该引用，<code>default = &quot;transactionManager&quot;</code></p>

<p>b、<code>mode</code>：指定Spring事务管理框架创建通知<code>bean</code>的方式。可用的值有<code>proxy</code>和<code>aspectj</code>。前者是默认值，表示通知对象是个<code>JDK</code>代理；后者表示<code>Spring AOP</code>会使用<code>AspectJ</code>创建代理。 </p>

<p>c、<code>order</code>：指定创建的切面的顺序。只要目标对象有多个通知就可以使用该属性。 </p>

<p>d、<code>proxy-target-class</code>：该属性如果为<code>true</code>就表示你想要代理目标类而不是<code>bean</code>所实现的所有接口<code>default=&quot;false&quot;</code> </p>

<h3 id="toc_17">1、@Transactional属性</h3>

<table>
<tr><th>属性</th><th>类型</th><th>描述</th></tr>
<tr><td>value</td><td>String</td><td>可选的限定描述符，指定使用的事务管理器。</td></tr>
<tr><td>propagation</td><td>enum: Propagation</td><td>可选的事务传播行为设置。</td></tr>
<tr><td>isolation</td><td>enum: Isolation</td><td>可选的事务隔离级别设置</td></tr>
<tr><td>readOnly</td><td>boolean</td><td>读写或只读事务，默认读写</td></tr>
<tr><td>timeout</td><td>int(in seconds granularity)</td><td>事务超时时间设置</td></tr>
<tr><td>rollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>导致事务回滚的异常类数组</td></tr>
<tr><td>rollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>导致事务回滚的异常类名字数组</td></tr>
<tr><td>noRollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类数组</td></tr>
<tr><td>noRollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类名字数组</td></tr>
</table>

<h4 id="toc_18">2、用法</h4>

<p><code>@Transactional</code>可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有<code>public</code>方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>

<p>虽然<code>@Transactional</code>注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， <strong><code>@Transactional</code>注解应该只被应用到<code>public</code>方法上，这是由<code>Spring AOP</code>的本质决定的。如果你在 <code>protected</code>、<code>private</code>或者默认可见性的方法上使用 <code>@Transactional</code>注解，这将被忽略</strong>，也不会抛出任何异常。</p>

<p>默认情况下，只有来自外部的方法调用才会被<code>AOP</code>代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</p>

<p>示例代码：</p>

<pre><code class="language-java">@Transactional(readOnly = true)
public class getInfoService implements BaseService 
{
  public Info getInfo(String name) 
  {
    // do something
  }
  // these settings have precedence for this method
  //方法上注解属性会覆盖类注解上的相同属性
  @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
  public void updateInfo(Info info) 
  {
    // do something
  }
}
</code></pre>

<p>如果在每个方法上都定义注解，那么就会很麻烦。（可以使用XML AOP事务管理能更好的处理这种情况）</p>

<h2 id="toc_19">六、基于<code>XML</code>的<code>AOP</code>事务管理</h2>

<h4 id="toc_20">1、基于<code>XML</code>的<code>AOP</code>事务管理配置文件如下：</h4>

<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;allServiceMethods&quot;  
                  expression=&quot;execution(* cn.hao24.mobauto.service.*.*(..))&quot;/&gt;  
    &lt;aop:advisor advice-ref=&quot;defaultTransactionAdvice&quot;
                    pointcut-ref=&quot;allServiceMethods&quot;/&gt;  
&lt;/aop:config&gt;  
  
&lt;tx:advice id=&quot;defaultTransactionAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;  
    &lt;tx:attributes&gt;  
        &lt;tx:method  
                name=&quot;*&quot;  
                isolation=&quot;DEFAULT&quot;  
                propagation=&quot;REQUIRED&quot;  
                no-rollback-for=&quot;java.lang.RuntimeException&quot;  
                timeout=&quot;100&quot;/&gt;  
        &lt;tx:method  
                name=&quot;get*&quot;  
                read-only=&quot;true&quot;/&gt;  
    &lt;/tx:attributes&gt;  
&lt;/tx:advice&gt;
</code></pre>

<h4 id="toc_21">2、<code>tx:advice</code>标签简介</h4>

<p>该标签会创建一个事务处理通知。 </p>

<p><code>id</code>是该<code>advice bean</code>的标识，而<code>transaction-manager</code>则必须引用一个<code>PlatformTransactionManager bean</code>。 <br/>
还可以通过<code>&lt;tx:attributes&gt;</code>标签定制<code>&lt;tx:advice&gt;</code>标签所创建的通知的行为。 </p>

<h4 id="toc_22">3、<code>&lt;tx:method/&gt;</code>标签的属性</h4>

<p><code>name</code>：方法名的匹配模式，通知根据该模式寻找匹配的方法。 </p>

<p>其余属性（<code>propagation</code>、<code>isolation</code>、<code>timeout</code>、<code>read-only</code>、<code>no-rollback-for</code>、<code>rollback-for</code>）不再赘述。</p>

<p><code>&lt;tx:method&gt;</code>中<code>isolation</code>（隔离）和<code>propagation</code>（传播）参数的含义： <br/>
<code>getIsolationLevel</code>：他对其他事务所看到的数据变化进行控制。 </p>

<h2 id="toc_23">七、MyBatis-Spring 配置</h2>

<p>使用<code>MyBatis-Spring</code>的主要原因是它允许<code>MyBatis</code>参与到 Spring 的事务管理中。而不是给<code>MyBatis</code>创建一个新的特定的事务管理器，<code>MyBatis-Spring</code>利用了存在于 <code>Spring</code>中的<code>DataSourceTransactionManager</code>。</p>

<p>一旦<code>Spring</code>的<code>PlatformTransactionManager</code>配置好了，你可以在<code>Spring</code>中以你通常的做法来配置事务。<code>@Transactional</code>注解和<code>AOP XML</code>的配置都是支持的。在事务处理期间,一个单独的<code>SqlSession</code>对象将会被创建和使用。当事务完成时,这个<code>session</code>会以合适的方式提交或回滚。</p>

<p>一旦事务创建之后，<code>MyBatis-Spring</code>将会透明的管理事务。配置代码如下：</p>

<pre><code class="language-xml">&lt;!-- 创建SqlSessionFactory，同时指定数据源 --&gt;
&lt;bean id=&quot;mySqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;!-- 自动扫描entity目录, 省掉Configuration.xml里的手工配置 --&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:sqlmaps/**/*Mapper.xml&quot; /&gt;
&lt;/bean&gt;

&lt;!-- Mapper接口所在包名，Spring会自动查找其下的类 --&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;  
    &lt;property name=&quot;basePackage&quot; value=&quot;cn.hao24.mobauto.mapper&quot; /&gt;
    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;mySqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>

<p><code>MyBatis</code>的<code>SqlSession</code>提供指定的方法来处理编程式的事务。 但是当使用<code>MyBatis-Spring</code>时, <code>bean</code>将会使用 <code>Spring</code>管理的<code>SqlSession</code>或映射器来注入。 那就是说<code>Spring</code>通常是处理事务的。</p>

<p>你不能在<code>Spring</code>管理的<code>SqlSession</code>上调用 <code>SqlSession.commit()</code>、<code>SqlSession.rollback()</code>或 <code>SqlSession.close()</code>方法 。 如果这样做了 , 就 会 抛 出<code>UnsupportedOperationException</code>异常。注意在使用注入的映射器时不能访问那些方法。</p>

<p>无论<code>JDBC</code>连接是否设置为自动提交, <code>SqlSession</code>数据方法的执行或在<code>Spring</code>事务之外任意调用映射器方法都将会自动被提交。</p>

<h3 id="toc_24">Local vs. Global Transactions</h3>

<p>Local transactions are specific to a single transactional resource like a JDBC connnection, whereas globa transactions can span multiple transactional resources like transaction in a distributed system.</p>

<h3 id="toc_25">事务类型</h3>

<p>数据库事务类型有本地事务和分布式事务：</p>

<ul>
<li>本地事务：就是普通事务，能保证单台数据库上的操作的ACID，被限定在一台数据库上</li>
<li>分布式事务：涉及两个或多个数据库源的事务，即跨越多台同类或异类数据库的事务（由每台数据库的本地事务组成的）</li>
</ul>

<p>Java事务类型有JDBC事务和JTA事务：</p>

<ul>
<li>JDBC事务：就是数据库事务类型中的本地事务，通过Connection对象的控制来管理事务</li>
<li>JTA事务：由应用程序服务器厂商提供实现</li>
</ul>

<p>JavaEE事务类型有本地事务和全局事务：</p>

<ul>
<li>本地事务：使用JDBC变成实现事务</li>
<li>全局事务：由应用程序服务器提供，使用JTA事务</li>
</ul>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/4</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            


            <div class="row">
                <div class="large-6 columns">
                    <p class="text-left" style="padding-top:25px;">
                         <a href="all_4.html">&laquo; Prev Page</a> 
                    </p>
                </div>
                <div class="large-6 columns">
                    <p class="text-right" style="padding-top:25px;">
                         <a href="all_6.html">&raquo; Next Page</a> 
                    </p>
                </div>
            </div>
        </div>
    </div>
    <!-- large 8 -->

 <div class="large-4 medium-4 columns">
    <div class="hide-for-small">
        <div id="sidebar" class="sidebar">
            <div id="site-info" class="site-info">
                
                <h1>NathanCHEN</h1>

                <div class="site-des"></div>
                <div class="social">
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <a class="rss" href="atom.xml" title="RSS">RSS</a>

                </div>
            </div>
            <div id="site-categories" class="side-item ">
                <div class="side-header">
                    <h2>Contact</h2>
                </div>
                <div class="side-content">
                    <ul class="posts-list">
                        <li class="post">
                            <p class="email-addr">tringchen AT gmail.com</p>

                            <p class="email-addr">江苏 · 南京</p>
                        </li>
                    </ul>
                </div>
            </div>
            <div id="site-categories" class="side-item ">
                <div class="side-header">
                    <h2>Categories</h2>
                </div>
                <div class="side-content">

                    <p class="cat-list">
                        
                        <a href="Java.html"><strong>Java</strong></a>
                        
                        <a href="JavaScript.html"><strong>JavaScript</strong></a>
                        
                        <a href="Ngnix.html"><strong>Ngnix</strong></a>
                        
                        <a href="tomcat.html"><strong>tomcat</strong></a>
                        
                        <a href="spring.html"><strong>spring</strong></a>
                        
                        <a href="RabbitMQ.html"><strong>RabbitMQ</strong></a>
                        
                        <a href="ELK.html"><strong>ELK</strong></a>
                        
                        <a href="TCP/IP.html"><strong>TCP/IP</strong></a>
                        
                        <a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"><strong>源码阅读</strong></a>
                        
                        <a href="others.html"><strong>others</strong></a>
                        
                        <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
                        
                        <a href="PAXOS.html"><strong>PAXOS</strong></a>
                        
                        <a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html"><strong>深入分析Java Web技术内幕</strong></a>
                        
                    </p>


                </div>
            </div>

            <div id="site-categories" class="side-item">
                <div class="side-header">
                    <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                    <ul class="posts-list">
                        
                        
                        <li class="post">
                            <a href="14590098445355.html">应用多级缓存模式支撑海量读服务</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14589988314853.html">浅谈Web缓存</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14588873943004.html">深入分析`Java I/O`的工作机制</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14588864645651.html">深入Web请求过程</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14588864364518.html">I</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                </div>
            </div>
        </div>
        <!-- sidebar -->
    </div>
    <!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->
 <div class="page-bottom clearfix">
    <div class="row">
        <p class="copyright">Copyright &copy; 2016
            Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp;
            Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
    </div>
</div>
</section>
</div>
</div>




<script src="asset/js/foundation.min.js"></script>
<script>
    $(document).foundation();
    function fixSidebarHeight() {
        var w1 = $('.markdown-body').height();
        var w2 = $('#sidebar').height();
        if (w1 > w2) {
            $('#sidebar').height(w1);
        }
        ;
    }
    $(function () {
        fixSidebarHeight();
    })
    $(window).load(function () {
        fixSidebarHeight();
    });

</script>





</body>
</html>
