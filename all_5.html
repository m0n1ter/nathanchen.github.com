<!doctype html>
<html class="no-js" lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>
        
        NathanCHEN
        
    </title>
    
    
    <link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css"/>
    <link rel="stylesheet" href="asset/css/docs.css"/>
    <link rel="stylesheet" href="asset/css/my.css"/>
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>

</head>
<body class="antialiased hide-extras">

<div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">


        <nav class="top-bar docs-bar hide-for-small" data-topbar>


            <section class="top-bar-section">
                <div class="row">
                    <div style="position: relative;width:100%;">
                        <div style="position: absolute; width:100%;">
                            <ul id="main-menu" class="left">
                                <li id="menu_item_index"><a href="index.html">HOME</a></li>
                                <li id="menu_item_archives"><a href="archives.html">Archives</a></li>
                                <li id="menu_item_about"><a href="about.html">ABOUT</a></li>
                            </ul>

                            <ul class="right" id="search-wrap">
                                <li>
                                    <form target="_blank" action="http://google.com/search" method="get">
                                        <input type="hidden" name="q" value="site:nathanchen.github.io"/>
                                        <input tabindex="1" type="search" name="q" placeholder="Search"/>
                                    </form>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

        </nav>

        <nav class="tab-bar show-for-small">
            <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
                <span> &nbsp; NathanCHEN</span>
            </a>
        </nav>

        <aside class="left-off-canvas-menu">
            <ul class="off-canvas-list">

                <li><a href="index.html">HOME</a></li>
                <li><a href="archives.html">Archives</a></li>
                <li><a href="about.html">ABOUT</a></li>

                <li><label>Categories</label></li>

                
                <li><a href="Java.html">Java</a></li>
                
                <li><a href="JavaScript.html">JavaScript</a></li>
                
                <li><a href="Ngnix.html">Ngnix</a></li>
                
                <li><a href="tomcat.html">tomcat</a></li>
                
                <li><a href="spring.html">spring</a></li>
                
                <li><a href="RabbitMQ.html">RabbitMQ</a></li>
                
                <li><a href="ELK.html">ELK</a></li>
                
                <li><a href="TCP/IP.html">TCP/IP</a></li>
                
                <li><a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html">源码阅读</a></li>
                
                <li><a href="others.html">others</a></li>
                
                <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
                
                <li><a href="PAXOS.html">PAXOS</a></li>
                
                <li><a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html">深入分析Java Web技术内幕</a></li>
                

            </ul>
        </aside>

        <a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
 <script type="text/javascript">
    $(function () {
        $('#menu_item_index').addClass('is_active');
    });
</script>
<div class="row">
    <div class="large-8 medium-8 columns">
        <div class="markdown-body home-categories">
            
            <div class="article">
                <a class="clearlink" href="14580089911497.html">
                    
                    <h1>RabbitMQ的阻塞和初步优化</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p>RabbitMQ占用内存达到峰值（内存的40%）消息链接就会发生阻塞</p>

<p>情况模拟：大量发送消息，RabbitMQ的消息处于堆积状态，内存值持续增大，RabbitMQ 的连接会阻塞。导致发送等待状态，CPU、内存占用很大，发送消息服务器异常。</p>

<h3 id="toc_0">异常处理结果分析：</h3>

<p>管理后台删除queue会大幅度的减少内存的占用，内存释放，链接不会发生阻塞，接受消息正常，CPU也正常。</p>

<h3 id="toc_1">异常发生原因初步分析：</h3>

<h4 id="toc_2">1. 消费者采用的排他队列（<code>Exclusive</code>）和持久化方式（<code>Durable</code>）</h4>

<p>持久化方式消息保存在磁盘中，非持久化保存在内存采用临时队列，应该注意以下三点：</p>

<ul>
<li><p>排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一个连接创建的临时队列的</p></li>
<li><p>连接间不允许建立同名的排他队列的</p></li>
<li><p>即使该队列是持久化的，一旦连接关闭或者客户端退出，应立即删除队列</p></li>
</ul>

<p>我们处理措施：队列修改为一旦连接关闭或者客户端退出，该队列都会被立即删除</p>

<pre><code class="language-java">channel.queueDeclare(queueName, true, true, true, null);
</code></pre>

<ul>
<li><code>@param queue</code> the <strong>name</strong> of the queue</li>
<li><code>@param durable</code> true if we are declaring a durable queue (the <strong>queue will survive a server restart</strong>) 服务器重启</li>
<li><code>@param exclusive</code> true if we are declaring an exclusive queue (<strong>restricted to this connection</strong>) 一个queue能不能有多个消费者</li>
<li><code>@param autoDelete</code> true if we are declaring an autodelete queue (<strong>server will delete it when no longer in use</strong>) 如果一个queue的全部消费者都挂了 </li>
<li><code>@param arguments</code> other properties (construction arguments) for the queue</li>
<li><code>@return</code> a declaration-confirm method to indicate the queue was successfully declared</li>
</ul>

<h4 id="toc_3">2. 修正程序中的<code>bug</code>，建立<code>MQSender</code>时不建<code>Queue</code></h4>

<p>在之前的程序中，当我们新建一个<code>MQSender</code>总会建一个<code>Queue</code>，而这个<code>Queue</code>没有消费者。<code>P</code>在发送信息时总会同时发送给<code>Exchange</code>和<code>Queue</code>。没有消费者以及持续不断地收消息导致<code>Queue</code>占用内存不断增大，最终拖垮整个RabbitMQ的效能。</p>

<p><img src="media/14580089911497/14580089934185.jpg" alt=""/></p>

<h3 id="toc_4">异常导致RabbitMQ连接异常处理：</h3>

<h4 id="toc_5">1.管理页面可以访问的情况下</h4>

<p>点击queues --&gt; 点击对应的队列名 --&gt; 进入队列详情页面，点击页面底部的delete按钮删除相应的队列，上述操作可以让RabbitMQ的内存下降</p>

<h4 id="toc_6">2.管理后台不能访问，后台不能启动，后台相关处理</h4>

<p>删除所有queues的消息，减小内存 （110为例）</p>

<pre><code>cd /var/lib/rabbitmq/mnesia/rabbit\@template-CentOS6/
rm -rf queues
</code></pre>

<p>启动RabbitMQ</p>

<pre><code>service rabbitmq-server start
</code></pre>

<h4 id="toc_7">此时两种方式删除queues</h4>

<h5 id="toc_8">1.访问管理台页面按1的方式删除queues</h5>

<h5 id="toc_9">2.linux管理台删除</h5>

<pre><code>rabbitmqctl stop_app 
</code></pre>

<p>清除所有队列同时初始化rabbitmq</p>

<pre><code>rabbitmqctl reset
</code></pre>

<p>创建登录管理后台的用户<code>用户名</code> <code>密码</code></p>

<pre><code>rabbitmqctl add_user 用户名 密码
rabbitmqctl set_user_tags 用户名 administrator
rabbitmqctl set_permissions -p / hao24 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
</code></pre>

<p>建立连接用户名密码</p>

<pre><code>rabbitmqctl add_user 用户名 密码
rabbitmqctl set_permissions -p / 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
</code></pre>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/15</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='RabbitMQ.html'>RabbitMQ</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14580044696840.html">
                    
                    <h1>Queue</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <pre><code class="language-java">channel.queueDeclare(queueName, true, true, true, null);
</code></pre>

<ul>
<li><code>@param queue</code> the <strong>name</strong> of the queue</li>
<li><code>@param durable</code> true if we are declaring a durable queue (the <strong>queue will survive a server restart</strong>) 服务器重启</li>
<li><code>@param exclusive</code> true if we are declaring an exclusive queue (<strong>restricted to this connection</strong>) 一个queue能不能有多个消费者</li>
<li><code>@param autoDelete</code> true if we are declaring an autodelete queue (<strong>server will delete it when no longer in use</strong>) 如果一个queue的全部消费者都挂了 </li>
<li><code>@param arguments</code> other properties (construction arguments) for the queue</li>
<li><code>@return</code> a declaration-confirm method to indicate the queue was successfully declared</li>
</ul>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/15</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='RabbitMQ.html'>RabbitMQ</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14578521973777.html">
                    
                    <h1>类文件结构</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <h3 id="toc_0"><code>Class</code>类文件的结构</h3>

<p><code>Class</code>文件是<strong>一组以8位字节为基础单位的二进制流</strong>，每个数据项目严格按照顺序紧凑地排列在<code>Class</code>文件之中，中间没有添加任何分隔符。<strong>当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割若干个8位字节进行存储</strong>。</p>

<p>Class文件格式只有两种数据类型：无符号数和表。</p>

<p><img src="media/14578521973777/14580226267662.jpg" alt=""/></p>

<h5 id="toc_1">无符号数</h5>

<ul>
<li>以<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>来分别表示1个字节、2个字节、4个字节和8个字节的无符号数</li>
<li>无符号数可以用来描述数字、索引引用、数量值，或者按照<code>utf-8</code>编码构成字符串值</li>
</ul>

<h5 id="toc_2">表</h5>

<ul>
<li>由多个无符号数或其他表作为数据项构成的复合数据类型</li>
<li>所有表都习惯性地以<code>_info</code>结尾</li>
<li>表用于描述有层次关系的复合结构的数据</li>
<li>整个<code>Class</code>文件本质上就是一张表</li>
</ul>

<p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容器计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。</p>

<h4 id="toc_3">魔数与<code>Class</code>文件的版本</h4>

<p>每个<code>Class</code>文件的头4个字节称为魔数（<code>Magic Number</code>），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的<code>Class</code>文件。</p>

<p><code>Class</code>文件的魔数为：<code>0xCAFEBABE</code> （<code>Cafe Babe</code>）</p>

<p>紧接着魔数的4个字节存储的是<code>Class</code>文件的版本号：第5和第6个字节是次版本号（<code>Minor Version</code>），第7和第8个字节是主版本号（<code>Major Version</code>）</p>

<blockquote>
<p>根据表6-1：<code>magic</code>是<code>u4</code>类型，因此是从<code>offset0</code>-<code>offset3</code></p>
</blockquote>

<p><img src="media/14578521973777/14578645877419.jpg" alt=""/></p>

<p><img src="media/14578521973777/14580227286642.jpg" alt=""/></p>

<h4 id="toc_4">常量池</h4>

<p>紧接着主次版本号之后的是常量池入口，常量池是<code>Class</code>文件结构中与其他项目关联最多的数据类型，也是占用<code>Class</code>文件空间最大的数据项目之一，同时它还是在<code>Class</code>文件中第一个出现的表类型数据项目。</p>

<p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一个<code>u2</code>类型的数据，代表常量池容量计数值（<code>constant_pool_count</code>）。这个容量计数是从1而不是0开始的。</p>

<p><img src="media/14578521973777/14578648670083.jpg" alt=""/></p>

<blockquote>
<p>常量池容量为十六进制的<code>0x0016</code>，即十进制的22，这就代表常量池中有21项常量</p>
</blockquote>

<p><strong><code>Class</code>文件结构中只有常量池的容量计数是从1开始的</strong>，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都是从0开始。</p>

<p><strong>常量池之中主要存放两大类常量：字面量（<code>Literal</code>）和符号引用（<code>Symbolic References</code>）</strong>。字面量比较接近于<code>Java</code>语言层面的常量概念，如文本字符串、被声明为<code>final</code>的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>

<ul>
<li>类和接口的全限定名（<code>Fully Qualified Name</code>）</li>
<li>字段的名称和描述符（<code>Descriptor</code>）</li>
<li>方法的名称和描述符</li>
</ul>

<p><code>Java</code>代码在进行<code>javac</code>编译的时候，是在虚拟机加载<code>Class</code>文件的时候进行动态连接。也就是说，在<strong><code>Class</code>文件中不会保存各个方法和字段的最终内存布局信息</strong>，因此这些字段和方法的符号引用不经过转换的话是无法直接被虚拟机使用的。<strong>当虚拟机运行时，需要从常量池获得对应的符号引用</strong>，再在类创建时或运行时解析并翻译到具体的内存地址之中。</p>

<p>常量池中的每一项常量都是一个表，共有11种结构各不相同的表结构数据，这11种表都有一个共同的特点，就是表开始的第一位是<code>u1</code>类型的标志位，代表当前这个常量属于哪种常量类型。</p>

<p><img src="media/14578521973777/14578729659671.jpg" alt=""/></p>

<p>图6-3中常量池的第一个常量，它的标志位是<code>0x07</code>，再看表6-3会发现这个常量属于<code>CONSTANT_Class_info</code>类型，此类型的常量代表一个类或接口的符号引用。</p>

<p><img src="media/14578521973777/14580150986168.jpg" alt="CONSTANT_Class_info结构"/></p>

<p><code>tag</code>是标志位</p>

<p><code>name_index</code>是一个索引值，它指向常量池中的一个<code>CONSTANT_Utf8_info</code>类型的常量，此常量代表了这个类（或者接口）的全限定名，这里的<code>name_index</code>值（偏移地址：<code>0x0000000B</code>）为<code>0x0002</code>，即指向了常量池中的第二项常量。它的标志位（偏移地址：<code>0x0000000D</code>）是0x01，查看表6-3可知是一个CONSTANT_Utf8_info类型的常量，其结构为</p>

<p><img src="media/14578521973777/14580174577630.jpg" alt=""/></p>

<p>length值说明这个字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。</p>

<p>本例中这个字符串的length值（偏移地址：<code>0x0000000F</code>）为0x001D，也就是长29个字节，内容为<code>org/fenixsoft/clazz/TestClass</code></p>

<p><img src="media/14578521973777/14580177154247.jpg" alt=""/></p>

<p><img src="media/14578521973777/14580282573398.jpg" alt=""/></p>

<p><img src="media/14578521973777/14580282699233.jpg" alt=""/></p>

<h4 id="toc_5">访问标志</h4>

<p>在常量池结束之后，紧接着的2个字节代表访问标志（<code>access_flags</code>），这个标志用于识别一些类或接口层次的访问信息，包括：这个<code>class</code>是类还是接口；是否定义为<code>public</code>类型；是否定义为<code>abstract</code>类型；如果是类的话，是否被声明为<code>final</code>等等。</p>

<p><img src="media/14578521973777/14580284064697.jpg" alt=""/></p>

<h4 id="toc_6">类索引、父类索引和接口索引集合</h4>

<p>类索引（<code>this_class</code>）和父类索引（<code>super_class</code>）都是一个<code>u2</code>类型的数据，而接口索引集合（<code>interfaces</code>）是一组<code>u2</code>类型的数据的集合，<code>Class</code>文件中由这三项数据来确定这个类的继承关系。</p>

<p><strong>类索引用于确定这个类的全限定名</strong>，<strong>父类索引用于确定这个类的父类的全限定名</strong>。由于<code>Java</code>不允许多重继承，所以父类索引只有一个，除了<code>java.lang.Object</code>之外，所有的<code>Java</code>类都有父类，因此除了<code>java.lang.Object</code>外，所有Java类的父类索引都不为0.</p>

<p>接口索引结合就用来描述这个类实现了哪些接口，<strong>这些被实现的接口将按<code>implements</code>语句后的接口顺序从左到右排列在接口的索引集合中</strong>。</p>

<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，<strong>类索引和父类索引用两个<code>u2</code>类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的全限定名字符串</strong></p>

<p><img src="media/14578521973777/14581128653713.jpg" alt=""/></p>

<p>对于接口索引集合，入口的第一项 - <code>u2</code>类型的数据为接口计数器（<code>interfaces_count</code>），表示索引表的容量。如果该类没有实现任何接口，那么该计数器值为0，后面接口的索引表不再占用任何字节。</p>

<h4 id="toc_7">字段表集合</h4>

<p>字段表（field_info）用于描述接口或类中声明的变量。字段（field）包括了类级变量或实例级变量，但不包括在方法内部声明的变量。</p>

<p>各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>

<p><img src="media/14578521973777/14581155115280.jpg" alt=""/></p>

<p>字段修饰符放在access_flags中</p>

<p><img src="media/14578521973777/14581155742017.jpg" alt=""/></p>

<p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称及字段和方法的描述符。</p>

<p><strong>全限定名</strong>：<code>org/fenixsoft/clazz/TestClass</code>是这个类的全限定名，在使用时最后一般会加入一个<code>;</code>表示全限定名结束</p>

<p><strong>简单名称</strong>：指没有类型和参数修饰的方法或字段名称，方法<code>inc()</code>和字段<code>m</code>的简单名称分别是<code>inc</code>和<code>m</code></p>

<p>方法和字段的<strong>描述符</strong>：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，<strong>基本数据类型（<code>byte, char, double, float, int, long, short, boolean</code>）及代表无返回值的<code>void</code>类型都用一个大写字符</strong>来表示，而<strong>对象类型则用字符<code>L</code>加对象的全限定名来表示</strong>。</p>

<p><img src="media/14578521973777/14581169733475.jpg" alt=""/></p>

<p>对于数组类型，每一纬度将使用一个前置的<code>[</code>字符来描述，如一个定义为<code>java.lang.String[][]</code>类型的二维数组，将被记录为：<code>[[Ljava/lang/String</code>；一个整型数组<code>int[]</code>将被记录为<code>[I</code></p>

<p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>()</code>之内。</p>

<p>如方法<code>void inc()</code>的描述符为<code>()V</code>，方法<code>java.lang.String toString()</code>的描述符为<code>()Ljava/lang/String</code>，方法<code>int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)</code>的描述符为<code>([CII[CIIII)I</code></p>

<p><img src="media/14578521973777/14581204026529.jpg" alt=""/></p>

<ul>
<li>第一个<code>u2</code>类型的数据为容量计数器<code>fields_count</code>，其值为<code>0x0001</code>，说明这个类只有一个字段表数据。</li>
<li>接下来是<code>access_flags</code>标志，其值为<code>0x0002</code>，代表<code>private</code>修饰符的<code>ACC_PRIVATE</code>标志位为真，其他修饰符为假。</li>
<li>代表字段名称的<code>name_index</code>的值为<code>0x0005</code>，从代码清单列出的常量表中可查到第五项常量是一个<code>CONSTANT_Utf8_info</code>类型的字符串，其值为<code>m</code>；代表字段描述符的<code>descriptor_index</code>的值为<code>0x0006</code>，指向常量池的字符串<code>I</code></li>
<li>根据这些信息，我们可以推断出原代码定义的字段为<code>private int m</code></li>
</ul>

<h4 id="toc_8">方法表集合</h4>

<p>方法表的结构如同字段表一样，依次包括了访问标志（<code>access_flags</code>）、名称索引（<code>name_index</code>）、描述符索引（<code>descriptor_index</code>）、属性表集合（<code>attributes</code>）几项。</p>

<p><img src="media/14578521973777/14585396884316.jpg" alt=""/></p>

<ul>
<li>第一个<code>u2</code>类型的数据（即是计数器容量）的值为<code>0x0002</code>，代表集合中有两个方法。</li>
<li>第一个方法的访问标志值为<code>0x001</code>，也就是只有<code>ACC_PUBLIC</code>标志为真</li>
<li>名称索引值为<code>0x0007</code>，查看代码清单的常量池可得方法名为<code>&lt;init&gt;</code></li>
<li>描述符索引值为<code>0x0008</code>，对应常量为<code>()V</code></li>
<li>属性表计数器<code>attributes_count</code>的值为<code>0x0001</code>就表示此方法的属性表集合有一项属性</li>
<li>属性名称索引为<code>0x0009</code>，对应常量为<code>Code</code>，说明此属性是方法的字节码描述</li>
</ul>

<p>在<code>Java</code>语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还需要必须拥有一个与原方法不同的特征签名，<strong>特征签名就是一个方法中各个参数在常量池中的字段符号引用集合</strong>，也就是因为返回值不会包含在特征签名之中，因此<code>Java</code>语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</p>

<h4 id="toc_9">属性表集合</h4>

<p>在Class文件、字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>

<p>对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要说明属性值所占用的位数长度即可。</p>

<p><img src="media/14578521973777/14585408733389.jpg" alt=""/></p>

<h5 id="toc_10">Code 属性</h5>

<p>Java程序方法体里面的代码经过javac编译器处理之后，最终变为字节码指令存储在Code属性内。</p>

<p><img src="media/14578521973777/14585473693257.jpg" alt=""/></p>

<ul>
<li>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为Code</li>
<li>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共是6个字节，所以属性值的长度固定为整个属性表的长度减去6个字节</li>
<li>max_stack代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。</li>
<li>max_locals代表了局部变量表所需的存储空间</li>
</ul>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/13</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14577020064790.html">
                    
                    <h1>事务原理与实践</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <h3 id="toc_0">事务简介</h3>

<ul>
<li>事务就是锁和并发的结合体。</li>
<li>所有的针对数据库的一个操作，都可以看做成一个事务。</li>
<li>事务单元之间只有这四种关系：读写、写读、读读、写写</li>
<li>真实业务场景中，如何以最快的速度的方式完成事务和事务之间的关系？又能保证上面四种逻辑的顺序？</li>
<li><p>做法：</p>

<ul>
<li><strong>序列化读写</strong>：<code>ACID</code>中的<code>I</code>破坏了一致性

<ul>
<li>优势：不需要冲突控制</li>
<li>劣势：慢</li>
</ul></li>
<li><p><strong>针对同一单元的访问进行控制（排他锁）</strong>：如果两个事务发生冲突，就串行；如果两个事务不会发生冲突，就并行。</p>

<pre><code>譬如两个事务单元Bob给Smith一百块；李磊给韩梅梅一百块，这两个事务单元完全没有冲突，应该可以并行
</code></pre></li>
<li><p><strong>读写锁分开</strong>：<del><code>读读</code></del>的场景并行；<code>读写</code>、<code>写读</code>、<code>写写</code>串行</p></li>
<li><p><strong><code>MVCC</code></strong>：多版本并发控制<code>Muti-Version Concurrency Control</code>，本质就是<code>Copy on write</code>，每次写都是写一个新的数据，并不是在原位更新，能够做到写不阻塞读，带来<del><code>写读</code></del>、<del><code>读写</code></del>场景的优化。</p>

<ul>
<li>劣势：系统实现的复杂度增加</li>
</ul></li>
</ul></li>
</ul>

<blockquote>
<p>现在只剩下<code>写写</code>才会产生冲突   </p>
</blockquote>

<h3 id="toc_1">事务谁先谁后？</h3>

<p>一个读请求应该读哪一个写之后的数据？</p>

<p><strong>逻辑时间戳</strong>：内存中维护一个数据的自增<code>ID</code>号，本质就是用来说明事务和事务单元之间谁先谁后</p>

<h3 id="toc_2">故障恢复</h3>

<ul>
<li>业务属性不匹配：<code>ACID</code>中的<code>A</code> 回滚，需要记住之前数据没有更改时的状态</li>
<li>系统崩溃</li>
</ul>

<h3 id="toc_3">死锁与死锁检测</h3>

<p>死锁产生的原因：</p>

<ul>
<li>两个线程参与</li>
<li>不同方向上加锁</li>
<li>作用在相同资源</li>
</ul>

<p>解决方案：</p>

<ul>
<li>尽可能不死锁：降低事务隔离级别</li>
<li><strong>碰撞检测</strong>：把所有事务单元维持的所有锁都记下来，终止死锁的一边</li>
<li>等锁超时</li>
</ul>

<h3 id="toc_4">事务的ACID（数据库怎么保证的）</h3>

<ul>
<li>原子性</li>
</ul>

<p>要么全部成功，要么全部失败</p>

<p>只是记录了一个<code>undo</code>日志回滚到之前的版本</p>

<p>Bob给Smith一百块</p>

<pre><code>ver1: Bob有100元 Smith有0元
ver2: Bob有0元 Smith有0元
    (undo：Bob有100元 Smith有0元) &lt;= 数据库回滚段
ver3: Bob有100元 Smith有100元
    (undo：Bob有0元 Smith有0元) &lt;= 数据库回滚段
</code></pre>

<ul>
<li>一致性</li>
</ul>

<pre><code>-- Lock Bob and Smith --
ver1: Bob有100元 Smith有0元
ver2: Bob有0元 Smith有0元
    (undo：Bob有100元 Smith有0元) &lt;= 数据库回滚段
ver3: Bob有0元 Smith有100元
    (undo：Bob有0元 Smith有0元) &lt;= 数据库回滚段
-- Unlock Bob and Smith --
</code></pre>

<ul>
<li>隔离性</li>
</ul>

<p>以性能为理由，对一致性的破坏（各种隔离级别）</p>

<p>隔离性扩展：快照</p>

<ul>
<li>持久性</li>
</ul>

<p>更改便持久的保存在数据库中，只要提交了就不丢</p>

<h3 id="toc_5">快照读的核心做法</h3>

<p>在回滚段中读</p>

<ul>
<li>针对读多写少的情况</li>
</ul>

<p><img src="media/14577020064790/14577073859607.jpg" alt=""/></p>

<blockquote>
<p>大部分数据库已经将<strong>快照读映射到读未提交、读已提交</strong></p>
</blockquote>

<h3 id="toc_6">事务的调优原则</h3>

<ul>
<li>在不影响业务应用的前提下，减小锁的覆盖范围</li>
<li>增加锁上可并行的线程数：读写锁分离、允许并行读取数据</li>
<li>选择正确锁的类型</li>
</ul>

<h3 id="toc_7">Consistent Nonlocking Reads in MySQL</h3>

<p>A consistent read means that InnoDB uses multi-versioning to present to a query a snapshot of the database at a point in time. </p>

<p>The query sees the changes made by transactions that <strong>committed before that point of time</strong>, and no changes made by later or uncommitted transactions. </p>

<p>The exception to this rule is that the query sees the changes made by ealier statements within the same transaction. This exception causes the following anomaly: if you update some rows in a time, a <code>SELECT</code> sees the latest version of the updated rows, but it might also see older versions of any rows. If other sessions simultaneously update the same table, the anomaly means that you might see the table in a state that never existed in the database.</p>

<p>If the transaction isolation level is <code>REPEATABLE READ</code> (the default level), all consistent reads within the same transaction read the snapshot established byu the first such read in that transaction. You can get a fresher snapshot for your queries by committing the current transaction and after that issuing new queries.</p>

<p>With READ COMMITTED isolation level, each consistent read within a transaction sets and reads its own fresh snapshot.</p>

<p>Consistent read is the default mode in which InnoDB processes <code>SELECT</code> statements in <code>READ COMMITTED</code> and <code>REPEATABLE READ</code> isolation levels. A consistent read does not set any locks on the tables it accesses, and therefore other sessions are free to modify those tables at the same time a consistent read is being performed on the table.</p>

<p>Suppose that you are running in the default <code>REPEATABLE READ</code> isolation level. When you issue a consistent read (that is, an ordinary <code>SELECT</code> statement), InnoDB gives your transaction a <strong>timepoint</strong> according to which your query sees the database. <strong>If another transaction deletes a row and commits after your timepoint was assigned, you do not see the row as having been deleted. Inserts and updates are treated similarly</strong>.</p>

<blockquote>
<p>你读数据的时候，数据不会加锁，其他人都能改你读的数据；但是你一直读到的都是最原始的数据，其他人怎么改都不会影响你读到的东西。</p>
</blockquote>

<p>In the following example, session A sees the row inserted by B onluy when B has committed the insert and A has committed as well, so that the timepoint is advanced past the commit of B.</p>

<table>
<thead><th>Session A</th><th>Session B</th></thead>
<tbody>
    <tr>
        <td>
            SET autocommit=0;
        </td>
        <td>
            SET autocommit=0;
        </td>
    </tr>
    <tr>
        <td>
            SELECT * FROM t;  
            # empty set
        </td>
        <td>
            
        </td>
    </tr>
    <tr>
        <td>
            
        </td>
        <td>
            INSERT INTO t VALUES (1, 2);
        </td>
    </tr>
    <tr>
        <td>
            SELECT * FROM t;
            # empty set
        </td>
        <td>
            
        </td>
    </tr>
    <tr>
        <td>
            
        </td>
        <td>
            COMMIT;
        </td>
    </tr>
    <tr>
        <td>
            SELECT * FROM t;
            # empty set
        </td>
        <td>
            
        </td>
    </tr>
    <tr>
        <td>
            COMMIT;
        </td>
        <td>
            
        </td>
    </tr>
    <tr>
        <td>
            SELECT * FROM t;
        </td>
        <td>
            
        </td>
    </tr>
</tbody>
</table>

<p><strong>READ UNCOMMITTED</strong>: <strong>UserA will see the change made by UserB</strong>. This isolation level is called dirty reads, which means that read data is not consistent with other parts of the table or the query, and may not yet have been committed. This isolation level ensures <strong>the quickest performance</strong>, as data is read directly from the table’s blocks with no further processing, verifications or any other validation. <strong>The process is quick and the data is as dirty as it can get</strong>.</p>

<p><strong>READ COMMITTED</strong>: <strong>UserA will not see the change made by UserB</strong>. This is because in the READ COMMITTED isolation level, the rows returned by a query are the rows that were committed when the <strong>query</strong> was started. The change made by UserB was not present when the <strong>query</strong> started, and therefore will not be included in the query result.</p>

<p><strong>REPEATABLE READ</strong>: <strong>UserA will not see the change made by UserB</strong>. This is because in the REPEATABLE READ isolation level, the rows returned by a query are the rows that were committed when the <strong>transaction</strong> was started. The change made by UserB was not present when the <strong>transaction</strong> was started, and therefore will not be included in the query result.</p>

<p>This means that “<strong>All consistent reads within the same transaction read the snapshot established by the first read</strong>” (from MySQL documentation.).</p>

<p><strong>SERIALIZABLE</strong>: This isolation level specifies that <strong>all transactions occur in a completely isolated fashion, meaning as if all transactions in the system were executed serially, one after the other</strong>. The DBMS can execute two or more transactions at the same time only if the illusion of serial execution can be maintained.</p>

<p>In practice, <strong>SERIALIZABLE is similar to REPEATABLE READ</strong>, but <strong>uses a different implementation for each database engine</strong>. <mark>In Oracle, the REPEATABLE READ level is not supported and SERIALIZABLE provides the highest isolation level. This level is similar to REPEATABLE READ, but InnoDB implicitly converts all plain SELECT statements to “SELECT … LOCK IN SHARE MODE</mark>.</p>

<blockquote>
<p>The default isolation level in MySQL’s InnoDB is <strong>REPEATABLE READ</strong>.</p>
</blockquote>

<p>Since old values of row data are required for current queris, databases use a special segment to store old row values and snapshot. MySQL calls this segment a Rollback Segment (Undo Segment in Oracle).</p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/11</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14576660245189.html">
                    
                    <h1>垃圾收集器与内存分配策略</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p>程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性。</p>

<p>而<strong><code>Java</code>堆和方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，<strong>这部分内存的分配和回收都是动态的</strong>，<strong>垃圾收集器所关注的是这部分内存</strong>。</p>

<h4 id="toc_0">引用技术算法</h4>

<p><strong>虚拟机并不是通过引用计数算法来判断对象是否存活的</strong>。</p>

<h4 id="toc_1">根搜索算法</h4>

<p>通过一系列的名为<code>CG Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用连（<code>Reference Chain</code>），<strong>当一个对象到<code>GC Roots</code>没有任何引用连相连时，则证明此对象是不可用的</strong>。</p>

<h4 id="toc_2">再谈引用</h4>

<ul>
<li>强引用：<strong>类似<code>Object obj = new Object()</code>这类的引用</strong>，只要强引用还存在，垃圾收集器永远不会回收掉引用的对象</li>
<li>软引用：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，<strong>在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收</strong>。</li>
<li>弱引用：用来描述非必需对象，它的强度比软引用更弱。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。</li>
<li>虚引用：也称为幽灵引用或者幻影引用。它是最弱的一种引用关系。<strong>为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知</strong>。</li>
</ul>

<h4 id="toc_3">生存还是死亡</h4>

<p>在根搜索算法中不可达的对象，它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被<strong>第一次标记并且进行一次筛选</strong>，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>

<p>如果这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条虚拟机自动建立的，低优先级的<code>Finalizer</code>线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。稍后<code>GC</code>将对<code>F-Queue</code>中的对象<strong>进行第二次小规模的标记</strong>，只要对象能重新与引用链上的任何一个对象建立关联即可。</p>

<h4 id="toc_4">回收方法区</h4>

<p>方法区（或者<code>HotSpot</code>虚拟机中的永久机）的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>

<p>回收废弃常量与回收<code>Java</code>堆中的对象非常类似。例如一个字符串<code>abc</code>已经进入了常量池中，但是没有任何<code>String</code>对象引用常量池中的<code>abc</code>常量，也没有其他地方引用了这个字面量，如果在这个时候发生内存回收，而且必要的话，这个<code>abc</code>常量就会被系统清除出了常量池。</p>

<p>判定一个常量是否是“废弃常量”比较简单，而要<strong>判定一个类是否是“无用的类”的条件</strong>则相对苛刻。类要同时满足下面三个条件才能算是“无用的类”：</p>

<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是<code>Java</code>堆中不存在该类的任何实例</li>
<li><strong>加载该类的<code>ClassLoader</code>已经被回收</strong></li>
<li><strong>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法</li>
</ul>

<h3 id="toc_5">垃圾收集算法</h3>

<h4 id="toc_6">标记 - 清除算法</h4>

<p>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p>

<p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致：当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>

<h4 id="toc_7">复制算法</h4>

<p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<strong>当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉</strong>。</p>

<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。</p>

<p>这种算法的代价是将内存缩小为原来的一半。</p>

<p>新生代的对象98%是朝生夕死的，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为<strong>一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间</strong>，<strong>每次使用<code>Eden</code>和其中的一块<code>Survivor</code></strong>。当回收时，<strong>将<code>Eden</code>和<code>Survivor</code>中还存活着的对象一次性地拷贝到另外一块<code>Survivor</code>空间上</strong>，最后清理掉<code>Eden</code>和刚才用过的<code>Survivor</code>的空间。</p>

<p><code>HotSpot</code>虚拟机默认<code>Eden</code>和<code>Survivor</code>的大小比例是8：1，只有10%的内存会被浪费掉（备用<code>Survivor</code>），但是我们没办法保证每次回收都只有不多于10%的对象存活，当<code>Survivor</code>空间不够用时，需要依赖其他内存（老年代）进行分配担保（<code>Handle Promotion</code>）</p>

<h4 id="toc_8">标记 - 整理算法</h4>

<p>根据老年代的特点，有人提出了另外一种“标记 - 整理”（Mark-Compact）算法，标记过程仍然与“标记-清楚”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>

<h4 id="toc_9">分代收集算法</h4>

<p>根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>

<p><strong>在新生代中</strong>，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就<strong>选用复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p>

<p><strong>老年代</strong>中因为对象存活率高、没有额外空间对它进行担保，就必须<strong>使用“标记-清理”或“标记-整理”算法</strong>来进行回收。</p>

<h3 id="toc_10">内存分配与回收策略</h3>

<p>自动内存管理最终可以归结为自动化地解决了两个问题：</p>

<ul>
<li>给对象分配内存</li>
<li>回收分配给对象的内存</li>
</ul>

<p>对象的内存分配，就是在堆上分配，对象主要分配在新生代的<code>Eden</code>区上，如果启动了本地线程分配缓冲，将按线程优先在<code>TLAB</code>上分配。</p>

<p>几条最普通的内存分配规则。</p>

<h4 id="toc_11">对象优先在Eden分配</h4>

<p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p>

<pre><code>新生态GC（Minor GC）：指发生在新生代的垃圾收集动作，Minor GC非常频繁，一般回收速度也比较快。
老年代GC（Major GC / Full GC）：指发生在老年代的GC。
</code></pre>

<h4 id="toc_12">大对象直接进入老年代</h4>

<p>所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>

<blockquote>
<p>大对象对虚拟机的内存分配来说就是一个坏消息；比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”。</p>
</blockquote>

<h4 id="toc_13">长期存活的对象将进入老年代</h4>

<p>虚拟机给每个对象定义了一个对象年龄（<code>Age</code>）计数器。如果对象在<code>Eden</code>出生并经过第一次<code>Minor GC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，将被移动到<code>Survivor</code>空间中，并将对象年龄设为1。对象在<code>Survivor</code>区中每熬过一个<code>Minor GC</code>，年龄就增加1岁，当它的年龄增加到一定程度（默认是15岁）时，就会被晋升到老年代。</p>

<h4 id="toc_14">动态对象年龄判定</h4>

<p>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到<code>MaxTenuringThreshold</code>才能晋升到老年代；<strong>如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半</strong>，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</p>

<h4 id="toc_15">空间分配担保</h4>

<p>在发生<code>Minor GC</code>时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次<code>Full GC</code>。如果小于，则查看<code>HandlePromotionFailure</code>设置是否允许担保失败；如果允许，那只会进行<code>Minor GC</code>；如果不允许，则也要改为进行一次<code>Full GC</code>。</p>

<p>新生代使用复制收集算法，但为了内存利用率，只使用其中一个<code>Survivor</code>空间来作为轮换备份，因此当出现大量对象在<code>Minor GC</code>后仍然存活的情况时，就需要老年代进行分配担保，让<code>Survivor</code>无法容纳的对象直接进入老年代。</p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/11</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            


            <div class="row">
                <div class="large-6 columns">
                    <p class="text-left" style="padding-top:25px;">
                         <a href="all_4.html">&laquo; Prev Page</a> 
                    </p>
                </div>
                <div class="large-6 columns">
                    <p class="text-right" style="padding-top:25px;">
                         <a href="all_6.html">&raquo; Next Page</a> 
                    </p>
                </div>
            </div>
        </div>
    </div>
    <!-- large 8 -->

 <div class="large-4 medium-4 columns">
    <div class="hide-for-small">
        <div id="sidebar" class="sidebar">
            <div id="site-info" class="site-info">
                
                <h1>NathanCHEN</h1>

                <div class="site-des"></div>
                <div class="social">
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <a class="rss" href="atom.xml" title="RSS">RSS</a>

                </div>
            </div>
            <div id="site-categories" class="side-item ">
                <div class="side-header">
                    <h2>Contact</h2>
                </div>
                <div class="side-content">
                    <ul class="posts-list">
                        <li class="post">
                            <p class="email-addr">tringchen AT gmail.com</p>

                            <p class="email-addr">江苏 · 南京</p>
                        </li>
                    </ul>
                </div>
            </div>
            <div id="site-categories" class="side-item ">
                <div class="side-header">
                    <h2>Categories</h2>
                </div>
                <div class="side-content">

                    <p class="cat-list">
                        
                        <a href="Java.html"><strong>Java</strong></a>
                        
                        <a href="JavaScript.html"><strong>JavaScript</strong></a>
                        
                        <a href="Ngnix.html"><strong>Ngnix</strong></a>
                        
                        <a href="tomcat.html"><strong>tomcat</strong></a>
                        
                        <a href="spring.html"><strong>spring</strong></a>
                        
                        <a href="RabbitMQ.html"><strong>RabbitMQ</strong></a>
                        
                        <a href="ELK.html"><strong>ELK</strong></a>
                        
                        <a href="TCP/IP.html"><strong>TCP/IP</strong></a>
                        
                        <a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"><strong>源码阅读</strong></a>
                        
                        <a href="others.html"><strong>others</strong></a>
                        
                        <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
                        
                        <a href="PAXOS.html"><strong>PAXOS</strong></a>
                        
                        <a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html"><strong>深入分析Java Web技术内幕</strong></a>
                        
                    </p>


                </div>
            </div>

            <div id="site-categories" class="side-item">
                <div class="side-header">
                    <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                    <ul class="posts-list">
                        
                        
                        <li class="post">
                            <a href="14594286280881.html">索引的相关知识</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14594277278701.html">Java序列化</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14594153252228.html">Java传值还是传引用</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14592202648535.html">`Local Storage`缓存</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14590098445355.html">应用多级缓存模式支撑海量读服务</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                </div>
            </div>
        </div>
        <!-- sidebar -->
    </div>
    <!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->
 <div class="page-bottom clearfix">
    <div class="row">
        <p class="copyright">Copyright &copy; 2016
            Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp;
            Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
    </div>
</div>
</section>
</div>
</div>




<script src="asset/js/foundation.min.js"></script>
<script>
    $(document).foundation();
    function fixSidebarHeight() {
        var w1 = $('.markdown-body').height();
        var w2 = $('#sidebar').height();
        if (w1 > w2) {
            $('#sidebar').height(w1);
        }
        ;
    }
    $(function () {
        fixSidebarHeight();
    })
    $(window).load(function () {
        fixSidebarHeight();
    });

</script>





</body>
</html>
