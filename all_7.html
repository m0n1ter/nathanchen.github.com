<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	NathanCHEN
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html">NathanCHEN</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-02T13:55:51+08:00" itemprop="datePublished">2016/3/2</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14568981515532.html" itemprop="url">
		从`ACID`到`CAP`到`BASE`</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0"><code>ACID</code></h3>

<ol>
<li><code>Atomic</code>原子性</li>
</ol>

<p>事务必须是一个原子的操作序列单元，事务中包含的各项操作在一次执行过程中，要么全部执行成功，要么全部不执行，任何一项失败，整个事务回滚，只有全部都执行成功，整个事务才算成功。</p>

<ol>
<li><code>Consistency</code>一致性</li>
</ol>

<p>事务的执行不能破坏数据库数据的完整性和一致性，事务在执行之前和之后，数据库都必须处于一致性的状态</p>

<ol>
<li><code>Isolation</code>隔离性</li>
</ol>

<p>在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。</p>

<ol>
<li><code>Durability</code>持久性</li>
</ol>

<p>一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的，即使发生系统崩溃或机器宕机，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。</p>

<h4 id="toc_1"><code>SQL</code>中的4个事务隔离级别</h4>

<ul>
<li>读未提交：允许脏读。如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此事务没有提交。</li>
<li>读已提交：允许不可重复读。只允许读到已经提交的数据。</li>
<li>可重复读：允许幻读。即同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。</li>
<li>串行化：最严格的事务，要求所有事务被串行执行，不能并发执行。</li>
</ul>

<h3 id="toc_2"><code>CAP</code>定理</h3>

<p>一个分布式系统不可能同时满足一致性<code>Consistency</code>、可用性<code>Availability</code>、分区容错性<code>Partition tolerance</code>这三个基本需求，最多只能同时满足其中的两项。</p>

<h4 id="toc_3">一致性</h4>

<p>分布式环境中，一致性是指多个副本之间能否保持一致的特征。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处理一致的状态。</p>

<h4 id="toc_4">可用性</h4>

<p>系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在<strong>有限的时间</strong>内返回<strong>正常结果</strong>。</p>

<h4 id="toc_5">分区容错性</h4>

<p>分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>

<h3 id="toc_6">BASE定理</h3>

<p>Basically Available（基本可用）、Soft State（软状态）、Eventually Consistent（最终一致性），基于CAP定理演化而来，核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>

<h4 id="toc_7">Basically Available（基本可用）</h4>

<p>分布式系统在出现不可预知的故障的时候，允许损失部分可用性，但不等于系统不可用。</p>

<h4 id="toc_8">Soft State（软状态）</h4>

<p>允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>

<h4 id="toc_9">Eventually Consistent（最终一致性）</h4>

<p>强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。其本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-02-24T12:21:55+08:00" itemprop="datePublished">2016/2/24</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='others.html'>others</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14562877150519.html" itemprop="url">
		Git flow</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">第一步：管理员新建项目</h3>

<ul>
<li>使用<code>sckf</code>帐号在<code>Git@OSC</code>中建立新的项目：<strong>一定要建私有类型的项目</strong></li>
</ul>

<p><img src="media/14562877150519/14562888025428.jpg" alt=""/></p>

<ul>
<li><p>在设置中要求团队的所有人，默认都设置为<code>开发者</code></p>

<pre><code>马琳(绒球小喵)：651024486@qq.com
王钊(王钊)：wangzhao@hao24.cn
陈文静(chenwenjing099)：1012573831@qq.com
陈嵚(Nathan)：qche7764@uni.sydney.edu.au
秦义胜：
</code></pre></li>
</ul>

<h3 id="toc_1">第二步：导入项目</h3>

<blockquote>
<p>一定要写<code>.gitignore</code>文件</p>
</blockquote>

<p>新建一个项目</p>

<pre><code>echo &quot;# tett&quot; &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin XXX
git push -u origin master
</code></pre>

<p>或者将本地项目放到<code>git</code>上</p>

<pre><code>git remote add origin XXX
vim .gitignore

git add .
git commit -m &#39;first commit&#39;
git push -u origin master
</code></pre>

<p><code>.gitignore</code>文件</p>

<pre><code>.idea/
*.iml
/out/
*.class
target/
.svn/
</code></pre>

<h3 id="toc_2">第三步：在phabricator设置Code Review</h3>

<p>通知 陈嵚</p>

<h3 id="toc_3">第四步：按照功能点建立分支</h3>

<pre><code>git checkout -b hotfix
...做写修改..
git add .
git commit -m &#39;修复XXXX&#39;
git push origin hotfix
</code></pre>

<h3 id="toc_4">第五步：申请合并到主分支</h3>

<p>在<code>Git@OSC</code>页面中切换到<code>hotfix</code>分支</p>

<p>发起<code>pull request</code>请求，请求从<code>hotfix</code> -&gt; <code>master</code></p>

<p>取决于你的权限，你会看到：</p>

<p><img src="media/14562877150519/14562896572869.jpg" alt=""/></p>

<p><strong><code>pull request</code>合并后删除提交分支 必选！</strong></p>

<p>或者</p>

<p><img src="media/14562877150519/14562899619504.jpg" alt=""/></p>

<h3 id="toc_5">第六部：Reviewer审查完毕，合并代码到主分支</h3>

<p><img src="media/14562877150519/14562889533167.jpg" alt=""/></p>

<p><code>Reviewer</code>负责删除已经合并的分支</p>

<h3 id="toc_6">范例</h3>

<p><code>--rebase</code>命令的作用是将先从远程<code>master</code>中下载最新的数据到我的分支，然后再将我的提交整合到这个分支的最顶端。</p>

<p>The <code>--rebase</code> option tells Git to move all of Mary&#39;s commits to the tip of the master branch after synchronizing it with the changes from the central repository.</p>

<pre><code>git pull --rebase origin master
</code></pre>

<p><img src="media/14562877150519/14563139512652.jpg" alt=""/></p>

<p>如果两个人在对不同的文件进行处理，那么他们基本不可能会产生冲突。如果真的有冲突产生，<code>Git</code>会暂停<code>rebase</code>并且打印出冲突信息</p>

<p>If Mary and John are working on unrelated features, it&#39;s unlikely that the rebasing process will generate conflicts. But if it does, Git will pause the rebase at the current commit and output the following message, along with some relevant instructions:</p>

<pre><code>CONFLICT (content): Merge conflict in &lt;some-file&gt;
</code></pre>

<p>使用<code>git status</code>可以查看冲突文件信息</p>

<p>Mary would simply run a git status to see where the problem is. Conflicted files will appear in the Unmerged paths section:</p>

<pre><code># Unmerged paths:
# (use &quot;git reset HEAD &lt;some-file&gt;...&quot; to unstage)
# (use &quot;git add/rm &lt;some-file&gt;...&quot; as appropriate to mark resolution)
#
# both modified: &lt;some-file&gt;
</code></pre>

<p>解决好了冲突，就可以使用<code>git add</code>把修改的冲突文件重新加进去，再使用<code>git rebase --continue</code>继续rebase</p>

<p>Then, she can stage the file(s) in the usual fashion and let git rebase do the rest:</p>

<pre><code>git add &lt;some-file&gt;
git rebase --continue   
</code></pre>

<h3 id="toc_7">Feature Branch Workflow</h3>

<pre><code>git checkout -b marys-feature master
...
git status
git add &lt;some-file&gt;
git commit

git push -u origin marys-feature
// This serves as a convenient backup
</code></pre>

<p>在将自己的修改合并到主分支的时候，需要发起一个<code>pull request</code>，让大家都知道自己做了什么</p>

<p>Before merging it into master, she needs to file a pull request letting the rest of the team know she&#39;s done.</p>

<p>She files the pull request in her Git GUI asking to merge marys-feature into master</p>

<p>在发起<code>pull request</code>之后，还可以去修改自己的文件，所有修改会显示在<code>pull request</code>中</p>

<p>To make the changes, Mary uses the exact same process as she did to create the first iteration of her feature. She edits, stages, commits, and pushes updates to the central repository. <strong>All her activity shows up in the pull request</strong>, and Bill can still make comments along the way.</p>

<p>其他人可以将别人的<code>pull request</code>拉倒自己本地来修改，任何提交也会显示在<code>pull request</code>中</p>

<p>If he wanted, Bill could pull marys-feature into his local repository and work on it on his own. <strong>Any commits he added would also show up in the pull request</strong>.</p>

<p>一旦审核人统一接受<code>pull request</code>，就可以合并到主分支了</p>

<p>Once Bill is ready to accept the pull request</p>

<pre><code>// check out their master branch 
git checkout master
// make sure it&#39;s up to date
git pull
// merge the central repository&#39;s copy of marys-feature
git pull origin marys-feature
// push back to origin
git push
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-02-23T19:53:59+08:00" itemprop="datePublished">2016/2/23</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Java.html'>Java</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14562284391371.html" itemprop="url">
		初探Java字符串</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>字符串对象内部是用字符数组存储的</p>

<pre><code class="language-java">    String m = &quot;hello,world&quot;;
    String n = &quot;hello,world&quot;;
    String u = new String(m);
    String v = new String(&quot;hello,world&quot;);
</code></pre>

<p>这些语句会发生这么些事情：<br/>
1. 会分配一个长度为11的<code>char</code>数组，并在常量池分配一个由这个<code>char</code>数组组成的字符串，然后由<code>m</code>去引用这个字符串<br/>
2. 用<code>n</code>去引用常量池里面的字符串，所以和<code>n</code>引用的是同一个对象<br/>
3. 生成一个新的字符串，但是内部的字符数组引用着<code>m</code>内部的字符数组<br/>
4. 生成一个新的字符串，但是内部的字符数组引用常量池里面的字符串内部的字符数组</p>

<p><img src="media/14562284391371/14562286878462.jpg" alt=""/></p>

<p>字符串常量通常是在编译的时候就确定好的，定义在类的方法区里面；也就是说，不同的类，即使用了同样的字符串，还是属于不同的对象。</p>

<h4 id="toc_0">字符串的操作细节</h4>

<pre><code class="language-java">    String m = &quot;hello,world&quot;;
    String u = m.substring(2,10);
    String v = u.substring(4,7);
</code></pre>

<p><img src="media/14562284391371/14562287855713.jpg" alt=""/></p>

<p><code>m,n,v</code>是三个不同的字符串对象，但引用的<code>value</code>数组其实是同一个。</p>

<p>但是字符串操作时，可能需要修改原来的字符串数组内容或者原数组没法容纳的时候，就会使用另外一个新的数组（例如<code>replace</code>，<code>concat</code>，<code>+</code>等操作）</p>

<pre><code class="language-java">    String m = &quot;hello,&quot;;
    String u = m.concat(&quot;world&quot;);
    String v = new String(m.substring(0,2));
</code></pre>

<p><img src="media/14562284391371/14562290927387.jpg" alt=""/></p>

<h4 id="toc_1">常量池中字符串的产生</h4>

<pre><code class="language-java">    String m = &quot;hello,world&quot;;
    String u = m + &quot;.&quot;;
    String v = &quot;hello,world.&quot;;
</code></pre>

<p><code>u</code>和<code>v</code>虽然是一样的内容的字符串，但是内部的字符数组不是同一个。</p>

<p>如果将<code>m</code>定义为<code>final</code>，编译器就会把u和v做成一样的了。</p>

<h4 id="toc_2">Reference</h4>

<p><a href="http://www.importnew.com/17034.html">http://www.importnew.com/17034.html</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-02-23T13:42:42+08:00" itemprop="datePublished">2016/2/23</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='others.html'>others</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14562061622587.html" itemprop="url">
		HTML解析</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>HTML5解析由两部分组成：分词与构建树。</p>

<p>分词属于语法分析部分，它把输入解析成符号序列。在HTML中符号就是开始标签，结束标签，属性名称和属性值。</p>

<h4 id="toc_0">分词算法</h4>

<p>分词算法可以用状态机来描述。每一个状态从输入流中消费一个或者多个字符，并根据它们更新下一状态。</p>

<p>决策受当前符号状态和树的构建状态影响。这意味着同样的字符可能会产生不同的结果，取决于当前的状态。</p>

<pre><code>&lt;html&gt;
    &lt;body&gt;
        Hello world
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>初始状态是<code>Data state</code>，当遇到<code>&lt;</code>时状态改为<code>Tag open state</code>。吃掉<code>a-z</code>字符组成的符号后产生了<code>Start tag token</code>，状态变更为<code>Tag name state</code>。我们一直保持此状态，直到遇到<code>&gt;</code>。每个字符都被追加到新的符号名上。在我们的例子中，解出的符号就是<code>html</code>。</strong></p>

<p><strong>当碰到<code>&gt;</code>时，当前符号完成，状态改回<code>Data state</code>。<code>&lt;body&gt;</code>标签将会以同样的方式处理。现在<code>html</code>与<code>body</code>标签都完成了，我们回到<code>Data state</code>状态。吃掉<code>H</code>（<code>Hello world</code>第一个字母）时会产生一个字符符号，直到碰到<code>&lt;/body&gt;</code>的<code>&lt;</code>符号，我们就完成了一个字符符号<code>Hello world</code>。</strong></p>

<p><strong>现在我们回到<code>Tag open state</code>状态。吃掉下一个输入<code>/</code>时会产生一个<code>end tag token</code>并变更为<code>Tag name state</code>状态。同样，此状态保持到我们碰到<code>&gt;</code>时。这时新标签符号完成，我们又回到<code>Data state</code>。同样<code>&lt;/html&gt;</code>也会被这样处理。</strong></p>

<h4 id="toc_1">树的构建算法</h4>

<p>当分词解析器被创建时，文档对象也会被创建。</p>

<p>在树的创建过程中DOM树的根节点（Document）将被修改，元素被添加到上面去。每个分词器完成的节点都会被树构建器处理。</p>

<p>除了把元素添加到DOM树外，它还会被添加到一个开放元素堆栈。这个堆栈用于纠正嵌套错误和标签未关闭错误。</p>

<pre><code>&lt;html&gt;
    &lt;body&gt;
        Hello world
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>树的构建过程中，输入就是分词过程中得到的符号序列。</strong>第一个模式叫<code>initial mode</code>。接收<code>html</code>符号后会变成<code>before html</code>模式并重新处理此模式中的符号。这会创建一个<code>HTMLHtmlElement</code>元素并追加到根文档节点。</p>

<p>然后状态改变为<code>before head</code>。我们收到<code>body</code>时，<strong>会隐式创建一个<code>HTMLHeadElement</code>，尽管我们没有这个标签，它也会被创建并添加到树中。</strong></p>

<p>现在我们进入<code>in head</code>模式，然后是<code>after head</code>，<code>Body</code>会被重新处理，创建<code>HTMLBodyElement</code>元素并插入，然后进入<code>in body</code>模式。</p>

<p>字符符号<code>Hello world</code>收到后会创建一个<code>Text</code>节点，所有字符都被一一追加到上面。</p>

<p>收到<code>body</code>结束标签后进入<code>after body</code>模式，收到<code>html</code>结束标签后进入<code>after after body</code>模式。所有符号处理完后将终止解析。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-02-22T15:44:15+08:00" itemprop="datePublished">2016/2/22</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html'>源码阅读</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14561270553113.html" itemprop="url">
		JSoup</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li><p>如果要建立一个对象只包含一个<code>ArrayList&lt;Object&gt;</code>，可以<code>extends</code>这个<code>ArrayList&lt;Object&gt;</code><br/>
<img src="media/14559858435476/14559859207916.jpg" alt=""/></p></li>
<li><p>TokenType包含</p></li>
</ul>

<pre><code>    TokenType
    ├── Doctype: name, publicIdentifier, systemIdentifier
    ├── StartTag: tagName, pendingAttributeName, pendingAttributeValue, attributes
    ├── EndTag: tagName, pendingAttributeName, pendingAttributeValue
    ├── Comment: data
    ├── Character: data
    ├── EOF: EOF
</code></pre>

<ul>
<li><p><code>HtmlTreeBuilderState</code>中定义了分析<code>html</code>页面时各种状态以及在各种状态下对应的处理方法（<strong>状态机</strong>）</p>

<pre><code>this.state.process(..)
</code></pre></li>
</ul>

<p>譬如</p>

<pre><code class="language-java">Initial {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                return true; // ignore whitespace
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                // todo: parse error check on expected doctypes
                // todo: quirk state check on doctype ids
                Token.Doctype d = t.asDoctype();
                DocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());
                tb.getDocument().appendChild(doctype);
                if (d.isForceQuirks())
                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);
                tb.transition(BeforeHtml);
            } else {
                // todo: check not iframe srcdoc
                tb.transition(BeforeHtml);
                return tb.process(t); // re-process token
            }
            return true;
        }
    },
</code></pre>

<p>当进入<code>initial</code>状态的时候，只可能出现四种情况<code>whitespace</code>, <code>comment</code>, <code>doctype</code>, 其他。在不同的情况下，定义了各种后续的策略</p>

<p>状态和下一状态的转换使用<code>tb.transition(BeforeHtml)</code>来进行。</p>

<ul>
<li>HTML解析状态机</li>
</ul>

<pre><code class="language-html">    &lt;!-- State: Initial --&gt;
    &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
    &lt;!-- State: BeforeHtml --&gt;
    &lt;html lang=&#39;zh-CN&#39; xml:lang=&#39;zh-CN&#39; xmlns=&#39;http://www.w3.org/1999/xhtml&#39;&gt;
    &lt;!-- State: BeforeHead --&gt;
    &lt;head&gt;
      &lt;!-- State: InHead --&gt;
      &lt;script type=&quot;text/javascript&quot;&gt;
      //&lt;!-- State: Text --&gt;
        function xx(){
        }
      &lt;/script&gt;
      &lt;noscript&gt;
        &lt;!-- State: InHeadNoscript --&gt;
        Your browser does not support JavaScript!
      &lt;/noscript&gt;
    &lt;/head&gt;
    &lt;!-- State: AfterHead --&gt;
    &lt;body&gt;
    &lt;!-- State: InBody --&gt;
    &lt;textarea&gt;
        &lt;!-- State: Text --&gt;
        xxx
    &lt;/textarea&gt;
    &lt;table&gt;
        &lt;!-- State: InTable --&gt;
        &lt;!-- State: InTableText --&gt;
        xxx
        &lt;tbody&gt;
        &lt;!-- State: InTableBody --&gt;
        &lt;/tbody&gt;
        &lt;tr&gt;
            &lt;!-- State: InRow --&gt;
            &lt;td&gt;
                &lt;!-- State: InCell --&gt;
            &lt;/td&gt;
        &lt;/tr&gt;    
    &lt;/table&gt;
    &lt;/html&gt;

</code></pre>

<ul>
<li><code>HTML</code>解析树</li>
</ul>

<p>根据如下代码:</p>

<pre><code class="language-java">        String html = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;First!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;First post! &lt;img src=\&quot;foo.png\&quot; /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
        Document doc = Jsoup.parse(html);
</code></pre>

<p>生成的<code>HTML</code>解析树（<code>Document</code>）</p>

<pre><code>doc-&gt;childNodes: 
        &lt;html&gt;&lt;head&gt;...&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt;

doc-&gt;childNodes-&gt;childNodes
        &lt;head&gt;...&lt;/head&gt;
        &lt;body&gt;...&lt;/body&gt;
</code></pre>

<p>然后继续按照<code>childNodes</code>分下去就是一颗完整的树</p>

<ul>
<li><code>HTML</code>解析</li>
</ul>

<p><code>Token token = tokeniser.read();</code>就是在分词，分出<code>&lt;html&gt;</code>等词出来</p>

<pre><code class="language-java">protected void runParser() {
   while (true) {
       Token token = tokeniser.read();
       process(token);

       if (token.type == Token.TokenType.EOF)
           break;
   }
}
</code></pre>

<ul>
<li><code>getElementByTag(&quot;a&quot;)</code></li>
</ul>

<p>寻找<code>tagName</code>为<code>a</code>的<code>element</code></p>

<pre><code class="language-java">new NodeTraversor(new Accumulator(root, elements, eval)).traverse(root);
</code></pre>

<p>使用<code>NodeTraversor</code>一个<code>element</code>一个<code>element</code>的遍历生成的<code>document</code>，找到一个<code>element</code>之后在<code>Accumulator</code>的<code>head</code>方法中判断是不是要找的<code>tagName</code>为<code>a</code>的<code>element</code>，如果是，就加到<code>elements</code>变量中</p>

<ul>
<li><code>TokenQueue</code></li>
</ul>

<pre><code class="language-java">TokenQueue tq = new TokenQueue(&quot;(one (two) three) four&quot;);
String guts = tq.chompBalanced(&#39;(&#39;, &#39;)&#39;);
assertEquals(&quot;one (two) three&quot;, guts);
</code></pre>

<p>使用<code>chompBalanced(char open, char close)</code>获取<code>open</code>和<code>close</code>之间的内容</p>

<pre><code class="language-java">do {
       if (isEmpty()) break;
       Character c = consume();
       if (last == 0 || last != ESC) {
           if (c.equals(open))
               depth++;
           else if (c.equals(close))
               depth--;
       }

       if (depth &gt; 0 &amp;&amp; last != 0)
           accum.append(c); // don&#39;t include the outer match pair in the return
       last = c;
   } while (depth &gt; 0);
</code></pre>

<p>找到符合<code>open</code>的元素，<code>depth+1</code>；找到符号<code>close</code>的元素，<code>depth-1</code>。期间的内容append就是需要提取的元素。</p>

<p><code>depth</code>不为0但是依然没有找到符合<code>close</code>的元素，就把找到的全输出</p>

<pre><code class="language-java">TokenQueue tq = new TokenQueue(&quot;(one (two three) four&quot;);
String guts = tq.chompBalanced(&#39;(&#39;, &#39;)&#39;);
// guts = one (two three four
</code></pre>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_6.html">Prev</a>  
	 <a class="next" href="all_8.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>