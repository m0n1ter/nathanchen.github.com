<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title><![CDATA[NathanCHEN]]></title>
    <link href="http://nathanchen.github.io/atom.xml" rel="self"/>
    <link href="http://nathanchen.github.io/"/>
    <updated>2016-04-04T00:11:29+08:00</updated>
    <id>http://nathanchen.github.io/</id>
    <author>
        <name><![CDATA[]]></name>

    </author>
    <generator uri="http://www.mweb.im/">MWeb</generator>
    
    <entry>
        <title type="html"><![CDATA[HTTP/2]]></title>
        <link href="http://nathanchen.github.io/14608176804744.html"/>
        <updated>2016-04-16T22:41:20+08:00</updated>
        <id>http://nathanchen.github.io/14608176804744.html</id>
        <content type="html"><![CDATA[
<h2 id="toc_0">HTTP/1连接</h2>

<p>在HTTP1中，每个请求和响应都占用一个TCP链接，尽管有Keep-Alive机制可以复用，但是在每个连接上同时只能有一个请求/响应，这意味着完成响应之前，这个连接不能用于其他请求。如果浏览器需要向同一个域名发送多个请求，需要在本地维护一个FIFO队列，完成一个再发送下一个。<strong>这样，从服务端完成请求开始回传，到收到下一个请求之间的这段时间，服务器处于空闲状态</strong>。</p>

<p>后来，人们提出了HTTP管道的概念，试图把本地的FIFO队列挪到服务端。它的原理是这样的：浏览器一股脑把请求都发送给服务端，然后等着就可以了。这样服务端就可以在处理完一个请求后，马上处理下一个，不会有空闲了。甚至服务端还可以多线程并行处理多个请求。</p>

<h3 id="toc_1">HTTP/1优化</h3>

<h4 id="toc_2">开源</h4>

<p>既然一个TCP连接同时只能处理一个HTTP消息，那多开几条TCP连接不就解决这个问题了。</p>

<p>浏览器确实是这样做的。现代浏览器一般允许同域名并发6~8个连接。这个数字为什么不能更大呢？实际上这是出于公平性的考虑，每个连接对于服务器来说都会带来一定开销，如果浏览器不加以限制，一个性能好、带宽足的终端就可能耗尽服务器所有资源，造成其他人无法使用。</p>

<p>我们还会使用Cookie-Free Domain来减少静态文件带cookies的问题</p>

<h4 id="toc_3">节流</h4>

<p>合并图片、js、css等</p>

<h2 id="toc_4">HTTP/2</h2>

<p>开启<code>Server Push</code>。HTTP/2的多路复用特征，使得可以在一个连接上同时打开多个流，双向传输数据。Server Push，意味着服务端可以在发送页面HTML时主动推送其他资源，而不用等到浏览器解析到相应位置，发起请求再响应。另外，服务端主动推送的资源不是被内联在页面里，它们有自己独立的URL，可以被浏览器缓存。</p>

<h3 id="toc_5">Reference</h3>

<p><a href="https://imququ.com/post/http2-and-wpo-1.html">https://imququ.com/post/http2-and-wpo-1.html</a></p>

<p><a href="https://imququ.com/post/http2-and-wpo-2.html">https://imququ.com/post/http2-and-wpo-2.html</a></p>

<p>HTTP2-high-perf-browser-networking.pdf</p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Web页面缓存]]></title>
        <link href="http://nathanchen.github.io/14606892007159.html"/>
        <updated>2016-04-15T11:00:00+08:00</updated>
        <id>http://nathanchen.github.io/14606892007159.html</id>
        <content type="html"><![CDATA[
<blockquote>
<p>采用nginx+lua+redis进行页面缓存</p>
</blockquote>

<h3 id="toc_0">1.配置nginx+lua+redis环境</h3>

<h4 id="toc_1">安装lua解释器</h4>

<pre><code class="language-shell">wget http://luajit.org/download/LuaJIT-2.0.2.tar.gz
</code></pre>

<p>配置<code>lua Lib</code>和<code>include/luajit-$version</code>目录为环境变量</p>

<h4 id="toc_2">下载<code>ngx_devel_kit</code>和<code>lua-nginx-module</code></h4>

<pre><code class="language-shell">https://codeload.github.com/simpl/ngx_devel_kit/tar.gz/v0.2.19
https://codeload.github.com/openresty/lua-nginx-module/tar.gz/v0.9.10
</code></pre>

<h4 id="toc_3">安装配置nginx</h4>

<pre><code class="language-shell">http://nginx.org/download/nginx-1.4.7.tar.gz（http://nginx.org/en/download.html
</code></pre>

<p><code>nginx configue</code>时候，将<code>ngx_devel_kit</code>和<code>lua-nginx-module</code>两个编入到<code>nginx</code>中</p>

<h4 id="toc_4">make 和make install</h4>

<h4 id="toc_5">使用redis</h4>

<p>lua解析json格式的数据 <code>http://www.kyne.com.au/~mark/software/lua-cjson.php</code>（默认安装就行）</p>

<p>lua封装redis调用接口，<code>https://github.com/openresty/lua-resty-redis</code>，安装，(并且redis.lua上层目录要有resty，因为require “resty.redis”,看代码，负责会出现找不到库）</p>

<pre><code class="language-shell">lua_package_path &quot;/opt/vendor/lua/?.lua;;&quot;;//指定redis.lua路径，;;指定默认路径  加在http段里
 
init_by_lua_file /usr/local/nginx/html/init.lua;

lua_code_cache off;//避免lua代码缓存，更改代码执行失效  

location /lua {  
      content_by_lua_file /usr/local/nginx/html/content.lua;  
} 加在加入一个location
</code></pre>

<h4 id="toc_6">拦截请求保存相应的页面缓存</h4>

<pre><code class="language-shell">location ~ /(index\.html|(goods|event)/[0-9]+\.html|video/list\.html|channel/class\.html)? {
    content_by_lua_file /app/nginx/conf/content.lua;
}     
</code></pre>

<p>加在加入一个location，拦截相应的请求，保存页面到redis缓存</p>

<h4 id="toc_7">缓存的更新与删除</h4>

<p>新增定时项目，定时循环页面缓存redis的Key值，根据key值访问相应接口，返回的结果值MD5之后保存到redis的不用区。</p>

<p>添加定时任务定时扫描保存MD5缓存的key，分页面进行操作，比较接口返回结果的MD5值和redis缓存是否一致，不一致删除相应的redis页面缓存，对于商品的特别处理，商品下市删除相应的redisMD5缓存和redis页面缓存。</p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Java中的Object对象]]></title>
        <link href="http://nathanchen.github.io/14606396114001.html"/>
        <updated>2016-04-14T21:13:31+08:00</updated>
        <id>http://nathanchen.github.io/14606396114001.html</id>
        <content type="html"><![CDATA[
<blockquote>
<p>Java把现实中的任何事物都当做一个对象（Object），Java是面向对象的，就是Object-Oriented简称OO</p>

<p>Object在Java中被定义为一个顶级父类，它是任何类的父类，我们可以显示的继承它，也可以隐式继承</p>
</blockquote>

<h3 id="toc_0">Object类中定义的常用方法</h3>

<h4 id="toc_1"><code>equals(Object obj)</code></h4>

<p><code>equals()</code>方法与<code>==</code>的区别：</p>

<p><img src="media/14606396114001/14606397602166.jpg" alt=""/></p>

<p><code>==</code>比较的是两个引用的值，即两个对象的地址。两次创建的对象是相互对立的，都各自分配了独立的内存空间，所有<code>str1 != str2</code></p>

<p><code>equals()</code>比较的是两个引用指向的对象的实际的值，涉及到对象的属性和方法。上例中两个对象的值都为<code>Hello</code>，所以<code>str1.equals(str2)</code></p>

<p><img src="media/14606396114001/14606398204425.jpg" alt=""/></p>

<p>由于<strong>Java中String类型是不可变的</strong>，也就是说在创建了一个字符串之后，<strong>如果想修改这个字符串的值是不能直接在原来的内存中修改存储的，而是需要重新分配一个内存空间用来存放新的内存空间</strong>。</p>

<p>String类的这种特性造成在对String对象进行创建或操作时非常浪费内存空间，为了解决这个问题，<strong>Java中引出一个字符串池的概念</strong>（a pool of String）。即：<strong>如果当前准备新创建的字符串对象的值在复用池中已经存在，那么就不在生成新的对象，而是复用池中已有的字符串对象，新建的字符串和原来同值的字符串内存地址是相同的</strong>。</p>

<p>注意的是，这种字符串池的机制只有采用<code>Object obj =&quot;Hello&quot;</code>方式（而非用<code>new</code>关键字）声明String对象的时候才有效。</p>

<h4 id="toc_2"><code>hashCode()</code></h4>

<p>Object类中定义了<code>hashCode()</code>方法决定了所有的对象都可以调用其hashCode()方法。</p>

<p>在HashMap的存储实现中，系统会根据对象的hashCode()值来决定每个元素的存储位置。</p>

<p>这个时候会有一个疑问，就是会不会出现两个对象的hashCode()值相同呢？</p>

<ul>
<li>对象相等则hashCode()一定相等；</li>
<li>hashCode()相等对象未必相等。</li>
</ul>

<p><code>hashCode()</code>存储机制中，<strong>不同的hashCode()值的对象会被分配到不同的“桶”里面</strong>，hashCode()值相同的对象会被放进同一个“桶”里面。<strong>在查询的过程中，一般是先遍历所有的桶再遍历桶里面的元素</strong>，所以为了能有一个高效的查询效果，我们应该尽可能的让所有的对象都被分配的自己独有的“桶”里面，这样才能最快的实现查询，要实现这样的要求就需要这些对象的hashCode()值不相同。</p>

<h4 id="toc_3"><code>hashCode()</code>、<code>equals()</code>和<code>==</code>三者的关系</h4>

<ul>
<li>如果是基本变量，没有<code>hashCode()</code>和<code>equals()</code>方法，基本变量的比较方式就只有<code>==</code>。因为他们不是对象，当然是可以通过Java中的包装类将他们转换成对象后还是可以调用<code>hashCode()</code>和<code>equals()()</code>方法。</li>
<li>如果是变量，由于<strong>在Java中所有变量定义都是一个指向实际存储的一个句柄（你可以理解为c++中的指针）</strong>，

<ul>
<li><strong><code>==</code>是比较句柄的地址（你可以理解为指针的存储地址），而不是句柄指向的实际内存中的内容</strong>，</li>
<li>如果要比较实际内存中的内容，那就要用<code>equals()</code>方法，</li>
<li>但是如果是我们自己定义的一个类，比较自定义类用<code>equals()</code>和<code>==</code>是一样的，都是比较句柄地址，<strong>因为自定义的类是继承于<code>Object</code>，而<code>Object</code>中的<code>equals()</code>就是用<code>==</code>来实现的</strong>，所以<strong>在自定义类的情况下重写equals()方法会是一个良好的习惯，否则失去了equals()方法存在的意义了</strong>。</li>
<li>那为什么我们用的String等等类型<code>equals()</code>是比较实际内容呢，是<strong>因为<code>String</code>等常用类已经重写了<code>Object</code>中的<code>equals()</code>方法，让<code>equals()</code>来比较实际内容</strong>。</li>
</ul></li>
<li><code>hashCode()</code>在一般的应用中我们不需要了解<code>hashCode()</code>的用法，但当我们用到<code>HashMap</code>，<code>hashset</code>等集合类时要注意下<code>hashCode()</code>。我们想通过一个<code>Object</code>的<code>key</code>来拿<code>HashMap</code>的<code>value</code>，<code>HashMap</code>的工作方法是，<strong>通过你传入的<code>Object</code>的<code>hashCode()</code>在内存中找地址，当找到这个地址后再通过<code>equals()()</code>方法来比较这个地址中的内容是否和你原来放进去的一样，一样就取出value</strong>。</li>
<li>所以这里要匹配2部分，<code>hashCode()</code>和<code>equals()</code>。但假如说我们<code>new</code>一个<code>Object</code>作为<code>key</code>去拿<code>value</code>是永远得不到结果的，因为每次<code>new</code>一个<code>Object</code>，这个<code>Object</code>的<code>hashCode()</code>是永远不同的，所以我们要重写<code>hashCode()</code>，你可以令你的<code>hashCode()</code>是<code>Object</code>中的一个恒量，这样永远可以通过你的<code>Object</code>的<code>hashCode()</code>来找到key的地址，然后你要重写你的<code>equals()</code>方法，使内存中的内容也相等</li>
</ul>

<p>首先，从语法角度，也就是从强制性的角度来说，<code>hashCode()</code>和<code>equals()</code>是两个独立的，互不隶属，互不依赖的方法，<code>equals()</code>成立与<code>hashCode()</code>相等这两个命题之间，谁也不是谁的充分条件或者必要条件。     </p>

<p>但是，从为了让我们的程序正常运行的角度，我们一定要（正确）重载<code>hashCode()</code>，使得<code>equals()</code>成立的时候，<code>hashCode()</code>相等，也就是</p>

<pre><code class="language-java">a.equals(b) -&gt; a.hashCode()==  b.hashCode()
</code></pre>

<p>总结一下，<code>equals()</code>是对象相等性比较，<code>hashCode()</code>是计算对象的散列值，当然他们的依据是对象的属性。</p>

<p>对于<code>equals()</code>，一般我们认为两个对象同类型并且所有属性相等的时候才是相等的，在类中必须改写<code>equals()</code>，因为<code>Object</code>类中的<code>equals()</code>只是判断两个引用变量是否引用同一对象，如果不是引用同一对象，即使两个对象的内容完全相同，也会返回false。当然，在类中改写这个<code>equals()</code>时，你也可以只对部分属性进行比较，只要这些属性相同就认为对象是相等的。</p>

<p>对于<code>hashCode()</code>，只要是用在和哈希运算有关的地方，和<code>equals()</code>一样，在你的类中也应该改写。当然如果两个对象是完全相同的，那么他们的`hashCode()当然也是一样的，但是象前面所述，规则可以由你自己来定义，因此两者之间并没有什么必然的联系。     </p>

<p>当然，大多数情况下我们还是根据所有的属性来计算<code>hashCode()</code>和进行相等性比较。</p>

<h3 id="toc_4">Reference</h3>

<p><a href="http://blog.chinaunix.net/uid-26981819-id-4462638.html">http://blog.chinaunix.net/uid-26981819-id-4462638.html</a><br/>
<a href="http://www.cnblogs.com/I-am-Betty/archive/2010/09/06/1819375.html">http://www.cnblogs.com/I-am-Betty/archive/2010/09/06/1819375.html</a></p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[深入Class文件结构]]></title>
        <link href="http://nathanchen.github.io/14606028630903.html"/>
        <updated>2016-04-14T11:01:03+08:00</updated>
        <id>http://nathanchen.github.io/14606028630903.html</id>
        <content type="html"><![CDATA[
<pre><code class="language-java">public class Message {
    public static void main(String[] args) {
        System.out.printf(&quot;junshan say:Hello Word!&quot;);
    }
}
</code></pre>

<p><img src="media/14606028630903/14606103819824.jpg" alt=""/><br/>
<img src="media/14606028630903/14606103954902.jpg" alt=""/></p>

<p>Oolong的语法结构中以“.”符号开头表示这是一个基本的属性项，它对应到Java中就是表示一个Java的基本概念，如一个类、一个方法、一个属性、一个对象或者一个接口等。</p>

<h3 id="toc_0">类相关的指令</h3>

<p><code>.source Message.java</code>表示这个代码的源文件是Message.java</p>

<p><code>.class public Message</code>表示这是一个类且公有的类名是Message</p>

<p><code>.super java/lang/Object</code>表示这个类的父类是Object</p>

<h3 id="toc_1">方法的定义</h3>

<p><code>.method public &lt;init&gt; ()V</code>表示这是一个公有方法，没有参数，返回值类型是<code>V</code>（也就是void），<code>&lt;init&gt;</code>表示是构造函数</p>

<p>下面的<code>.method public static main([Ljava/lang/String;)V</code>表示的是main方法，它的参数是一个String类型的数组，其中<code>[</code>表示的是数组，而<code>L</code>表示的是一个类形式而不是基本数据类型，凡是<code>L</code>表示的类后面都会以<code>;</code>结尾，表示这个类的结束。</p>

<h3 id="toc_2">常量池</h3>

<p>class文件中的常量池如下：</p>

<p><img src="media/14606028630903/14606994451956.jpg" alt=""/><br/>
<img src="media/14606028630903/14606994624362.jpg" alt=""/><br/>
<img src="media/14606028630903/14606994757711.jpg" alt=""/></p>

<p>每个常量都是由三个字节来描述的。</p>

<p>第一个字节表示这个常量是什么类型的常量，JVM定义了12种类型的常量，每个种类的常量都会对应一个数值。</p>

<p><img src="media/14606028630903/14606274800854.jpg" alt=""/></p>

<p><img src="media/14606028630903/14606274949725.jpg" alt=""/></p>

<p>这些常量通常都是相互引用的，是一个常量引用了另一个常量。</p>

<h4 id="toc_3">UTF8常量类型</h4>

<p>它可以存储多个字节长度的字符串值，如可以存储类名或者方法名等很长的一个字符串。</p>

<p>UTF8类型的常量由前两个字节来表示后面所存储的字符串的总字节数</p>

<p><code>01003c</code>其中的<code>3c</code>表示后面所跟的字节长度有60个。</p>

<p><img src="media/14606028630903/14606277381217.jpg" alt=""/></p>

<p>UTF8常量由三部分表示，包括这个常量是什么格式的，这个常量有多少个字节，后面就是这个常量实际的内容。</p>

<h4 id="toc_4">Fieldred、Methodref常量类型</h4>

<p>为了描述Class中的属性项和方法。</p>

<h5 id="toc_5"><code>0900100011</code> Fieldref类型常量</h5>

<p><img src="media/14606028630903/14606278315252.jpg" alt=""/></p>

<ul>
<li>前一个字节表示这个常量是Fieldref类型，所以是09</li>
<li>后面两个字节表示的是该Fieldref是哪个类中的Field，存储的值是第几个常量的位置</li>
<li>后面两个字节表示的是这个Fieldref常量的Name和Type，同样它也是指向NameAndType类型常量的索引</li>
</ul>

<h4 id="toc_6">Class常量类型</h4>

<p>Class常量表示的是该类的名称，它会指向另外一个UTF8类型的常量，该常量存储的是该类的具体名称</p>

<p><img src="media/14606028630903/14606280340103.jpg" alt=""/></p>

<p>07表示的是Class类型的常量，后面的两个字节表示的是19个常量，而第19个常量正是一个UTF8类型的常量，该常量存储的是<code>java/lang/Object</code>，也就是该类的名称。</p>

<h4 id="toc_7">NameAndType常量类型</h4>

<p>为了表示Methodref和Fieldref的名称和类型描述做进一步说明而存在的，名称通常又由UTF8常量类型来表示，而类型描述也由UTF8来表示，所以NameAndType类型是由一个字节的类型表示加上两个字节的UTF8的位置索引组成的。</p>

<p><img src="media/14606028630903/14606964946256.jpg" alt=""/></p>

<ul>
<li>0007指向的是第7个常量，表示的是这个Methodref或者Fieldref的名称</li>
<li>0008表示的是Methodref的返回类型或者Fieldref的参数类型</li>
</ul>

<h3 id="toc_8">类信息</h3>

<p>常量列表的后面就是关于这个类本身的信息描述了，如这个类的访问控制、名称和类型，以及是否有父类或者实现了某些接口等描述信息。</p>

<p><img src="media/14606028630903/14606999059828.jpg" alt=""/></p>

<p>由两个字节表示这个类的访问控制描述</p>

<p><img src="media/14606028630903/14606978176390.jpg" alt=""/></p>

<p>类访问控制的两个字节中实际上只使用了5个bit，其他的bit还没有定义，这5个bit中第一个bit表示的是该类是否是public的，为1的话就是public类，否则就是private类。所以对类的访问修饰只有两种，要么是public要么是private。</p>

<p>第5个bit表示的是该类是否是final类，1表示是，0表示否。</p>

<p>第6个bit描述该类是否含有invokespecial，也就是是否继承其他类，在Java中所有的类默认都继承了Object类。</p>

<p>第10个bit描述了该类是否是接口类，0表示不是接口类，1是接口类。</p>

<p>第12个bit表示该类是否是抽象类，0表示不是抽象类，1表示是抽象类。</p>

<p>后面两个字节0006是该类的类名称，它指向的是第6个常量，0004表示的是该父类的类名称，它指向的是第4个常量定义的名称，再后面的0000表示该类没有实现接口类。</p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Thread Synchronization Utilities]]></title>
        <link href="http://nathanchen.github.io/14605288849994.html"/>
        <updated>2016-04-13T14:28:05+08:00</updated>
        <id>http://nathanchen.github.io/14605288849994.html</id>
        <content type="html"><![CDATA[
<p>We talk about synchronization when more than one concurrent task shares a resource.</p>

<p>The blocks of code that access this shared resource are called critical sections.</p>

<p>The high-level mechanisms are:</p>

<ul>
<li><strong>Semaphores</strong>: A semaphore is a counter that controls the access to one or more shared resources. </li>
<li><strong>CountDownLatch</strong>: The CountDowLatch class is a mechanism provided by the Java language that <strong>allows a thread to wait for the finalization of multiple operations</strong>.</li>
<li><strong>CyclicBarrier</strong>: The CyclicBarrier class is another mechanism provided by the Java language that <strong>allows the synchronization of multiple threads in a common point</strong>.</li>
<li><strong>Phaser</strong>: The Phaser class is another mechanism provided by the Java language that <strong>controls the execution of concurrent tasks divided in phases</strong>. All the threads must finish one phase before they can continue with the next one.</li>
<li><strong>Exchanger</strong>: The Exchanger class is another mechanism provided by the Java language that <strong>provides a point of data interchange between two threads</strong>.</li>
</ul>

<h3 id="toc_0">Controlling concurrent access to a resource</h3>

<p>A semaphore is a counter taht protects the access to one or more shared resources.</p>

<p>When a thread wants to access one of these shared resources, first, it must acquire that semaphore. If the internal counter of the semaphore is greater than 0, the semaphore decrements the counter and allows access to the shared resource. A counter bigger than 0 means there are free resources that can be used, so the thread can access and use one of them.</p>

<p>When the thread has finished the use of the shared resource, it must release the semaphore so that the other thread can access the shared resource. That operation increases the internal counter of the semaphore.</p>

<p>Binary semaphores protect the access to a unique shared resource, so the internal counter of the semaphore can only take the values of 1 or 0.</p>

<h4 id="toc_1">Fairness in semaphores</h4>

<p>The default mode is called the non-fair mode. In this mode, when the synchronization resources is released, one of the waiting threads is selected to get this resource, but it&#39;s selected without any criteria. The fair mode changes this behavior and forces to select the thread that has been waiting for more time.</p>

<p>The Semaphore class admits a second parameter in its constructor. This parameter must take a Boolean value. If you give it the false value, you are creating a semaphore that will work in non-fair mode. You will get the same behavior if you don&#39;t use this parameter.</p>

<h3 id="toc_2">Controlling concurrent access to multiple copies of a resource</h3>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Java序列化(Serializable)与反序列化]]></title>
        <link href="http://nathanchen.github.io/14603848361262.html"/>
        <updated>2016-04-11T22:27:16+08:00</updated>
        <id>http://nathanchen.github.io/14603848361262.html</id>
        <content type="html"><![CDATA[
<h3 id="toc_0">序列化是干什么的</h3>

<p>为了保存在内存中的各种对象的状态，并且可以把保存的对象状态再读出来。</p>

<h3 id="toc_1">序列化的几种方式</h3>

<p>在Java中socket传输数据时，比较常见的做法有两种：</p>

<ul>
<li>把对象包装成JSON字符串传输</li>
<li>采用Java对象的序列换与反序列化</li>
</ul>

<h4 id="toc_2">Object Serialize</h4>

<p>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>

<blockquote>
<p>当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象</p>
</blockquote>

<ul>
<li>把Java对象转换为字节序列的过程称为对象的序列化。</li>
<li>把字节序列恢复为Java对象的过程称为对象的反序列化。</li>
</ul>

<p>显示地定义serialVersionUID有两种用途：</p>

<ul>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本堆序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID</li>
<li>当你序列化了一个类实例后，希望更改一个字段或者添加一个字段，不设置serialVersionUID，所做的任何更改都将导致无法反序列化旧的实例，并在反序列化时抛出一个异常。如果你添加了serialVersionUID，在反序列旧的实例时，新添加或者更改的字段值将设为初始化值，字段被删除将不设置。</li>
</ul>

<h3 id="toc_3">Reference</h3>

<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651477035&amp;idx=1&amp;sn=617ab67ba4b3fa398ff0a8163eb0b7ac&amp;scene=23&amp;srcid=0411oESGwr6kfzJoeyPUPRWD#rd">http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651477035&amp;idx=1&amp;sn=617ab67ba4b3fa398ff0a8163eb0b7ac&amp;scene=23&amp;srcid=0411oESGwr6kfzJoeyPUPRWD#rd</a></p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Java基础之集合]]></title>
        <link href="http://nathanchen.github.io/14603378680590.html"/>
        <updated>2016-04-11T09:24:28+08:00</updated>
        <id>http://nathanchen.github.io/14603378680590.html</id>
        <content type="html"><![CDATA[
<p><img src="media/14603378680590/14603379082138.jpg" alt=""/></p>

<h3 id="toc_0">一、HashSet</h3>

<p><code>HashSet</code>实现<code>Set</code>接口。<code>HashSet</code>中不允许有重复元素，这是因为<code>HashSet</code>是基于<code>HashMap</code>实现的，<code>HashSet</code>中的元素都存放在<code>HashMap</code>的<code>key</code>上面，而<code>value</code>中的值都是统一的一个<code>private static final Object PRESENT = new Object();</code>。<code>HashSet</code>跟 <code>HashMap</code>一样，都是一个存放链表的数组。具体看下<code>HashSet</code>怎样实现不允许有重复元素的。</p>

<pre><code class="language-java">/*
* @param e 将添加到此set中的元素。
* @return 如果此set尚未包含指定元素，则返回true。
*/
public boolean add(E e)
{
    return map.put(e, PRESENT)==null;
}
</code></pre>

<p>如果此<code>set</code>中尚未包含指定元素，则添加指定元素。更确切地讲，如果此<code>set</code>没有包含满足<code>(e == null ? e2 == null : e.equals(e2))</code>的元素<code>e2</code>，则向此<code>set</code>添加指定的元素<code>e</code>。</p>

<p>如果此<code>set</code>已包含该元素，则该调用不更改<code>set</code>并返回<code>false</code>。底层实际将将该元素作为<code>key</code>放入<code>HashMap</code>。由于<code>HashMap</code>的<code>put()</code>方法添加<code>key-value</code>对时，当新放入<code>HashMap</code>的<code>Entry</code>中<code>key</code>与集合中原有<code>Entry</code>的<code>key</code>相同（<code>hashCode()</code>返回值相等，通过<code>equals</code>比较也返回<code>true</code>），新添加的<code>Entry</code>的<code>value</code>会将覆盖原来<code>Entry</code>的<code>value</code>，但 <code>key</code>不会有任何改变，因此如果向<code>HashSet</code>中添加一个已经存在的元素时，新添加的集合元素将不会被入<code>HashMap</code>中，原来的元素也不会有任何改变，这也就满足了<code>Set</code>中元素不重复的特性。</p>

<p>总结：不允许重复元素的本质是：当插入元素存在时，表面上看起来<code>HashSet</code>返回的是<code>false</code>，实际上执行的操作是原值被相同的值再覆盖一遍。</p>

<h3 id="toc_1">二、ArrayList</h3>

<p><code>ArrayList</code> 继承了<code>AbstractList</code> ，实现了<code>List</code> 。它是一个数组队列，相当于动态数组，提供了相关的添加、删除、修改、遍历等功能。</p>

<p>每个<code>ArrayList</code> 实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向<code>ArrayList</code> 中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造<code>ArrayList</code> 时指定其容量。在添加大量元素前，应用程序也可以使用 <code>ensureCapacity</code> 操作来增加<code>ArrayList</code>实例的容量，这可以减少递增式再分配的数量。</p>

<p>注意，此实现不是同步的。如果多个线程同时访问一个<code>ArrayList</code> 实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。</p>

<h4 id="toc_2">1、<code>ArrayList</code>构造方法</h4>

<p><code>ArrayList</code> 提供了三种方式的构造器，可以构造一个默认初始容量为 10 的空列表、构造一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。源码如下：</p>

<pre><code class="language-java">public ArrayList()
{
    this(10);
}

public ArrayList(int initialCapacity)
{
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity);
    this.elementData = new Object[initialCapacity];
}

public ArrayList(Collection c)
{
    elementData = c.toArray();
    size = elementData.length;
    // c.toArray might (incorrectly) not return Object[] (see 6260652)
    if (elementData.getClass() != Object[].class)
        elementData = Arrays.copyOf(elementData, size, Object[].class);
}
</code></pre>

<h4 id="toc_3">2、ArrayList 提供的各类方法</h4>

<h5 id="toc_4">a、存储:</h5>

<p>set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)</p>

<h5 id="toc_5">b、读取：</h5>

<p>get(int index)</p>

<h5 id="toc_6">c、删除：</h5>

<p>remove(int index)、remove(Object o)【附：remove(Object o)方法移除此列表中首次出现的指定元素（如果存在），这是应为ArrayList中允许存放重复的元素】</p>

<p>注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。</p>

<h5 id="toc_7">d、调整数组容量：</h5>

<p>每当向数组中添加元素时，都会去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组<br/>
扩容通过一个公开的方法 ensureCapacity(int minCapacity) 来实现。在实际添加大量元素前，也可以使用 ensureCapacity 来手动增加 ArrayList 实例的容量，以减少递增式再分配的数量。</p>

<pre><code class="language-java">public void ensureCapacity(int minCapacity)
{
    modCount++;
    int oldCapacity = elementData.length;
    if (minCapacity &gt; oldCapacity)
    {
        Object oldData[] = elementData;
        int newCapacity = (oldCapacity * 3)/2 + 1;
        if (newCapacity &lt; minCapacity)
        newCapacity = minCapacity;
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
}
</code></pre>

<p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的 1.5 倍。这种操作的代价是很高的。因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造 ArrayList 实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用 ensureCapacity 方法来手动增加 ArrayList 实例的容量。</p>

<p>ArrayList 还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过 trimToSize 方法来实现。</p>

<h4 id="toc_8">3、Fail-Fast机制：</h4>

<p>ArrayList 也采用了快速失败的机制，通过<strong>记录 modCount 参数</strong>来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>

<blockquote>
<p>Fail-Fast机制： “快速失败” 也就是 fail-fast，它是 Java 集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。记住是有可能，而不是一定。例如：<strong>假设存在两个线程（线程 1、线程 2 ），线程1通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制</strong>。】</p>
</blockquote>

<h3 id="toc_9">三、Linkedlist</h3>

<p>List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。 此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。 所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。</p>

<pre><code class="language-java">private transient Entry header = new Entry(null, null, null);
</code></pre>

<p>这个成员变量是LinkedList的关键，它在链表中没有实际数据意义，是链表的标示（通俗一点就是链表的第一个无意义的元素），而且被修饰为 transient，标示着他不会被序列化。header也可以当做队列末尾的元素，因为是双向列表，所以header.next末尾元素后边的元素就成了队首元素，header.previous就是队尾元素了，看一下它的添加方法</p>

<pre><code class="language-java">public void addFirst(E paramE)
{
    addBefore(paramE, this.header.next);//队首
}

public void addLast(E paramE)
{
    addBefore(paramE, this.header);//队尾
}
</code></pre>

<p>以上两个方法都利用 addBefore 方法将元素添加到指定对象之前，</p>

<p>addFirst 向队头加元素，将元素paramE添加到header.next-队首元素之前；</p>

<p>addLast 向队尾加元素，将元素paramE添加到header之前。</p>

<p>链表的基本特性是插入速度快，遍历速度慢。</p>

<p>LinkedList 的方法 entry(int index) 类似 ArrayList 的 get(int index)，源码如下：</p>

<pre><code class="language-java">/***
* 根据序号获取Entry对象
*/
private Entry entry(int paramInt)
{
    if ((paramInt &lt; 0) || (paramInt &gt;= this.size))
    {
        throw new IndexOutOfBoundsException(&quot;Index: &quot; + paramInt + &quot;, Size: &quot; + this.size);
    }
    Entry localEntry = this.header;
    int i;
    /***
    * 二分法：目标序号小于Size的1/2，则从头到尾
    * 如果大于Size的1/2，则从尾到头
    */
    if (paramInt &lt; this.size &gt;&gt; 1)
    {
        for (i = 0; i &lt;= paramInt; i++)
            localEntry = localEntry.next;
    }
    else
    {
        for (i = this.size; i &gt; paramInt; i--)
            localEntry = localEntry.previous;
    }
    return localEntry;
}
</code></pre>

<h3 id="toc_10">四、 ArrayList 和 LinkedList 的区别</h3>

<p>一般大家都知道 ArrayList 和 LinkedList 的大致区别：</p>

<p>1、ArrayList 是实现了基于动态数组的数据结构， LinkedList 基于链表的数据结构。</p>

<p>2、对于随机访问 get 和 set， ArrayList 觉得优于 LinkedList，因为 LinkedList 要移动指针。</p>

<p>3、对于新增和删除操作 add 和 remove， LinedList 比较占优势，因为 ArrayList 要移动数据。</p>

<p>ArrayList 和 LinkedList 在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下：</p>

<p>1、对 ArrayList 和 LinkedList 而言，在列表末尾增加一个元素所花的开销都是固定的。对 ArrayList 而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对 LinkedList 而言，这个开销是统一的，分配一个内部 Entry 对象。</p>

<p>2、在 ArrayList 的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在 LinkedList 的中间插入或删除一个元素的开销是固定的。</p>

<p>3、LinkedList 不支持高效的随机元素访问。</p>

<p>4、ArrayList 的空间浪费主要体现在在 list 列表的结尾预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗相当的空间。可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间，并且需要随机地访问其中的元素时,使用 ArrayList 会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用 LinkedList 了。</p>

<h3 id="toc_11">五、非同步性（非线程安全）</h3>

<p><strong>HashMap、Hashset、ArrayList、LinkedList 都是非同步性的</strong>，以 LinkedList 如果多个线程同时访问一个链接列表，而其中至少一个线程从结构上修改了该列表，则它必须保持外部同步。（结构修改指添加或删除一个或多个元素的任何操作；仅设置元素的值不是结构修改。）这一般通过对自然封装该列表的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedList 方法来“包装”该列表。最好在创建时完成这一操作，以防止对列表进行意外的不同步访问，如下所示：</p>

<pre><code class="language-java">List list = Collections.synchronizedList(new LinkedList(...));
</code></pre>

<p>同理，Map 有 Collections.synchronizedMap(Map m) 这个方法可以实现同步。</p>

<p>或者使用synchronized关键字</p>

<h3 id="toc_12">Reference</h3>

<p><a href="http://www.cnblogs.com/xwdreamer/archive/2012/06/03/2532999.html">http://www.cnblogs.com/xwdreamer/archive/2012/06/03/2532999.html</a></p>

<p><a href="http://zhangshixi.iteye.com/blog/674856">http://zhangshixi.iteye.com/blog/674856</a></p>

<p><a href="http://tan4836128.iteye.com/blog/1717809">http://tan4836128.iteye.com/blog/1717809</a></p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Critical rendering path]]></title>
        <link href="http://nathanchen.github.io/14602952169896.html"/>
        <updated>2016-04-10T21:33:36+08:00</updated>
        <id>http://nathanchen.github.io/14602952169896.html</id>
        <content type="html"><![CDATA[
<blockquote>
<p>Bytes -&gt; Characters -&gt; Tokens -&gt; nodes -&gt; Object Model<br/>
HTML markup is transformed into a Document Object Model (DOM), CSS markup is transformed into a CSS Object Model (CSSOM)<br/>
DOM and CSSOM are independent data structures</p>
</blockquote>

<h3 id="toc_0">Document Object Model (DOM)</h3>

<p><img src="media/14602952169896/14602975561490.jpg" alt=""/></p>

<h3 id="toc_1">CSS Object Model (CSSOM)</h3>

<p>While the browser was construncting the DOM of our simple page, it encoutered a link tag in the head section of the document referencing an external CSS stylesheet: style.css. Anticipating that it will need this resource to render the page, it immediately dispatches a request for this resource.</p>

<p>Just as with HTML, we need to convert the received CSS rules into something that the browser can understand and work with.</p>

<p><img src="media/14602952169896/14602984916423.jpg" alt=""/></p>

<p>The first step is for the browser to combine the DOM and CSSOM into a &quot;render tree&quot; that captures all the visible DOM content on the page, plus all the CSSOM style information for each node.</p>

<p><img src="media/14602952169896/14602985739859.jpg" alt=""/></p>

<p>To construct the render tree, the browser roughly does the following:</p>

<ul>
<li>Starting at the root of the DOM tree, traverse each visible node.

<ul>
<li>Some nodes are not visible at all, and are omitted since they are not reflected in the rendered output</li>
<li>Some nodes are hidden via CSS and are also omitted from the render tree</li>
</ul></li>
<li>For each visible node find the appropriate matching CSSOM rules and apply them</li>
<li>Emit visible nodes with content and their computed styles.</li>
</ul>

<blockquote>
<p>&#39;visibility: hidden&#39; is different from &#39;display: none&#39;<br/>
&#39;visibility: hidden&#39; makes the element invisible, but the element still occupies space in the layout<br/>
&#39;display: none&#39; removes the element entirely from the render tree such that the element is invisible and is not part of layout</p>
</blockquote>

<hr/>

<blockquote>
<p>By default, CSS is treated as a render blocking resource<br/>
Media types and media queries allow us to mark some CSS resources as non-render blocking<br/>
All CSS resources, regardless of blocking or non-blocking behavior, are downloaded by the browser</p>
</blockquote>

<pre><code class="language-html">&lt;link href=&quot;style.css&quot;    rel=&quot;stylesheet&quot;&gt;
&lt;link href=&quot;style.css&quot;    rel=&quot;stylesheet&quot; media=&quot;all&quot;&gt;
&lt;link href=&quot;portrait.css&quot; rel=&quot;stylesheet&quot; media=&quot;orientation:portrait&quot;&gt;
&lt;link href=&quot;print.css&quot;    rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;
</code></pre>

<ul>
<li>The first declaration is render blocking and matches in all conditions.</li>
<li>The second declaration is also render blocking: “all” is the default type and if you don’t specify any type, it’s implicitly set to “all”. Hence, the first and second declarations are actually equivalent.</li>
<li>The third declaration has a dynamic media query which will be evaluated when the page is being loaded. Depending on the orientation of the device when the page is being loaded, portrait.css may or may not be render blocking.</li>
<li>The last declaration is only applied when the page is being printed, hence it is not render blocking when the page is first loaded in the browser.</li>
</ul>

<h3 id="toc_2">Adding interactivity with JavaScript</h3>

<p>First, our script is executed at the exact point where it is inserted in the document. When the HTML parser encounters a script tag, it pauses its process of constructing the DOM and yields control over to the JavaScript engine; once the JavaScript engine has finished running, the browser then picks up from where it left off and resumes the DOM construction.</p>

<p>In other words, our script block can&#39;t find any elements later in the page because they haven&#39;t been processed yet.</p>

<blockquote>
<p>Or, executing our inline script blocks DOM construction, which will also delay the initial render.</p>
</blockquote>

<p>JavaScript execution can lead to significant delays in how quickly the browser can process and render our page on the screen:</p>

<ul>
<li>The location of the script in the document is significant</li>
<li>DOM constrction is paused when a script tag is encountered and until the script has finished executing</li>
<li>JavaScirpt can query and modify the DOM and CSSOM</li>
<li>Javascript execution is delayed until the CSSOM is ready</li>
</ul>

<h4 id="toc_3">Parser Blocking vs. Asynchronous JavaScript</h4>

<p>By default, JavaScript execution is &#39;parser blocking&#39;: when the browser encounters a script in the document it must pause DOM construction, hand over the control to the JavaScript runtime and let the script execute before proceeding with DOM construction.</p>

<p>In the case of an external JavaScript file the browser will also have to pause and wait for the script to be fetched from disk, cache, or a remote server, which can add tens of thousands of milliseconds of delay to the critical rendering path.</p>

<p>Adding the async keyword to the script tag tells the browser that it should not block the DOM construction while it waits for the script to become available.</p>

<pre><code class="language-html">&lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;
</code></pre>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Optimizing content efficiency]]></title>
        <link href="http://nathanchen.github.io/14602794784491.html"/>
        <updated>2016-04-10T17:11:18+08:00</updated>
        <id>http://nathanchen.github.io/14602794784491.html</id>
        <content type="html"><![CDATA[
<h3 id="toc_0">Text compression with GZIP</h3>

<ul>
<li>GZIP performs best on text-based assets: CSS, Javascript, HTML</li>
<li>All modern browsers support GZIP compresion and will automatically request it</li>
<li>Your server needs to be configured to enable GZIP compression</li>
<li>Some CDNs require special care to ensure that GZIP is enabled</li>
</ul>

<blockquote>
<p>There are cases where GZIP can increase the size of the asset. Typically, this happens when the asset is very small and the overhead of the GZIP dictionary is higher than the comression saving.</p>
</blockquote>

<h3 id="toc_1">Validating cached responses with ETags</h3>

<p>First, the browser checks the local cache and finds the previous response, unfortunately it cannot use it as the response has now &quot;expired&quot;.</p>

<p>At this point it could simply dispatch a new request and fetch the new full response, but that&#39;s inefficient because if the resource has not changed then there is no reason to download the exact same bytes that are already in cache.</p>

<p>That&#39;s the problem that validation tokens, as specified in the ETag header, are designed to solve: the server generates and returns an arbitrary token which is typically a hash or some other fingerprint of the contents of the file. If the fingerprint is still the same then the resource has not changed and we can skip the download.</p>

<p>The client automatically provides the ETag token within the &quot;If-None-Match&quot; HTTP request header, the server checks the token against the current resource, and if it has not changed returns a &quot;304 Not Modified&quot; response which tells the browser that the response it has in cache has not changed and can be renewed for another 120 seconds.</p>

<h3 id="toc_2">Cache-Control</h3>

<p>The best request is a request that does not need to communication with the server: a local copy of the response allows us to eliminate all network latency and avoid data charges for the data transfer.</p>

<h5 id="toc_3">&quot;no-cache&quot; and &quot;no-store&quot;</h5>

<p>&quot;no-cache&quot;: If a proper validation token (ETag) is present, no-cache will incur a roundtrip to validate the cached response, but can eliminate the download if the resource has not changed.</p>

<p>&quot;no-store&quot;: It disallows the browser and all intermediate caches to store any version of the returned response. Everytime the user requests this asset, a request is sent to the server and a full response is downloaded each and every time.</p>

<h5 id="toc_4">&quot;private&quot; vs. &quot;public&quot;</h5>

<p>&quot;public&quot;: it can be cached, even if it has HTTP authentication associated with it, and even when the response status code isn&#39;t normally cacheable.</p>

<p>&quot;private&quot;: can be cached by user&#39;s browser, but not by a CDN</p>

<h5 id="toc_5">&quot;max-age&quot;</h5>

<p>specifies the maximum time in seconds that the fetched response is allowed to be reused for from the tiem of the request</p>

<pre><code>max-age=60 // response can be cached and reused for the next 60 seconds
</code></pre>

<h3 id="toc_6">Invalidating and updating cached response</h3>

<p>All HTTP requests made by the browser are first routed to the browser cache to check if there is a valid cached response that can be used to fulfill the request. If there is a match, the response is read from the cache and we eliminate both the network latency and the data costs incurred by the transfer.</p>

<p>We can change the URL of the resource and force the user to download the new response whenever its content changes.</p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Instruct search engines how your multi-device page is structured]]></title>
        <link href="http://nathanchen.github.io/14602722755915.html"/>
        <updated>2016-04-10T15:11:15+08:00</updated>
        <id>http://nathanchen.github.io/14602722755915.html</id>
        <content type="html"><![CDATA[
<h3 id="toc_0">Determine URL structure of your webpage</h3>

<h5 id="toc_1">Responsive Web Design</h5>

<p>serves the same HTML for one URL and uses CS media quries to determine how the content is rendered on the client side.</p>

<pre><code>Desktop and Mobile: http://www.example.com/
</code></pre>

<h5 id="toc_2">Separate mobile site</h5>

<p>redirects users to a different URL depending on the user-agent</p>

<pre><code>Desktop: http://www.example.com/
Mobile: http://m.example.com/
</code></pre>

<h5 id="toc_3">Dynamic serving</h5>

<p>serves different HTML for one URL depending on the user-agent</p>

<pre><code>Desktop and Mobile: http://www.example.com/
</code></pre>

<blockquote>
<p>The best approach we recommend is to use responsive web design</p>
</blockquote>

<h3 id="toc_4">Using <code>link[rel=canonical]</code> and <code>link[rel=alternate]</code> when serving from separate URLs</h3>

<p>Serving similar contents on a desktop version and a mobile version at different URLs may cause confusion for both users and sertch engines because it&#39;s not obvious for viewers that they are intended to be identical. You should indicate:</p>

<ul>
<li>Contents of those 2 URLs are identical</li>
<li>Which is mobile version</li>
<li>Which is desktop version</li>
</ul>

<p>This information can help search engines better index content and ensure users find what they&#39;re looking for in a format that works for their device.</p>

<h5 id="toc_5">Use <code>link[rel=alternate]</code> for desktop version</h5>

<p>On desktop page, indicate that there&#39;s a mobile version on a different URL by adding link tag with rel=&quot;alternate&quot; pointing to mobile version URL with href. By adding media attribute with value of &quot;only screen and (max-width: 640px)&quot; will help search engines understand that this is explicitly targeting small screens.</p>

<pre><code class="language-html">&lt;title&gt;...&lt;/title&gt;
&lt;link rel=&quot;alternate&quot; media=&quot;only screen and (max-width: 640px)&quot; href=&quot;http://m.example.com/&quot;&gt;
</code></pre>

<h5 id="toc_6">Use link[rel=canonical] for mobile version</h5>

<p>On mobile specific pages, indicate that there&#39;s a desktop version at a different URL by adding link tag with rel=&quot;canonical&quot; pointing to desktop version URL with href.</p>

<pre><code class="language-html">&lt;title&gt;...&lt;/title&gt;
&lt;link rel=&quot;canonical&quot; href=&quot;http://www.example.com/&quot;&gt;
</code></pre>

<h3 id="toc_7">Use Vary HTTP header for device oriented serving site</h3>

<p>By letting search engines know that the content varies depending on user agent, they can optimize search results for the user agent that is sending queries.</p>

<h5 id="toc_8">Use Vary HTTP header</h5>

<pre><code>HTTP/1.1 200 OK
Content-Type: text/html
Vary: User-Agent
Content-Length: 5710
</code></pre>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Basic Thread Synchronization]]></title>
        <link href="http://nathanchen.github.io/14600079867622.html"/>
        <updated>2016-04-07T13:46:26+08:00</updated>
        <id>http://nathanchen.github.io/14600079867622.html</id>
        <content type="html"><![CDATA[
<h3 id="toc_0">Introduction</h3>

<p>In a concurrent application, it is normal that multiple threads read or write the same data or have access to the same file or database connection.</p>

<p>The solution for these problems comes with the concept of critical section.</p>

<p>A critical section is a block of code that accesses a shared resource and can&#39;t be executed by more than one thread at the same time.</p>

<p>When a thread wants access to a critical section, it uses one of those synchronization mechanisms to <strong>find out if there is any other thread executing the critical section</strong>. Otherwise, the thread is suspended by the sunchronization mechanism until the thread that is executing the critical section ends it.</p>

<h3 id="toc_1">Synchronizing a method</h3>

<p>the use of the synchronized keyword to control the concurrent access to a method.</p>

<p>Only one execution thread will access one of the methods of an object declared with the synchronized keyword. If another thread tries to access any method declared with the synchronized keyword of the same object, it will suspended until the first thread finishes the execution of the method.</p>

<p>Static methods have a different behavior. Only one execution thread will access one of the static methods declared with the synchronized keyword, but another thread can access other non-static methods of an object of that class.</p>

<p>Two threads can access two different synchronized methods if one is static and the other one is not.</p>

<p>Only a thread can access the methods of an object that use the sychronized keyword in their declaration. If a thread(A) is executing a synchronized method and another thread(B) wants to execute other synchronized methods of the same object, it will be blocked until the thread(A) ends. But if threadB has access to different objects of the same class, none of them will be blocked.</p>

<p>The synchronized keyword penalizes the performance of the application, so you must only use it on methods that modify shared data in a concurrent environment. </p>

<p>If you have multiple threads calling a synchronized method, only one will execute them at a time while the others will be waiting. If the operation doesn&#39;t use the synchronized keyword, all the threads can execute the operation at the same time, reducing the total execution time.</p>

<p>If you know that a method will not be called by more than one thread, don&#39;t use the synchronized keyword.</p>

<p>We can <strong>use the synchronized keyword to protect the access to a block of code instead of an entire method</strong>. We should use the synchronized keyword in this way to protect the access to the shared data, leaving the rest of operations out of this block, obtaining a better performance of the application. <strong>The objective is to have the critical secion be as short as possible</strong>.</p>

<p>Normally, we will use the <code>this</code> keyword to reference the object that is executing the method.</p>

<pre><code class="language-java">synchronized (this) {
    // Java code
}
</code></pre>

<h3 id="toc_2">Arranging independent attributes in synchronized classes</h3>

<p>When you use the synchronized keyword to protect a block of code, you must pass an object reference as a parameter. Normally, you will use the this keyword to reference the object that executes the method, but you can use other object references. </p>

<p>For example, if you have two independent attributes in a class shared by multiple threads, you must synchronize the access toe each variable, but there is no problem if there is one thread accessing one of the attributes and another thread accessing the other at the same time.</p>

<h3 id="toc_3">Using conditions in synchronized code</h3>

<p>A classic problem in concurrent programming is the producer-consumer problem. We have a data buffer, one or more producers of data that save it in the buffer and one or more consumers of data that take it from the buffer.</p>

<p>As the buffer is a shared data structure, we have to control the access to it using a synchronization mechanism such as the synchronized keyword, but we have more limitations. A producer can&#39;t save data in the buffer if it&#39;s full and the consumer can&#39;t take data from the buffer if it&#39;s empty.</p>

<p>For these types of situations, Java provides the wait(), notify() and notifyAll() methods implemented in the Object class.</p>

<p><strong>When the thread calls the <code>wait()</code> method, the JVM puts the thread to sleep and release the obejct that controls the synchronized block of code that it&#39;s executing and allows the other threads to execute other blocks of synchronized code protected by that object.</strong> To wake up the thread, you must call the notify() or notifyAll() method inside a block of code protected by the same object.</p>

<h3 id="toc_4">Synchronizing a block of code with a Lock</h3>

<p>based on the Lock interface and classes that implement it (as ReentrantLock). This mechanism presents some advantages, which are as follows:</p>

<ul>
<li><strong>It allows the structuring of synchronized blocks in a more flexible way</strong>. With the synchronized keyword, you have to get and free the control over a synchronized block of code in a structured way. The Lock interfaces allow you to get more complex structures to implement your ciritical section.</li>
<li>The Lock interfaces provide additional functionalities over the synchronized keyword. One of the new functionalities is implemented by the tryLock() method. With the synchronized keyword, when a threadA tries to execute a synchronized block of code, if there is another threadB executing it, the threadA is suspended until the threadB finishes the execution of the synchronized block. <strong>With locks, you can execute the tryLock() method. This meothod returns a Boolean value indicating if there is another thread running the code protected by this lock</strong>.</li>
<li>The Lock interfaces allow a separation of read and write operations having multiple readers and only one modifier.</li>
<li>The Lock interfaces offer <strong>better performance</strong> than the synchronized keyword.</li>
</ul>

<p>When we want to implement a critical section using locks and guarantee that only one execution thread runs a block of code, we have to create a ReentrantLock object.</p>

<p>At the beginning of the critical section, we have to get the control of the lock using the lock() method. When a threadA calls this method, if no other thread has the control of the lock, the method gives the threadA the control of the lock and returns immediately to permit the execution of the critical secion to this thread.</p>

<p>Otherwise, if there is another thread B executing the critical section controlled by this lock, the lock() method puts the thread A to sleep until the thread B finishes the execution of the critical section.</p>

<p>At the end of the critical section, we have to use the unlock() method to free the control of the lock and allow the other threads to run this critical section. If you don&#39;t call the unlock() method at the end of the critical section, the other threads that are waiting for that block will be waiting forever, causing a deadlock situation. If you use try-catch blocks in you critical section, don&#39;t forget to put the sentence containing the unlock() method inside the finally section.</p>

<p>The Lock interface includes another method to get the control of the lock. It&#39;s the tryLock() method. The biggest difference with the lock() method is that this method, if the thread that uses it can&#39;t get the control of the Lock interface, returns immediately and doesn&#39;t put the thread to sleep.</p>

<h3 id="toc_5">Synchronizing data access with read/write locks</h3>

<p>ReentrantReadWriteLock has two locks, one for read operations and one for write operations. There can be more than one thread using read operations simultaneously, but only one thread can be using write operations. When a thread is doing a write operation, there can&#39;t be any thread doing read operations.</p>

<h3 id="toc_6">Modifying Lock fairness</h3>

<p>The constructor of the ReentrantLock and ReentrantReadWriteLock classes admits a boolean parameter named fair that allows you to control the behavior of both classes.</p>

<p>The false value is the default value and it&#39;s called the non-fair mode. When there are some threads waiting for a lock and the lock has to select one of them to get the access to the critial section, it selects one without any criteria.</p>

<p>The true value is called the fair mode. When there are some threads waiting for a lock and the lock has to select one to get access to a critical section, it selects the thread that has been waiting for the most time.</p>

<p>As the tryLock() method doesn&#39;t put the thread to sleep if the Lock interface is used, the fair attribute doesn&#39;t affect its funcionality.</p>

<p>While Thread 0 is running the first block of code protected by the lock, we have nine threads waiting to execute that block of code. When Thread 0 releases the lock, immediately, it requests the lock again, so we have 10 threads trying to get the lock. As the fair mode is enabled, the Lock interface will choose Thread 1, so it&#39;s the thread that has been waiting for more time for the lock.</p>

<h3 id="toc_7">Using multiple conditions in a Lock</h3>

<p>A lock may be associated with one or more conditions. <strong>The purpose of these conditions is to allow threads to have control of a lock and check whether a condition is true or not and, if it&#39;s false, be suspended until another thread wakes them up</strong>.</p>

<p>All the Condition objects are associated with a lock and created using the newCondition() method declared in the Lock interface. Before we can do any operation with a condition, you have to have the control of the lock associated with the condition, so the operations with conditions must by in a block of code that begins with a call to a lock() method of a Lock object and ends with an unlock() method of the same Lock object.</p>

<p>When a thread calls the await() method of a condition, it automatically frees the control of the lock, so that another thread can get it and begin the execution of the same, or another critical section protected by that lock.</p>

<p>When a thread calls the singal() or signalAll() methods of a condition, one or all of the theads that were waiting for that condition are woken up, but this doesn&#39;t guarantee that the condition that made them sleep is now true, so you must put the await() calls inside a while loop. You can&#39;t leave that loop until the condition is true. While the condition is false, you must call await() again.</p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[AOP]]></title>
        <link href="http://nathanchen.github.io/14599989235671.html"/>
        <updated>2016-04-07T11:15:23+08:00</updated>
        <id>http://nathanchen.github.io/14599989235671.html</id>
        <content type="html"><![CDATA[
<blockquote>
<p>为某个对象提供一个代理，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。</p>
</blockquote>

<h3 id="toc_0">静态代理和动态代理</h3>

<ul>
<li><p>静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的<code>.class</code>文件就已经存在了   </p>

<ul>
<li>优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。</li>
<li>缺点：

<ul>
<li>一个代理类只能为一个接口服务</li>
<li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法</li>
</ul></li>
</ul></li>
</ul>

<blockquote>
<p>代理接口</p>
</blockquote>

<pre><code class="language-java">public interface Subject {
    public void dealTask(String taskName);
}
</code></pre>

<blockquote>
<p>真正执行任务的类</p>
</blockquote>

<pre><code class="language-java">public class RealSubject implements Subject {  
    @Override  
    public void dealTask(String taskName) {  
     System.out.println(&quot;正在执行任务：&quot;+taskName);  
     try {  
        Thread.sleep(500);  
     } catch (InterruptedException e) {  
        e.printStackTrace();  
     }  
    }  
}  
</code></pre>

<blockquote>
<p>代理类</p>
</blockquote>

<pre><code class="language-java">public class ProxySubject implements Subject {  
    //代理类持有一个委托类的对象引用  
    private Subject delegate;  
       
    public ProxySubject(Subject delegate) {  
        this.delegate = delegate;  
    }  
      
    /** 
    * 将请求分派给委托类执行，记录任务执行前后的时间，时间差即为任务的处理时间 
    *  
    * @param taskName 
    */  
    @Override  
    public void dealTask(String taskName) {  
        long stime = System.currentTimeMillis();   
        //将请求分派给委托类处理  
        delegate.dealTask(taskName);  
        long ftime = System.currentTimeMillis();   
        System.out.println(&quot;执行任务耗时&quot;+(ftime - stime)+&quot;毫秒&quot;);  
    }  
}  
</code></pre>

<blockquote>
<p>静态代理类工厂</p>
</blockquote>

<pre><code class="language-java">public class SubjectStaticFactory {  
    //客户类调用此工厂方法获得代理对象。  
    //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。  
    public static Subject getInstance(){   
        return new ProxySubject(new RealSubject());  
    }  
}  
</code></pre>

<blockquote>
<p>客户类</p>
</blockquote>

<pre><code class="language-java">public class Client1 {  
    public static void main(String[] args) {  
        Subject proxy = SubjectStaticFactory.getInstance();  
        proxy.dealTask(&quot;DBQueryTask&quot;);  
    }   
}
</code></pre>

<ul>
<li>动态代理：在程序运行时，运用反射机制动态创建而成

<ol>
<li><code>jdk</code>动态代理 只能代理实现接口的类，不能实现接口的类就不能实现<code>JDK</code>的动态代理</li>
<li><code>CGLib</code>动态代理</li>
</ol></li>
</ul>

<h3 id="toc_1">Spring AOP：前置增强、后置增强、环绕增强，抛出增强</h3>

<ul>
<li>前置增强类实现了<code>org.springframework.aop.MethodBeforeAdvice</code>接口</li>
<li>后置增强类实现了<code>org.springframework.aop.AfterReturningAdvice</code>接口</li>
<li>环绕增强类需要实现<code>org.aopalliance.intercept.MethodInterceptor</code>接口</li>
<li>抛出增强类需要实现<code>org.springframework.aop.ThrowsAdvice</code>接口</li>
</ul>

<p><img src="media/14599989235671/201604061031.png" alt="201604061031"/></p>

<ul>
<li>引入增强类，扩展了<code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>类</li>
</ul>

<p><img src="media/14599989235671/201604061035.png" alt="201604061035"/></p>

<p>以上定义了一个引入增强类，扩展了 <code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>类，同时也实现了新定义的<code>Apology</code>接口。在类中首先覆盖了父类的<code>invoke()</code>方法，然后实现了<code>Apology</code>接口的方法</p>

<p><img src="media/14599989235671/20160406103701.png" alt="20160406103701"/></p>

<p>需要注意<code>proxyTargetClass</code>属性，它表明是否代理目标类，默认为<code>false</code>，也就是代理接口了，此时<code>Spring</code>就用<code>JDK</code>动态代理。如果为<code>true</code>，那么<code>Spring</code>就用<code>CGLib</code>动态代理</p>

<p><img src="media/14599989235671/201604061038.png" alt="201604061038"/></p>

<p><code>saySorry()</code>方法是可以被<code>greetingImpl</code>对象来直接调用的，只需将其强制转换为该接口即可</p>

<h3 id="toc_2">Spring AOP ：切面</h3>

<p>通过切面，将增强类与拦截匹配条件组合在一起，然后将这个切面配置到<code>ProxyFactory</code>中，从而生成代理</p>

<p><code>Advisor</code>（切面）封装了<code>Advice</code>（增强）与<code>Pointcut</code>（切点 ）</p>

<p><img src="media/14599989235671/201604061048.png" alt="201604061048"/><br/>
<img src="media/14599989235671/201604061049.png" alt="201604061049"/></p>

<p>注意以上代理对象的配置中的<code>interceptorNames</code>，它不再是一个增强，而是一个切面，因为已经将增强封装到该切面中了。此外，切面还定义了一个切点（正则表达式），其目的是为了只将满足切点匹配条件的方法进行拦截。</p>

<p>需要强调的是，这里的切点表达式是基于正则表达式的。<br/>
示例中的<code>aop.demo.GreetingImpl.good.*</code>表达式后面的<code>.*</code>表示匹配所有字符，翻译过来就是“匹配 <code>aop.demo.GreetingImpl</code> 类中以 <code>good</code> 开头的方法”</p>

<p>除了<code>RegexpMethodPointcutAdvisor</code>以外，在<code>Spring AOP</code>中还提供了几个切面类，比如：</p>

<ul>
<li><p><code>DefaultPointcutAdvisor</code>：默认切面（可扩展它来自定义切面）</p></li>
<li><p><code>NameMatchMethodPointcutAdvisor</code>：根据方法名称进行匹配的切面</p></li>
<li><p><code>StaticMethodMatcherPointcutAdvisor</code>：用于匹配静态方法的切面</p></li>
</ul>

<h3 id="toc_3">Spring AOP：自动代理</h3>

<ul>
<li>扫描<code>Bean</code>名称</li>
</ul>

<p><img src="media/14599989235671/201604061054.png" alt="201604061054"/></p>

<p>以上使用<code>BeanNameAutoProxyCreator</code>只为后缀为<code>Impl</code>的<code>Bean</code>生成代理。</p>

<p>需要注意的是，这个地方我们不能定义代理接口，也就是<code>interfaces</code>属性，因为我们根本就不知道这些<code>Bean</code>到底实现了多少接口。此时不能代理接口，而只能代理类。</p>

<p>所以这里提供了一个新的配置项，它就是<code>optimize</code>。若为<code>true</code>时，则可对代理生成策略进行优化（默认是<code>false</code>的）。也就是说，如果该类有接口，就代理接口（使用<code>JDK</code>动态代理）；<br/>
如果没有接口，就代理类（使用<code>CGLib</code>动态代理）。而并非像之前使用的<code>proxyTargetClass</code>属性那样，强制代理类，而不考虑代理接口的方式。可见<code>Spring AOP</code>确实为我们提供了很多很好地服务</p>

<p><code>CGLib</code>创建代理的速度比较慢，但创建代理后运行的速度却非常快，而<code>JDK</code>动态代理正好相反。如果在运行的时候不断地用<code>CGLib</code>去创建代理，系统的性能会大打折扣，所以建议一般在系统初始化的时候用<code>CGLib</code>去创建代理，并放入<code>Spring</code>的<code>ApplicationContext</code>中以备后用。</p>

<ul>
<li>扫描切面配置</li>
</ul>

<p><img src="media/14599989235671/201604061057.png" alt="201604061057"/></p>

<p>这里无需再配置代理了，因为代理将会由<code>DefaultAdvisorAutoProxyCreator</code>自动生成。也就是说，这个类可以扫描所有的切面类，并为其自动生成代理。</p>

<h3 id="toc_4">Spring + AspectJ</h3>

<ul>
<li>基于注解：通过 AspectJ execution 表达式拦截方法</li>
</ul>

<p><img src="media/14599989235671/201604061103.png" alt="201604061103"/></p>

<p>类上面标注的<code>@Aspect</code>注解，这表明该类是一个<code>Aspect</code>（其实就是<code>Advisor</code>）。</p>

<p>该类无需实现任何的接口，只需定义一个方法（方法叫什么名字都无所谓），只需在方法上标注<code>@Around</code>注解，在注解中使用了<code>AspectJ</code>切点表达式。方法的参数中包括一个<code>ProceedingJoinPoint</code>对象，它在<code>AOP</code>中称为<code>Joinpoint</code>（连接点），可以通过该对象获取方法的任何信息</p>

<pre><code>execution(* aop.demo.GreetingImpl.*(..))

execution()：表示拦截方法，括号中可定义需要匹配的规则。

第一个“*”：表示方法的返回值是任意的。

第二个“*”：表示匹配该类中所有的方法。

(..)：表示方法的参数是任意的。 
</code></pre>

<p>配置<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></p>

<ul>
<li>基于注解：通过 AspectJ <code>@annotation</code> 表达式拦截方法
<img src="media/14599989235671/201604061109.png" alt="201604061109"/></li>
</ul>

<p><img src="media/14599989235671/201604061111.png" alt="201604061111"/></p>

<p>除了<code>@Around</code>注解外，其实还有几个相关的注解，稍微归纳一下吧：</p>

<pre><code>@Before：前置增强

@After：后置增强

@Around：环绕增强

@AfterThrowing：抛出增强

@DeclareParents：引入增强
</code></pre>

<p>除了使用<code>@Aspect</code>注解来定义切面类以外，<code>Spring AOP</code>也提供了基于配置的方式来定义切面类：</p>

<pre><code class="language-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans ...&quot;&gt;
    &lt;bean id=&quot;greetingImpl&quot; class=&quot;aop.demo.GreetingImpl&quot;/&gt;
    &lt;bean id=&quot;greetingAspect&quot; class=&quot;aop.demo.GreetingAspect&quot;/&gt;
    &lt;aop:config&gt;
        &lt;aop:aspect ref=&quot;greetingAspect&quot;&gt;
            &lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* aop.demo.GreetingImpl.*(..))&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
    &lt;/beans&gt;
</code></pre>

<p>使用<code>&lt;aop:config&gt;</code>元素来进行<code>AOP</code>配置，在其子元素中配置切面，包括增强类型、目标方法、切点等信息。</p>

<p><img src="media/14599989235671/201604061419.png" alt="201604061419"/></p>

<h3 id="toc_5">Reference</h3>

<p><a href="http://blog.csdn.net/giserstone/article/details/17199755">http://blog.csdn.net/giserstone/article/details/17199755</a></p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Thread Management]]></title>
        <link href="http://nathanchen.github.io/14599483001450.html"/>
        <updated>2016-04-06T21:11:40+08:00</updated>
        <id>http://nathanchen.github.io/14599483001450.html</id>
        <content type="html"><![CDATA[
<h3 id="toc_0">Introduction</h3>

<p>Inside a process, we can have various simultaneous tasks. The concurrent tasks that run inside a process are called threads.</p>

<p>We have two ways of creating a thread in Java:</p>

<ul>
<li>Extending the Thread class and overriding the run() method</li>
<li>Building a class that implements the Runnable interface and then creating an object of the Thread class passing the Runnable object as a parameter</li>
</ul>

<blockquote>
<p>Calculator</p>
</blockquote>

<pre><code class="language-java">public class Calculator implements Runnable
{
    private int number;

    public Calculator (int number)
    {
        this.number = number;
    }

    @Override
    public void run ()
    {
        for (int i = 1; i &lt;= 10; i ++)
        {
            System.out.printf(&quot;%s: %d * %d = %d \n&quot;, Thread.currentThread().getName(), number, i, i * number);
        }
    }
}
</code></pre>

<blockquote>
<p>Main</p>
</blockquote>

<pre><code class="language-java">public class Main
{
    public static void main (String[] args)
    {
        for (int i = 1; i &lt;= 10; i ++)
        {
            Calculator calculator = new Calculator(i);
            Thread thread = new Thread(calculator);
            thread.start();
        }
    }
}
</code></pre>

<p>Every Java program has at least on execution thread. When you run the program, the JVM runs this execution thread that calls the main() method of the program.</p>

<p>When you call the start() method of a Thread object, we are creating another execution thread.</p>

<p>A Java program ends when all its threads finish. If the initial thread ends, the rest of the threads will continue with their execution until they finish. If one of the threads use the System.exit() instruction to end the execution of the program, all the threads end their execution.</p>

<p>Creating an object of the Thread class doesn&#39;t create a new execution thread. Also, calling the run() method of a class that implements the Runnable interface doesn&#39;t create a new execution thread. Only calling the start() method creates a new execution thread.</p>

<h3 id="toc_1">Getting and setting thread information</h3>

<p>The Thread class saves some information attributes that can help us to identify a thread. These attributes are:</p>

<ul>
<li>ID: stores a unique identifier for each Thread</li>
<li>Name: stores the name of the Thread</li>
<li>Priority: stores the priority of the Thread object. Threads can have a priority between 1 and 10, where 1 is the lowest.</li>
<li>Status: stores the status of Thread. Thread can be in one of these six states: new, runnable, blocked, waiting, time waiting, or terminated.</li>
</ul>

<p>The threads with the highest priority end before the ones with the lowest priority. </p>

<h3 id="toc_2">Interrupting a thread</h3>

<p>A Java program with more than one execution thread only finishes when the execution of all of its threads end.</p>

<p>Java provides the interruption mechanism to indicate to a thread that we want to finish it. Thread has to check if it has been interrupted or not, and it can decide if it responds to the finalization request or not. Thread can ignore it adn continue with its execution.</p>

<p>The Thread class has an attribute that stores a boolean value indicating whether that thread has been interrupted or not. When you call the interrupt() method of a thread, you set that attribute to true. The isInterrupted() method only returns the value of that attribute.</p>

<p>You can throw InterruptedException when you detect the interruption of the thread and catch it in the run() method.</p>

<h3 id="toc_3">Sleeping and resuming a thread</h3>

<p>Sometimes, the thread does nothing. During this time, the thread doesn&#39;t use any resources of the computer. After this time, the thread will be ready to continue with its execution when the JVM chooses it to be executed. You can use the sleep() method of the Thread class for this purpose.</p>

<p>Another possibility is to use the sleep() method of an element of the TimeUnit enumeration. This method uses the sleep() method of the Thread classes to put the current thread to sleep, but it receives the parameter in the unit that it represents and converts it to milliseconds.</p>

<p>When you call the sleep() method, Thread leaves the CPU and stops its execution for a period of time. During this time, it&#39;s not consuming CPU time, so the CPU can be executing other tasks.</p>

<p>When Thread is sleeping and is interrupted, the method throws an InterruptedException immediately and doesn&#39;t wait until the sleeping time finishes.</p>

<h3 id="toc_4">Waiting for the finalization of a thread</h3>

<p>We may have a program that will begin initializing the resources it needs before proceeding with the rest of the execution. <strong>We can run the initializaion tasks as threads and wait for its finialization before continuing with the rest of the program.</strong></p>

<p>For this purpose, we can use the join() method of the Thread class. When we call this method using a thread object, it suspends the execution of the calling thread until the object called finishes its execution.</p>

<p>Instead of waiting indefinitely for the finalization of the thread called, the calling thread waits for the milliseconds specified as a parameter of the method.</p>

<pre><code class="language-java">join(long milliseconds)

join(long milliseconds, long nanos)
</code></pre>

<p>For example, if the object thread1 has the code, thread2.join(1000), the thread thread1 suspends its execution until one of these two conditions is true:</p>

<ul>
<li>thread2 finishes its execution</li>
<li>1000 milliseconds have been passed</li>
</ul>

<h3 id="toc_5">Creating and running a daemon thread</h3>

<p>Deamon thread: has very low priority and normally only executes when no other thread of the same program is running. When daemon threads are the only threads running in a program, the JVM ends the program finishing thses thread.</p>

<p>They can&#39;t do important jobs because we don&#39;t know when they are going to have CPU time and they can finish any time if there aren&#39;t any other threads running. A typical example of these kind of threads is the Java garbage collector.</p>

<p>You only can call the setDaemon() method before you call the start() method. Once the thread is running, you can&#39;t modify its daemon status.</p>

<h3 id="toc_6">Processing uncontrolled exceptions in a thread</h3>

<p><strong>When a checked exception is thrown</strong> inside the run() method of a Thread object, we have to catch and treat them, because the run() method doesn&#39;t accept a throws clause. </p>

<p><strong>When an unchecked exception is thrown</strong> inside the run() method of a Thread object, the default behavior is to write the stack trace in the console and exit the program.</p>

<p>When an exception is thrown in a thread and is not caught, the JVM checks if the thread has an uncaught execption handler set by the corresponding method. If it has, the JVM invokes this method with the Thread object and Exception as arguments.</p>

<p>If the thread has not got an uncaught exception handler, the JVM prints the statck trace in the console and exits the program.</p>

<h3 id="toc_7">Using local thread variables</h3>

<p>If you create an object of a class that implements the Runnable interface and then start various Thread objects using the same Runnable object, all the threads share the same attributes. This meanns that, if you change an attribute in a thread, all the threads will be affected by this change.</p>

<p>Thread-local variables: sometimes, you will be interested in having an attribute that won&#39;t be shared between all the threads that run the same object.</p>

<pre><code class="language-java">private static ThreadLocal&lt;Date&gt; startDate = new ThreadLocal&lt;Date&gt;() {
   protected Date initialValue() {
       return new Date();
   }
};
</code></pre>

<p>Thread-local variables store a value of an attribute for each Thread that uses one of these variables. You can read the value using the <code>get()</code> method and changes the value using the <code>set()</code> method. <strong>The first time you access</strong> the value of a thread-local variable, if it has no value for the Thread object that it is calling, <strong>the thread-local variable calls the <code>initialValue()</code> method</strong> to assign a value for that Thread and returns the inital value.</p>

<p>The thread-local class provides the <code>remove()</code> method that deletes the value stored in the thread-local variable for the thread that it&#39;s calling.</p>

<p>If a thread A has a value in a thread-local variable and it creates another thread B, the thread B will have the same value as the thread A in the thread-local varaible. You can override the <code>childValue()</code> method that is called to initalize the value of the child thread in the thread-local variable.</p>

<h3 id="toc_8">Grouping threads into a group</h3>

<p>threat the threads of a group as a single unit and provides access to the Thread objects that belong to a group to do an operation with them.</p>

<p>For example, you have some threads doing the same task and you want to control them, irrespective of how many threads are still running, the status of each one will interrupt all of them with a single call.</p>

<p>Java provides the ThreadGroup class to work with groups of threads. A ThreadGroup object can be formed by Thread objects and by another ThreadGroup object, generating a tree structure of threads.</p>

<h3 id="toc_9">Processing uncontrolled exceptions in a group of threads</h3>

<p>Java implements an exception-based mechanism to manage error situations. Those exceptions are thrown by the Java classes when an error situation is detected.</p>

<p>Java also provides a mechanism to capture and process those exceptions. There are exceptions that must be captured or re-thrown using the throws clause of a method. These exceptions are called checked exceptions. Those not are unchecked exceptions.</p>

<p>When an uncaught exception is thrown in Thread, the JVM looks for three possible handlers for this exception.</p>

<ul>
<li>it looks for the uncaught exception handler of the thread</li>
<li>If this handler doesn&#39;t exist, then the JVM looks for the uncaught exception handler for the ThreadGroup class of the thread</li>
<li>If this method doesn&#39;t exist, the JVM looks for the default uncaught exception handler</li>
</ul>

<h3 id="toc_10">Creating threads through a factory</h3>

<p>With this factory, we centralize the creation of objects with some advantages:</p>

<ul>
<li>It&#39;s easy to change the class of the objects created or the way we create these objects</li>
<li>It&#39;s easy to limit the creation of objects for limited resources. For example, we can only have n objects of a type</li>
<li>It&#39;s easy to generate statistical data about the creation of the objets</li>
</ul>

<p>Java provides an interface, the ThreadFactory interfaces to implement a Thread object factory.</p>

<p>The ThreadFactory interface has only one methods called newThread. Most basic ThreadFactory has only one line:</p>

<pre><code>return new Thread(r);
</code></pre>

<p>You can improve this implementation by adding some variants by:</p>

<ul>
<li>Creating personalized threads, using a special format for the name or even creating our own thread class that inherits the Java Thread class</li>
<li>Saving thread creation statistics</li>
<li>Limiting the number of threads created</li>
<li>Validating the creation of the threads</li>
<li>...<br/></li>
</ul>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Javac编译原理]]></title>
        <link href="http://nathanchen.github.io/14599206151015.html"/>
        <updated>2016-04-06T13:30:15+08:00</updated>
        <id>http://nathanchen.github.io/14599206151015.html</id>
        <content type="html"><![CDATA[
<h3 id="toc_0">如何才能编译程序呢？</h3>

<ul>
<li>首先，要读取源代码，一个字节一个字节地读进来，找出这些字节中哪些是我们定义的语法关键词。

<ul>
<li>词法分析的结果就是从源码中找到一些规范化的Token流，就像人类语言中，给你一句话，你要能分辨出哪些是一个词语，哪些是标点符号</li>
</ul></li>
<li>接着，就是对这些Token流进行语法分析，检查这些关键词组合在一起是不是符合Java语言规范

<ul>
<li>语法分析的结果就是形成一个符合Java语言规范的抽象语法树</li>
</ul></li>
<li>接下来是语义分析，判断语义是不是正确。主要工作是把一些难懂的、复杂的语法转化成更加简单的语法。</li>
<li>最后，通过字节码生成器生成字节码，将会根据经过注解的抽象语法树生成字节码，就像将所有的中文词语翻译成英文单词后，按照英文语法组装成英文语句。</li>
</ul>

<p><img src="media/14599206151015/14605338857066.jpg" alt=""/></p>

<h3 id="toc_1">Javac工作原理分析</h3>

<h4 id="toc_2">词法分析器</h4>

<pre><code class="language-java">public class Cifa {
    int a;
    int c = a + 1;
}
</code></pre>

<p>Javac的主要词法分析器的默认实现类是com.sun.tools.javac.parser.Scanner，<strong>Scanner会逐个读取Java源文件的单个字符，然后解析出符合Java语言规范的Token序列</strong>。</p>

<p><strong>JavacParser规定了哪些词是符合Java语言规范规定的词</strong>；<strong>具体读取和归类不同语法的操作由Scanner完成</strong>。Token规定了所有Java语言的合法关键词，Names用来存储和表示解析后的词法。</p>

<p>词法分析过程是在JavaParser的parseCompilationUnit方法中完成的。</p>

<p>从源文件的第一个字符开始，按照Java语法规范依次找出package、import、类定义，以及属性和方法定义等，最后构建一个抽象语法树。</p>

<p>词法分析器的分析结果就是将这个类中的所有关键词匹配到Token类的所有项中的任何一项。</p>

<p><img src="media/14599206151015/14605340792770.jpg" alt=""/></p>

<h4 id="toc_3">语法分析器</h4>

<p>词法分析器的作用就是将Java源文件的字符流转变成对应的Token流。而词法分析器是将词法分析器分析的Token流组建成更加结构化的语法树，也就是将一个个单词组装成一句话，一个完整的语句。哪些词语组合在一起是主语、哪些是谓语，要做进一步区分。</p>

<p>Javac的语法树使得Java源码更加结构化，这种结构化可以为后面的进一步处理提供方便。每个语法树上的节点都是<code>com.sun.tools.javac.tree.JCTree</code>的一个实例</p>

<p>JCTree类中有如下三个重要的属性项：</p>

<ul>
<li>Tree tag: 每个语法节点都会用一个整形常数表示，并且每个节点类型的数值是在前一个的基础上加1。顶层节点TOPLEVEL是1，而IMPORT节点等于TOPLEVEL加1，等于2</li>
<li>pos：也是一个整数，它存储的是这个语法节点在源代码中的起始位置，一个文件的一个位置是0，而-1表示一个不存在的位置</li>
<li>type：表示的是这个节点是什么Java类型，如int、float等</li>
</ul>

<p>下面以Yufa类为例，看看它的最后的语法树是什么：</p>

<pre><code class="language-java">public class Yufa {
    int a;
    private int c = a + 1;
    
    public int getC() {
        return c;
    }
    
    public void setC(int c) {
        this.c = c;
    }
}
</code></pre>

<blockquote>
<p>这段代码对应的语法树是</p>
</blockquote>

<p><img src="media/14599206151015/14605353774400.jpg" alt=""/></p>

<h4 id="toc_4">语义分析器</h4>

<p>前面介绍了将一个Java源文件先解析成一个一个的Token流，然后再经过语法分析器将Token流解析成更加结构化、可操作的一颗语法树。</p>

<h5 id="toc_5">将Java类中的符号输入到符号表中</h5>

<p>主要由<code>com.sun.tools.javac.comp.Enter</code>类完成，这个类主要完成以下两个步骤。</p>

<ul>
<li>将所有类中出现的符号输入到类本身的符号表中，所有类符号、类的参数类型符号（泛型参数类型）、超类符号和继承的接口类型符号等都存储到一个未处理列表中</li>
<li>将这个未处理列表中所有的类都解析到各自的类符号列表中</li>
</ul>

<p>首先一个类中处理类本身会定义一些符号变量外，如类名称、变量名称和方法名称等，还有一些符号是引用其他类的，符号调用其他类的方法或者变量等，还有一些这个类可能会继承或者实现超类和接口等。这些符号都是在其他类中定义的。</p>

<p>第二个步骤就是按照递归向下的顺序解析语法树，将所有的符号都输入符号表中。</p>

<p>在Enter类解析这一步骤中，还有一个重要的步骤是添加默认的构造函数。</p>

<h5 id="toc_6">处理annotation</h5>

<p>这个步骤是由<code>com.sun.tools.javac.processing.JavaProcessingEnvironment</code>类完成的。</p>

<h5 id="toc_7">标注</h5>

<p>这个步骤最重要的是检查语义的合法性和进行逻辑判断，如：</p>

<ul>
<li>变量的类型是否匹配</li>
<li>变量在使用前是否已经初始化</li>
<li>能够推导出泛型方法的参数类型</li>
<li>字符串常量的合并</li>
</ul>

<p>还有一些类来协助</p>

<ul>
<li>检查语法树中的变量类型是否正确，如方法返回的类型是否与接收的引用值类型匹配</li>
<li>检查变量、方法或者类的访问是否合法、变量是否是静态变量、变量是否已经初始化</li>
<li>常量折叠，这里主要针对字符串常量，会将一个字符串常量中的多个字符串合并成一个字符串</li>
<li>帮助推导泛型方法的参数类型等</li>
</ul>

<pre><code class="language-java">public class Yufa {
    int a = 0;
    private int c = a + 1;
    private int d = 1 + 1;
    private String s = &quot;hello &quot; + &quot;world&quot;;
}
</code></pre>

<blockquote>
<p>经过Attr解析后，这个源码会变成如下：</p>
</blockquote>

<pre><code class="language-java">public class Yufa {

    public Yufa() {
        super();
    }
    int a = 0;
    private int c = a + 1;
    private int d = 1 + 1;
    private String s = &quot;hello world&quot;;
}
</code></pre>

<p>字符串s由两个&quot;hello &quot;和&quot;world&quot;合并成一个字符串</p>

<h5 id="toc_8">数据流分析</h5>

<p>标注完成后就是<code>com.sun.tools.javac.comp.Flow</code>类完成数据流分析</p>

<ul>
<li>检查变量在使用前是否都已经正确赋值</li>
<li>保证final修饰的变量不会被重复赋值</li>
<li>方法的返回值类型都要确定</li>
<li>所有Checked Exception都要捕获或者向上抛出</li>
<li>所有的语句都要被执行到。这里会检查是否有语句出现在一个方法return的后面</li>
</ul>

<h5 id="toc_9">进一步度对语法树进行语义分析</h5>

<p>语义分析的最后一个步骤是执行<code>com.sun.tools.javac.comp.Flow</code>，这一步是进一步堆语法树进行语义分析，如消除一些无用的代码，永不真的条件判断将会去除。还有就是解除一些语法糖，如将foreach这种语法解析成标准的for循环形式。</p>

<ul>
<li>去掉无用的代码，如假的if代码块。</li>
<li>变量的自动转换，如将int自动包装成Integer类型或者相反的操作等</li>
<li>去除语法糖，将foreach的形式转化成更简单的for循环</li>
</ul>

<h4 id="toc_10">代码生成器</h4>

<p>接下来Javac会调用<code>com.sun.tools.javac.jvm.Gen</code>类遍历语法树生成最终的Java字节码</p>

<p>生成Java字节码需要经过两个步骤：</p>

<ul>
<li>将Java方法中的代码块转成符合JVM语法的命令形式，JVM的操作都是基于栈的，所有的操作都必须经过出栈和进栈来完成</li>
<li>按照JVM的文件组织格式将字节码输出到以class为扩展名的文件中</li>
</ul>

<pre><code class="language-java">public class Daima {
    public static void main(String[] args) {
        int rt = add(1, 2);
    }
    
    public static int add(Integer a, Integer b) {
        return a + b;
    }
}
</code></pre>

<p>这段代码调用一个函数，这个函数的作用就是将两个int类型的参数相加，然后将相加的结果返回给调用者。</p>

<p>加法表达式：必须先将两个操作数a和b放到操作栈，然后再利用加法操作符执行加法操作，将加法的结果放到当前栈的栈顶，最后将这个结果返回给调用者。</p>

<p>这个过程可以用如下方式描述：</p>

<ul>
<li>先计算左表达式结果，将左表达式结果转化成int类型</li>
<li>将这个结果放入当前栈中</li>
<li>再计算右表达式结果，将右表达式结果转化成int类型</li>
<li>将这个结果放入当前栈中</li>
<li>弹出‘+’操作符</li>
<li>将操作结果置于当前栈栈顶</li>
</ul>

<h3 id="toc_11">设计模式解析之访问者模式</h3>

<h4 id="toc_12">访问者模式的结构</h4>

<p>这种模式的基本想法如下：</p>

<ul>
<li>首先我们拥有一个由许多对象构成的对象结构，这些对象的类都拥有一个accept方法用来接受访问者对象</li>
<li>访问者是一个接口，它拥有一个visit方法，这个方法对访问到的对象结构中不同类型的元素作出不同的反应</li>
<li>在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施accept方法，在每一个元素的accept方法中回调访问者的visiti方法，从而使访问者得以处理对象结构的每一个元素。</li>
<li>我们可以针对对象结构设计不同的实在的访问者类完成不同的操作。</li>
</ul>

<p><img src="media/14599206151015/14605998039648.jpg" alt=""/></p>

<ul>
<li>抽象访问者（Visitor）：声明所有访问者需要的接口</li>
<li>具体访问者（Concrete Visitor）：实现抽象访问者声明的接口</li>
<li>抽象节点元素（Element）：提供一个接口能够接受访问者作为参数传递给节点元素</li>
<li>具体节点元素（ConcreteElement）：实现抽象节点元素声明的接口</li>
<li>结构对象（Object Structure）：提供一个接口能够访问到所有的节点元素，一般作为一个集合特有节点元素的引用</li>
<li>客户端（Client）：分别创建访问者和节点元素的对象，调用访问者访问变量节点元素</li>
</ul>

<pre><code class="language-java">interface Visitor {
     void visit(Wheel wheel);
     void visit(Engine engine);
     void visit(Body body);
     void visit(Car car);
 }

 class Wheel {
     private String name;
     Wheel(String name) {
         this.name = name;
     }
     String getName() {
         return this.name;
     }
     void accept(Visitor visitor) {
         visitor.visit(this);
     }
 }
  
 class Engine {
     void accept(Visitor visitor) {
         visitor.visit(this);
     }
 }

 class Body {
     void accept(Visitor visitor) {
         visitor.visit(this);
     }
 }

 class Car {
     private Engine  engine = new Engine();
     private Body    body   = new Body();
     private Wheel[] wheels 
         = { new Wheel(&quot;front left&quot;), new Wheel(&quot;front right&quot;),
             new Wheel(&quot;back left&quot;) , new Wheel(&quot;back right&quot;)  };
     void accept(Visitor visitor) {
         visitor.visit(this);
         engine.accept(visitor);
         body.accept(visitor);
         for (int i = 0; i &lt; wheels.length; ++ i)
             wheels[i].accept(visitor);
     }
 }

 class PrintVisitor implements Visitor {
     public void visit(Wheel wheel) {
         System.out.println(&quot;Visiting &quot; + wheel.getName()
                             + &quot; wheel&quot;);
     }
     public void visit(Engine engine) {
         System.out.println(&quot;Visiting engine&quot;);
     }
     public void visit(Body body) {
         System.out.println(&quot;Visiting body&quot;);
     }
     public void visit(Car car) {
         System.out.println(&quot;Visiting car&quot;);
     }
 }

 public class VisitorDemo {
     static public void main(String[] args) {
         Car car = new Car();
         Visitor visitor = new PrintVisitor();
         car.accept(visitor);
     }
 }
</code></pre>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[秒杀系统架构分析与实战]]></title>
        <link href="http://nathanchen.github.io/14598242695601.html"/>
        <updated>2016-04-05T10:44:29+08:00</updated>
        <id>http://nathanchen.github.io/14598242695601.html</id>
        <content type="html"><![CDATA[
<h2 id="toc_0">秒杀技术挑战</h2>

<h4 id="toc_1">对现有网站业务造成冲击</h4>

<p>将秒杀系统独立部署，甚至使用独立域名，使其与网站完全隔离。</p>

<h4 id="toc_2">高并发下的应用、数据库负载</h4>

<p>重新设计秒杀商品页面，不使用网站原来的商品详细页面，页面内容静态话，用户请求不需要经过应用服务。</p>

<h4 id="toc_3">突然增加的网络及服务器带宽</h4>

<p>因为秒杀新增的网络带宽，必须和运营商重新购买或者租借。为了减轻网站服务器的压力，需要将秒杀商品页面缓存在CDN，同样需要和CDN服务商临时租借新增的出口带宽。</p>

<h4 id="toc_4">直接下单</h4>

<p>下单页面也是一个普通的URL，如果得到这个URL，不用等到秒杀开始就可以下单了。</p>

<p>需要将该URL动态化，即使秒杀系统的开发者也无法在秒杀开始前访问下单页面的URL。方法是在下单页面URL加入由服务器端生成的随机数作为参数，在秒杀开始的时候才能得到。</p>

<h4 id="toc_5">如果控制秒杀商品页面购买按钮的点亮</h4>

<p>在秒杀商品静态页面中加入一个JavaScript文件引用，该JavaScript文件中包含秒杀开始与否标志。这个JavaScript文件非常小，即使每次浏览器刷新都访问JavaScript文件服务器，也不会对服务器集群和网络带宽造成太大压力。</p>

<h4 id="toc_6">如果只允许第一个提交的订单被发送到订单子系统</h4>

<p>假设下单服务器集群有10台服务器，每台服务器只接受最多10个下单请求。</p>

<p>在还没有人提交订单成功之前，如果一个服务器已经有10单了，而有的一单都没处理，可能出现的用户体验不佳的场景是用户第一次点击购买按钮进入已结束页面，再刷新一下页面，有可能被一单都没有处理的服务器处理，进入了填写订单的页面，可以考虑通过cookie的方式来应对，符合一致性原则。当然可以采用最少连接的负载均衡算法，出现上述情况的概率大大降低。</p>

<h4 id="toc_7">如何进行下单前置检查</h4>

<ul>
<li>下单服务器检查本机已处理的下单请求数目</li>
</ul>

<p>如果超过10条，直接返回已结束页面给用户</p>

<p>如果未超过10条，则用户可进入填写订单及确认页面</p>

<ul>
<li>检查全局已提交订单数目</li>
</ul>

<p>已超过秒杀商品总数，返回已结束页面给用户</p>

<p>未超过秒杀商品总数，提交到子订单系统</p>

<h4 id="toc_8">秒杀一般是定时上架</h4>

<h4 id="toc_9">减库存的操作</h4>

<p>有两种选择，一种是拍下减库存；另一种是付款减库存</p>

<h4 id="toc_10">库存会带来‘超卖’的问题</h4>

<p>采用乐观锁</p>

<pre><code class="language-sql">UPDATE auction_auctions SET
quantity = #inQuantity#
WHERE auction_id = #itemId# and quantity = #dbQuantity#
</code></pre>

<h4 id="toc_11">秒杀器的应对</h4>

<p>秒杀器一般下单购买及其迅速，根据购买记录可以甄别出一部分。可以通过校验码达到一定的方法。</p>

<h2 id="toc_12">秒杀架构原则</h2>

<h4 id="toc_13">尽量将请求拦截在系统上游</h4>

<h4 id="toc_14">读多写少的多使用缓存</h4>

<h2 id="toc_15">秒杀架构设计</h2>

<ul>
<li>秒杀系统的页面设计尽可能简单</li>
<li>购买按钮只有在秒杀活动开始的时候才变亮</li>
<li>下单表单也尽可能简单；只有第一个提交的订单发送给网站的订单子系统，其余用户提交订单后只能看到秒杀结束页面</li>
</ul>

<h3 id="toc_16">前端层设计</h3>

<h4 id="toc_17">秒杀页面的展示</h4>

<p>各类静态资源首先应分开存放，然后放到CDN节点上分散压力</p>

<h4 id="toc_18">倒计时</h4>

<p>可能出现客户端时钟与服务器时钟不一致，另外服务器之间也是有可能出现时钟不一致。</p>

<h4 id="toc_19">浏览器层请求拦截</h4>

<ul>
<li>产品层面：用户点击后，按钮置灰</li>
<li>JS层面：限制用户在x秒之内只能提交一次请求</li>
</ul>

<h3 id="toc_20">站点层设计</h3>

<ul>
<li>同一个uid，限制访问频率：做页面缓存，x秒内到达站点层的请求，均返回同一个页面</li>
<li>同一个item的查询，均返回同一个页面</li>
</ul>

<h3 id="toc_21">服务层设计</h3>

<h4 id="toc_22">并发队列的选择</h4>

<ul>
<li>ArrayBlockingQueue是初始容量固定的阻塞队列，我们可以用来作为数据库模块成功竞拍的队列。比如有10个商品，那么我们就设定一个大小为10的数组队列。</li>
<li>ConcurrentLinkedQueue使用的是CAS无锁队列，是一个异步队列，入队的速度很快，出队进行了加锁，性能稍慢。</li>
<li>LinkedBlockingQueue也是阻塞的队列，入队和出队都加了锁，当队空的时候线程会暂时阻塞。</li>
</ul>

<p>由于我们的系统入队需求要远大于出队需求，一般不会出现队空的情况，所以我们可以选择ConcurrentLinkedQueue来作为我们的请求队列实现。</p>

<p>数据库模块数据库主要是使用一个ArrayBlockingQueue来暂存有可能成功的用户请求。</p>

<h2 id="toc_23">数据库设计</h2>

<h3 id="toc_24">设计思路</h3>

<h4 id="toc_25">如何保证数据的可用性？</h4>

<p>冗余。</p>

<h4 id="toc_26">如何保证数据库‘读’高可用？</h4>

<p>冗余读库</p>

<h4 id="toc_27">如何保证数据库‘写’高可用？</h4>

<p>冗余写库。采用双主互备的方式。</p>

<p>双写同步，数据可能冲突（例如‘自增id’同步冲突），有两种常见解决方案：</p>

<ul>
<li>两个写库使用不同的初始值，相同的步长来增加id：写库1的id为0，2，，4，6……；写库2的id为1，3，5，7……</li>
<li>不使用数据的id，业务层自己生成唯一的id。保证数据不冲突。</li>
</ul>

<h4 id="toc_28">如何扩展读性能</h4>

<ul>
<li>第一种是建立索引：不同的库可以建立不同的索引
    - 线上读库建立线上访问索引，例如uid
    - 线下读库建立线下访问索引，例如time</li>
<li>第二种是增加从库</li>
<li>第三种是增加缓存</li>
</ul>

<h4 id="toc_29">如何保证一致性</h4>

<p>主从数据库的一致性，通常有两种解决方案：</p>

<ul>
<li>中间件：如果某一个key有写操作，在不一致时间窗口内，中间件会将这个key的读操作也路由到主库上。</li>
<li>强制读主</li>
</ul>

<p>DB与缓存间的不一致：有可能“从库读到旧数据，旧数据进入cache”</p>

<p>写操作时顺序升级为：</p>

<ul>
<li>淘汰cache</li>
<li>写数据库</li>
<li>在经验‘主从同步延时窗口时间’达到了以后，再次发起一个异步淘汰cache的请求。</li>
</ul>

<h2 id="toc_30">作弊的手段：</h2>

<h3 id="toc_31">同一个帐号，一次性发出多个请求</h3>

<p>在程序入口处，一个帐号只允许接受1个请求，其他请求过滤。</p>

<p>可以通过Redis这种内存缓存服务，写入一个标志位（只允许1个请求写成功），成功写入的则可以继续参加。</p>

<p><img src="media/14598242695601/14598423081800.jpg" alt=""/></p>

<p>或者自己实现一个服务，将同一个帐号的请求放入一个队列中，处理完一个，再处理下一个。</p>

<h3 id="toc_32">多个帐号，一次性发送多个请求</h3>

<p>可以通过检测机器IP请求频率</p>

<ul>
<li>弹出验证码</li>
<li>直接禁止IP</li>
</ul>

<h3 id="toc_33">多个帐号，不同IP发送不同请求</h3>

<p>通过帐号行为的‘数据挖掘’来提前清理掉它们。</p>

<h2 id="toc_34">高并发下的数据安全</h2>

<h3 id="toc_35">悲观锁思路</h3>

<p>在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。</p>

<h3 id="toc_36">FIFO队列思路</h3>

<p>强行将多线程变成单线程。</p>

<p>我们直接将请求放入队列中，采用FIFO。</p>

<h3 id="toc_37">乐观锁思路</h3>

<p>这个数据的所有请求都有资格去修改，但是会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。</p>

<hr/>

<h3 id="toc_38">Reference</h3>

<p><a href="http://www.importnew.com/18920.html">http://www.importnew.com/18920.html</a></p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[StringBuilder在高性能场景下的正确用法]]></title>
        <link href="http://nathanchen.github.io/14596982516208.html"/>
        <updated>2016-04-03T23:44:11+08:00</updated>
        <id>http://nathanchen.github.io/14596982516208.html</id>
        <content type="html"><![CDATA[
<h3 id="toc_0">初始长度很重要</h3>

<p><code>StringBuilder</code>的内部有一个<code>char[]</code>，不同的<code>append()</code>就是不断的往<code>char[]</code>里填东西的过程。</p>

<p><code>new StringBuilder()</code>时<code>char[]</code>的默认长度为16，超过就用<code>System.arraycopy</code>成倍复制扩容。</p>

<p>这样一来有数组拷贝的成本，二来原来的<code>char[]</code>也白白浪费了，要被<code>GC</code>掉。</p>

<p>所以，合理设置一个初始值是很重要的。</p>

<blockquote>
<p>一种长度设置的思路，在<code>append()</code>的时候，不急着往<code>char[]</code>里塞东西，而是先拿一个<code>String[]</code>把它们都存起来，到了最后才把所有<code>String</code>的<code>length</code>加起来，构造一个合理长度的<code>StringBuilder</code>。</p>
</blockquote>

<h3 id="toc_1">但是，还是会浪费一倍的char[]</h3>

<p>因为：</p>

<pre><code class="language-java">return new String(value, 0, count);
</code></pre>

<p><code>String</code>的构造函数会用<code>System.arraycopy()</code>复制一次传入的<code>char[]</code>来保证安全性及不可变性，这样<code>StringBuilder</code>里的<code>char[]</code>就白白牺牲掉了。</p>

<p>为了不浪费这些<code>char[]</code>，可以重用<code>StringBuilder</code>。</p>

<h3 id="toc_2">重用StringBuilder</h3>

<pre><code class="language-java">public StringBuilder getStringBuilder() {
    sb.setLength(0);
    return sb;
}
</code></pre>

<p>为了避免并发冲突，这个<code>Holder</code>一般设为<code>ThreadLocal</code>。</p>

<h3 id="toc_3">+和StringBuilder</h3>

<pre><code class="language-java">String str = &quot;hello &quot; + user.getName();
</code></pre>

<p>这一句经过<code>javac</code>编译后的效果，的确等价于使用<code>StringBuilder</code>，但没有设定长度。</p>

<p>但是，如果像下面这样：</p>

<pre><code class="language-java">String str = &quot;hello &quot;;
str = str + user.getName();
</code></pre>

<p>每一条语句，都会生成一个新的<code>StringBuilder</code>，这样这里就有了两个<code>StringBuilder</code>，性能就完全不一样了。</p>

<p>保险起见，还是继续自己用<code>StringBuilder</code>并设定好长度。</p>

<pre><code class="language-java">private static final ThreadLocal&lt;StringBuilderHelper&gt; threadLocalStringBuilderHolder = new ThreadLocal&lt;StringBuilderHelper&gt;() {
    protected StringBuilderHelper initialValue() {
        return new StringBuilderHelper(256);
    }
}

StringBuilder sb = threadLocalStringBuilderHolder.get().resetAndGetStringBuilder();
</code></pre>

<blockquote>
<p>StringBuidlerHolder</p>
</blockquote>

<pre><code class="language-java">public class StringBuilderHolder {
    private final StringBuilder sb;
    
    public StringBuilderHolder(int capacity) {
        sb = new StringBuidler(capacity);
    }
    
    public StringBuilder resetAndGetStringBuilder() {
        sb.setLength(0);
        return sb;
    }
}
</code></pre>

<hr/>

<h3 id="toc_4">Reference</h3>

<p><a href="http://calvin1978.blogcn.com/articles/stringbuilder.html">http://calvin1978.blogcn.com/articles/stringbuilder.html</a></p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[分布式Unique ID的生成方法一览]]></title>
        <link href="http://nathanchen.github.io/14596964476354.html"/>
        <updated>2016-04-03T23:14:07+08:00</updated>
        <id>http://nathanchen.github.io/14596964476354.html</id>
        <content type="html"><![CDATA[
<h3 id="toc_0">发号器</h3>

<p>Oracle的自增ID</p>

<p>特点是准连续的自增数字，为什么说是准连续？因为性能考虑，每个Client一次会领20个ID回去慢慢用，用完了再来拿。另一个Client过来，拿的就是另外20个ID。</p>

<p>如果有多个数据中心，那就拿高位的几个bit来区分。</p>

<h3 id="toc_1">UUID</h3>

<ul>
<li>时间戳 + UUID版本号，分三段占16个字符</li>
<li>Clock Sequence号与保留字段，占4个字符</li>
<li>节点标识，占12个字符</li>
</ul>

<p>UUID有多种算法，能用于TraceID的是：</p>

<ul>
<li>version1：基于时间的算法</li>
<li>version4：基于随机数的算法</li>
</ul>

<h4 id="toc_2">version 4</h4>

<p>最暴力的做法，也是JDK里的算法，除了少数几个位必须按规范填，其余全部用随机数表示。</p>

<h4 id="toc_3">version 1</h4>

<p>严格守着原来各个位的规矩：</p>

<p>以100纳秒为1，从1582年10月15日算起</p>

<p>节点标识也有48bit，一般用MAC地址表示，如果有多快网卡就随便用一块。如果没有网卡，就用随机数凑数，或者拿一堆尽量多的其他信息，比如主机名什么的，拼在一起再hash</p>

<p>顺序号这16bit则仅用于避免前面的节点标识改变（网卡改了），时钟系统出问题，让它随机一下避免重复。</p>

<hr/>

<h3 id="toc_4">Reference</h3>

<p><a href="http://calvin1978.blogcn.com/articles/uuid.html">http://calvin1978.blogcn.com/articles/uuid.html</a></p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[关于Java集合的小抄]]></title>
        <link href="http://nathanchen.github.io/14596091370634.html"/>
        <updated>2016-04-02T22:58:57+08:00</updated>
        <id>http://nathanchen.github.io/14596091370634.html</id>
        <content type="html"><![CDATA[
<h2 id="toc_0">List</h2>

<h3 id="toc_1">ArrayList</h3>

<p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加<code>50%</code>容量，用<code>System.arraycopy()</code>复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时，创建大小为10的数组。</p>

<h4 id="toc_2">基本优势</h4>

<p>按数组下标访问元素<code>get(i)</code> <code>set(i, e)</code>的性能很高。</p>

<p>直接在数组末尾加入元素<code>add(e)</code>的性能也高。</p>

<h4 id="toc_3">基本劣势</h4>

<p>如果按下表插入、删除元素<code>add(i, e)</code> <code>remove(i)</code> <code>remove(e)</code>，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了。</p>

<h3 id="toc_4">LinkedList</h3>

<p>以双向链表实现。链表无容量限制，但本身使用了更多空间，也需要额外的链表指针操作。</p>

<h4 id="toc_5">基本优势</h4>

<p>不需扩容，调整容量</p>

<p>在链表两头的操作<code>add()</code> <code>addFirst()</code> <code>removeLast()</code>能省掉指针的移动</p>

<h4 id="toc_6">基本劣势</h4>

<p>按下标访问元素<code>get(i)</code> <code>set(i, e)</code>要遍历链表，将指针移动到位。如果<code>i</code>&gt;数组大小的一半，会从末尾移起。</p>

<h3 id="toc_7">CopyOnWriteArrayList</h3>

<p>并发优化的<code>ArrayList</code>。用<code>CopyOnWrite</code>策略，在修改时，先复制一个快照来修改，改完再让内部指针指向新数组。</p>

<p>因为对快照的修改对读操作不可见，所以只有写锁没有读锁，加上复制的昂贵成本，典型的适合读多写少的场景。如果更新频率较高，或者数组较大时，还是<code>Collections.synchronizedList(list)</code>，对所有操作用同一把锁来保证线程安全更好。</p>

<h2 id="toc_8">Map</h2>

<h3 id="toc_9">HashMap</h3>

<p>用<code>key</code>的哈希值%桶数组的大小可得到数组下标。</p>

<p>插入元素时，如果两条<code>key</code>落在同一个桶，<code>Entry</code>用一个<code>next</code>属性实现多个<code>Entry</code>以单向链表存放，后入桶的<code>Entry</code>将<code>next</code>指向桶当前的<code>Entry</code></p>

<p>当<code>Entry</code>数量达到桶数量的<code>75%</code>时，会成倍扩容桶数组，并重新分配所有原来的<code>Entry</code>，所以这两也最好有个预估值。</p>

<p>取模用位运算<code>(hash &amp; (arrayLength-1))</code>会比较快，所以数组的大小永远是2的<code>N</code>次方。默认第一次放入元素时的初始值是16。</p>

<p><strong>在JDK8里，新增默认为8的閥值，当一个桶里的<code>Entry</code>超过閥值，就不以单向链表而以红黑树来存放以加快<code>Key</code>的查找速度。</strong></p>

<h3 id="toc_10">LinkedHashMap</h3>

<p>扩展<code>HashMap</code>，增加了双向链表的实现，号称是最占内存的数据结构。</p>

<h3 id="toc_11">TreeMap</h3>

<p>以红黑树实现。</p>

<h3 id="toc_12">ConcurrentHashMap</h3>

<p>并发优化的<code>HashMap</code>，默认16把写锁（可以设置更多），有效地分散了阻塞的概率，而且没有读锁。</p>

<p>数据结构为<code>Segment[]</code>，<code>Segment</code>里面才是哈希桶数组，每个<code>Segment</code>一把锁。<code>Key</code>先算出它在哪个<code>Segment</code>里，再算出它在哪个哈希桶里。</p>

<h2 id="toc_13">Set</h2>

<p><code>Set</code>几乎都是内部用一个<code>Map</code>来实现的。</p>

<p>将<code>Map</code>里的<code>KeySet</code>当做一个<code>Set</code>，而<code>Value</code>是假值，全部使用同一个<code>Object</code>。<code>Set</code>的特征也继承了那些内部<code>Map</code>实现的特征。</p>

<ul>
<li><code>HashSet</code>：内部就是<code>HashMap</code></li>
<li><code>LinkedHashSet</code>：内部就是<code>LinkedHashMap</code></li>
<li><code>TreeSet</code>：内部就是<code>TreeMap</code>的<code>SortedSet</code></li>
<li><code>ConcurrentSkipListSet</code>：内部就是<code>ConcurrentSkipListMap</code>的并发优化<code>SortedSet</code></li>
</ul>

<h2 id="toc_14">Queue</h2>

<p><code>Queue</code>是在两端出入的<code>List</code>，所以也可以用数组或链表来实现。</p>

<h3 id="toc_15">LinkedList</h3>

<p>即是<code>List</code>，也是<code>Queue</code>。它是唯一一个允许放入<code>null</code>值的<code>Queue</code>。</p>

<h3 id="toc_16">ArrayDeque</h3>

<p>以循环数组实现的双向<code>Queue</code>。大小是2的倍数，默认是16。</p>

<p>It represens a queue where you can insert and remove elements from both ends of the queue. </p>

<h4 id="toc_17">Adding and Accessing Elements</h4>

<p>The order in which the elements added to the ArrayDeque are stored internally. ArrayDeque stores the elements in the order in which they are inserted.</p>

<p>You can peek at the element at the head of the queue without taking the element out of the queue.</p>

<h3 id="toc_18">PriorityQueue</h3>

<p>用二叉堆实现的优先级队列，不再是<code>FIFO</code>，而是按元素实现的<code>Comparable</code>接口或传入<code>Comparator</code>的比较结果来出队，数值越小，优先级越高，越先出队。</p>

<hr/>

<h3 id="toc_19">Reference</h3>

<p><a href="http://calvin1978.blogcn.com/articles/collection.html">http://calvin1978.blogcn.com/articles/collection.html</a></p>

<p><a href="http://tutorials.jenkov.com/java-collections/deque.html">http://tutorials.jenkov.com/java-collections/deque.html</a></p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Java ArrayList工作原理及实现]]></title>
        <link href="http://nathanchen.github.io/14596082686083.html"/>
        <updated>2016-04-02T22:44:28+08:00</updated>
        <id>http://nathanchen.github.io/14596082686083.html</id>
        <content type="html"><![CDATA[
<h2 id="toc_0">概述</h2>

<p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加<code>50%</code>容量，用<code>System.arraycopy()</code>复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时，创建大小为10的数组。</p>

<h4 id="toc_1">基本优势</h4>

<p>按数组下标访问元素<code>get(i)</code> <code>set(i, e)</code>的性能很高。</p>

<p>直接在数组末尾加入元素<code>add(e)</code>的性能也高。</p>

<h4 id="toc_2">基本劣势</h4>

<p>如果按下表插入、删除元素<code>add(i, e)</code> <code>remove(i)</code> <code>remove(e)</code>，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了。</p>

<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add(&quot;语文: 99&quot;);
list.add(&quot;数学: 98&quot;);
list.add(&quot;英语: 100&quot;);
list.remove(0);
</code></pre>

<p><code>add</code>操作：直接将数组的内容置位</p>

<p><code>remove</code>操作：删除index为0的节点，并将后面的元素移到0处。</p>

<h2 id="toc_3">add函数</h2>

<p>add函数：将元素放到末尾</p>

<pre><code class="language-java">public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
</code></pre>

<p><code>ensureCapacityInternal</code>自动扩容机制的核心</p>

<pre><code class="language-java">private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
 
    ensureExplicitCapacity(minCapacity);
}
 
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
 
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}
 
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // 扩展为原来的1.5倍
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    // 如果扩为1.5倍还不满足需求，直接扩为需求值
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>

<ul>
<li>当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍</li>
<li>之后的操作就是把老的数组拷到新的数组里面</li>
</ul>

<h2 id="toc_4">set和get函数</h2>

<ul>
<li>先做index范围检查，看是不是越界了</li>
<li>然后做赋值或访问操作</li>
</ul>

<h2 id="toc_5">remove函数</h2>

<pre><code class="language-java">public E remove(int index) {
    rangeCheck(index);
 
    modCount++;
    E oldValue = elementData(index);
 
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        // 把后面的往前移
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    // 把最后的置null
    elementData[--size] = null; // clear to let GC do its work
 
    return oldValue;
}
</code></pre>

<ul>
<li>删除要删的元素</li>
<li>将排在删除元素后面的往前移</li>
</ul>

<h3 id="toc_6">Reference</h3>

<p><a href="http://www.importnew.com/18865.html">http://www.importnew.com/18865.html</a></p>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[索引的相关知识]]></title>
        <link href="http://nathanchen.github.io/14594286280881.html"/>
        <updated>2016-03-31T20:50:28+08:00</updated>
        <id>http://nathanchen.github.io/14594286280881.html</id>
        <content type="html"><![CDATA[
<h2 id="toc_0">索引的类型</h2>

<h3 id="toc_1"><code>B树</code>(二叉搜索树)：</h3>

<ol>
<li>所有非叶子结点至多拥有两个儿子（<code>Left</code>和<code>Right</code>）；</li>
<li>所有结点存储一个关键字；</li>
<li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</li>
</ol>

<p><img src="media/14594286280881/201603311458.jpg" alt="201603311458"/></p>

<h3 id="toc_2"><code>B--tree</code>多路搜索树（并不是二叉的）</h3>

<h4 id="toc_3"><code>B--tree</code>特点:</h4>

<ol>
<li>定义任意非叶子结点最多只有<code>M</code>个儿子，且<code>M &gt; 2</code>；</li>
<li>根结点的儿子数为<code>[2, M]</code>；</li>
<li>除根结点以外的非叶子结点的儿子数为<code>[M/2, M]</code>；</li>
<li>每个结点存放至少<code>M/2-1</code>（取上整）和至多<code>M-1</code>个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数 = 指向儿子的指针个数 - 1；</li>
<li>非叶子结点的关键字：<code>K[1]</code>, <code>K[2]</code>, …, <code>K[M-1]</code>；且<code>K[i] &lt; K[i+1]</code>；</li>
<li>非叶子结点的指针：<code>P[1]</code>, <code>P[2]</code>, …, <code>P[M]</code>；其中<code>P[1]</code>指向关键字小于<code>K[1]</code>的子树，<code>P[M]</code>指向关键字大于<code>K[M-1]</code>的子树，其它<code>P[i]</code>指向关键字属于(<code>K[i-1]</code>, <code>K[i]</code>)的子树；</li>
<li> 所有叶子结点位于同一层；<br/></li>
</ol>

<blockquote>
<p>（M=3）<br/>
<img src="media/14594286280881/201603311503.jpg" alt="201603311503"/></p>
</blockquote>

<h3 id="toc_4"><code>B+-tree</code>(平衡二叉查找树)</h3>

<p><code>B-Tree</code>索引（大部分<code>mysql</code>存储引擎）<code>B-tree</code>的数据存储是有序的。加速数据的访问不用扫描整个表</p>

<h4 id="toc_5">数据库使用<code>B+-tree</code>结构（<code>B--tree</code>的变种）的原因</h4>

<p>数据库的索引大都以索引文件的形式存储在磁盘上，索引查找的过程就会产生磁盘<code>I/O</code>消耗，<strong>索引结构组织能减少查找过程中磁盘<code>I/O</code>的存取次数</strong>。磁盘会做到按需读取，<strong>每次预读的长度都会为页</strong>（一个节点的大小）<strong>的整数倍</strong>，这样每个节点就只需要一次<code>I/O</code>就能全部载入。新建的节点会申请页空间，一个节点物理上也存储在一个页里，计算机存储分配都是按页对齐的，这样就能一次<code>I/O</code>完全载入一个<code>node</code>。<code>B+-tree</code>的<code>m</code>值越大，树的高度越低，有利于一次完全载入</p>

<h4 id="toc_6">一颗<code>m</code>阶的<code>B+-tree</code>(二叉查找树)的特性如下（其中<code>ceil(x)</code>是一个取上限的函数）</h4>

<ol>
<li>树中每个结点至多有<code>m</code>个孩子</li>
<li>除根结点和叶子结点外，其它每个结点至少有<code>ceil(m/2)</code>个孩子</li>
<li>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）</li>
<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为<code>null</code>)</li>
<li><p>每个非终端结点中包含有<code>n</code>个关键字信息：<code>(n，P0，K1，P1，K2，P2，......，Kn，Pn)</code>。其中：</p>

<pre><code>a) Ki (i=1...n)为关键字，且关键字按顺序排序K(i-1)&lt; Ki。
b) Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。
c) 关键字的个数n必须满足： ceil(m / 2)-1 &lt;= n &lt;= m-1。
</code></pre></li>
</ol>

<h5 id="toc_7">下面以一棵5阶B+-tree实例进行讲解(如下图所示)：（重点看以下图）</h5>

<p><img src="media/14594286280881/201603311033.png" alt="201603311033"/></p>

<p>其满足上述条件：除根结点和叶子结点外，其它每个结点至少有<code>ceil(5/2)=3</code>个孩子（至少2个关键字）；当然最多5个孩子（最多4个关键字）。</p>

<p>下图中关键字为大写字母，顺序为字母升序。</p>

<p><strong>插入（insert）操作</strong></p>

<ul>
<li>首先在<code>B-tree</code>中是否存在，</li>
<li><p>如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，</p>

<ul>
<li>注意：<strong>如果叶子结点空间足够</strong>，这里需要<strong>向右移动该叶子结点中大于新插入关键字的元素</strong>，</li>
<li><strong>如果空间满了以致没有足够的空间去添加新的元素</strong>，则将该<strong>结点进行<code>分裂</code></strong>，将<strong>一半数量的关键字元素分裂到新的其相邻右结点中</strong>，<strong>中间关键字元素上移到父结点中</strong>（当然，如果父结点空间满了，也同样需要<code>分裂</code>操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。</li>
<li>如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</li>
</ul></li>
</ul>

<h5 id="toc_8">插入以下字符字母到空的5阶<code>B-tree</code>中：</h5>

<pre><code>C N G A H E K Q M F W L T Z D P R X Y S
</code></pre>

<ul>
<li>结点空间足够，4个字母插入相同的结点中</li>
</ul>

<p><img src="media/14594286280881/20160331111501.jpg" alt="20160331111501"/></p>

<ul>
<li>当咱们试着插入<code>H</code>时，结点发现空间不够，以致<strong>将其分裂成2个结点</strong>，<strong>移动中间元素<code>G</code>上移到新的根结点中</strong>，在实现过程中，咱们把<strong><code>A</code>和<code>C</code>留在当前结点中</strong>，而<strong><code>H</code>和<code>N</code>放置新的其右邻居结点</strong>中</li>
</ul>

<p><img src="media/14594286280881/20160331111502.jpg" alt="20160331111502"/></p>

<ul>
<li>当咱们插入<code>E</code>, <code>K</code>, <code>Q</code>时，不需要任何分裂操作</li>
</ul>

<p><img src="media/14594286280881/20160331111503.jpg" alt="20160331111503"/></p>

<ul>
<li>插入<code>M</code>需要一次分裂，注意<code>M</code>恰好是中间关键字元素，以致向上移到父节点中</li>
</ul>

<p><img src="media/14594286280881/20160331111504.jpg" alt="20160331111504"/></p>

<ul>
<li>插入<code>F</code>, <code>W ,</code>L<code>, T</code>不需要任何分裂操作</li>
</ul>

<p><img src="media/14594286280881/20160331111505.jpg" alt="20160331111505"/></p>

<ul>
<li>插入<code>Z</code>时，最右的叶子结点空间满了，需要进行分裂操作，中间元素<code>T</code>上移到父节点中，注意通过上移中间元素，    树最终还是保持平衡，分裂结果的结点存在<code>2</code>个关键字元素。</li>
</ul>

<p><img src="media/14594286280881/20160331111506.jpg" alt="20160331111506"/></p>

<ul>
<li>插入<code>D</code>时，导致最左边的叶子结点被分裂，<code>D</code>恰好也是中间元素，上移到父节点中，然后字母<code>P</code>, <code>R</code>, <code>X</code>, <code>Y</code>陆续插入不需要任何分裂操作。</li>
</ul>

<p><img src="media/14594286280881/20160331111507.jpg" alt="20160331111507"/></p>

<ul>
<li>当插入<code>S</code>时，含有<code>N</code>, <code>P</code>, <code>Q</code>, <code>R</code>的结点需要分裂，把中间元素<code>Q</code>上移到父节点中，但是情况来了，<strong>父节点中空间已经满了</strong>，所以也要进行分裂，将父节点中的中间元素<code>M</code>上移到新形成的根结点中，<strong>注意以前在父节点中的第三个指针在修改后包括<code>D</code>和<code>G</code>节点中</strong>。这样具体插入操作的完成。</li>
</ul>

<p><img src="media/14594286280881/20160331111508.jpg" alt="20160331111508"/></p>

<p><strong>删除(delete)操作：</strong></p>

<ul>
<li>首先查找<code>B+-tree</code>中需删除的元素，如果该元素在<code>B+-tree</code>中存在，则将该元素在其结点中进行删除</li>
<li>如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况。</li>
</ul>

<p>删除元素，移动相应元素之后，如果某结点中元素数目小于<code>ceil(m/2)-1</code>，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于<code>ceil(m/2)-1</code>），<strong>如果丰满，则向父节点借一个元素来满足条件</strong>；<strong>如果其相邻兄弟都刚脱贫</strong>，即借了之后其结点数目小于<code>ceil(m/2)-1</code>，<strong>则该结点与其相邻的某一兄弟结点进行“合并”成一个结点</strong>，以此来满足条件</p>

<h5 id="toc_9">依次删除<code>H</code>, <code>T</code>, <code>R</code>, <code>E</code></h5>

<ul>
<li>首先删除元素<code>H</code>，当然首先查找<code>H</code>，<code>H</code>在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目<code>ceil(m/2)-1=2</code>，则操作很简单，咱们只需要移动<code>K</code>至原来<code>H</code>的位置，移动<code>L</code>至<code>K</code>的位置（也就是结点中删除元素后面的元素向前移动）</li>
</ul>

<p><img src="media/14594286280881/20160331121601.jpg" alt="20160331121601"/></p>

<ul>
<li>删除<code>T</code>,因为<code>T</code>没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者<code>W</code>(字母升序的下个元素)，<strong>将<code>W</code>上移到<code>T</code>的位置</strong>，然后将原包含<code>W</code>的孩子结点中的<code>W</code>进行删除，这里恰好删除<code>W</code>后，该孩子结点中元素个数大于2，无需进行合并操作。</li>
</ul>

<p><img src="media/14594286280881/20160331121602.jpg" alt="20160331121602"/></p>

<ul>
<li>删除<code>R</code>，<code>R</code>在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目<code>ceil(5/2)-1=2</code>,<strong>如果其某个相邻兄弟结点中比较丰满（元素个数大于<code>ceil(5/2)-1=2</code>），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中</strong>，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素<code>W</code>下移到该叶子结点中，代替原来<code>S</code>的位置，<code>S</code>前移；然后<code>X</code>在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除<code>X</code>，后面元素前移。</li>
</ul>

<p><img src="media/14594286280881/20160331121603.jpg" alt="20160331121603"/></p>

<ul>
<li><strong>删除<code>E</code>，删除后会导致很多问题</strong>，因为<code>E</code>所在的结点数目刚好达标，刚好满足最小元素个数<code>（ceil(5/2)-1=2）</code>,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以<strong>需要该节点与某相邻兄弟结点进行合并操作</strong>；<strong>首先移动父结点中的元素</strong>（该元素在两个需要合并的两个结点元素之间）<strong>下移到其子结点中</strong>，<strong>然后将这两个结点进行合并成一个结点</strong>。所以在该实例中，<strong>咱们首先将父节点中的元素<code>D</code>下移到已经删除<code>E</code>而只有<code>F</code>的结点中，然后将含有<code>D</code>和<code>F</code>的结点和含有<code>A</code>, <code>C</code>的相邻兄弟结点进行合并成一个结点</strong>。</li>
</ul>

<p><img src="media/14594286280881/20160331121604.jpg" alt="20160331121604"/><br/>
<img src="media/14594286280881/20160331121605.jpg" alt="20160331121605"/></p>

<p>应文件系统所需而产生的一种<code>B+-tree</code>的变形树</p>

<h5 id="toc_10"><code>B+-tree</code>的特性：</h5>

<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ol>

<h5 id="toc_11"><code>B+-树</code>比<code>B--tree</code>更适合实际应用中操作系统的文件索引和数据库索引的原因</h5>

<ol>
<li><strong><code>B+-tree</code>的磁盘读写代价更低</strong>：<code>B+-tree</code>的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对<code>B--tree</code>更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说<code>IO</code>读写次数也就降低了。</li>
<li><strong><code>B+-tree</code>的查询效率更加稳定</strong>：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ol>

<h5 id="toc_12"><code>B+tree</code>的应用</h5>

<p><img src="media/14594286280881/201603311516.jpg" alt="201603311516"/></p>

<h3 id="toc_13"><code>B*-tree</code>（红黑树)</h3>

<p><code>B*-tree</code>是<code>B+-tree</code>的变体，<strong>在<code>B+-tree</code>的非根和非叶子结点再增加指向兄弟的指针</strong>；<code>B*-tree</code>定义了非叶子结点关键字个数至少为<code>(2/3)*M</code>，即块的最低使用率为<code>2/3</code>（代替<code>B+树</code>的<code>1/2</code>）</p>

<p><img src="media/14594286280881/201603311517.jpg" alt="201603311517"/></p>

<p><code>B+树</code>的分裂：<strong>当一个结点满时，分配一个新的结点，并将原结点中<code>1/2</code>的数据复制到新结点，最后在父结点中增加新结点的指针</strong>；<strong><code>B+树</code>的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针</strong>。</p>

<p><code>B*树</code>的分裂：<strong>当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中</strong>，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制<code>1/3</code>的数据到新结点，最后在父结点增加新结点的指针。</p>

<p>所以，<strong><code>B*树</code>分配新结点的概率比<code>B+树</code>要低，空间使用率更高</strong>；</p>

<p><strong>小结</strong></p>

<p><code>B树</code>：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p>

<p><code>B-树</code>：多路搜索树，每个结点存储<code>M/2</code>到<code>M</code>个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>

<p><code>B+树</code>：在<code>B-树</code>基础上，为叶子结点增加链表指针，所有关键字都在叶子结点<br/>
中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>

<p><code>B*树</code>：在<code>B+树</code>基础上，为非叶子结点也增加链表指针，将结点的最低利用率从<code>1/2</code>提高到<code>2/3</code>；</p>

<p><strong>局限性</strong></p>

<ul>
<li>查找必须从索引列的最左边开始</li>
<li>不能跳过索引中的列进行查询</li>
<li>存储引擎不能优化访问任何在第一个范围条件右边的列</li>
</ul>

<p>访问就只能使用索引的头两列，因为<code>like</code>是范围条件</p>

<h3 id="toc_14">哈希索引（只有<code>memory</code>引擎支持显示的哈希索引）</h3>

<p>建立在哈希表的基础上，只对使用了索引中的每一列精确查找有用。对于每一行计算出内索引的哈希码，把哈希码保存在索引中，并且保存一个指向哈希表中每一行的指针<br/>
其检索效率非常高，索引的检索可以一次定位</p>

<h5 id="toc_15">哈希索引的弊端</h5>

<ul>
<li><code>Hash</code>索引仅仅能满足<code>=</code>, <code>IN</code>和<code>&lt;=&gt;</code>查询，<strong>不能使用范围查询</strong>。</li>
</ul>

<p>由于<code>Hash</code>索引比较的是进行<code>Hash</code>运算之后的<code>Hash</code>值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的<code>Hash</code>算法处理之后的<code>Hash</code>值的大小关系，并不能保证和<code>Hash</code>运算前完全一样。</p>

<ul>
<li>`<code>Hash</code>索引无法被用来避免数据的排序操作。</li>
</ul>

<p>由于<code>Hash</code>索引中存放的是经过<code>Hash</code>计算之后的<code>Hash</code>值，而且<code>Hash</code>值的大小关系并不一定和<code>Hash</code>运算前的键值完全一样，所以数据库<strong>无法利用索引的数据来避免任何排序运算</strong>。</p>

<ul>
<li><code>Hash</code>索引<strong>不能利用部分索引键查询</strong>。</li>
</ul>

<p>对于组合索引，<code>Hash</code>索引在计算<code>Hash</code>值的时候是组合索引键合并后再一起计算<code>Hash</code>值，而不是单独计算<code>Hash</code>值，所以通过组合索引的前面一个或几个索引键进行查询的时候，<code>Hash</code>索引也无法被利用。</p>

<ul>
<li><code>Hash</code>索引<strong>在任何时候都不能避免表扫描</strong>。</li>
</ul>

<p>前面已经知道，<code>Hash</code>索引是将索引键通过<code>Hash</code>运算之后，将<code>Hash</code>运算结果的<code>Hash</code>值和所对应的行指针信息存放于一个<code>Hash</code>表中，由于不同索引键存在相同<code>Hash</code>值，所以即使取满足某个<code>Hash</code>键值的数据的记录条数，也无法从<code>Hash</code>索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p>

<ul>
<li><code>Hash</code>索引<strong>遇到大量<code>Hash</code>值相等的情况后性能并不一定就会比<code>B-Tree</code>索引高</strong>。</li>
</ul>

<p>对于选择性比较低的索引键，如果创建<code>Hash</code>索引，那么将会存在大量记录指针信息存于同一个<code>Hash</code>值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</p>

<p>对使用索引的每一列的精确查找有用</p>

<h3 id="toc_16">空间索引（<code>MYISAM</code>必须使用<code>MYSQL</code>的<code>GIS</code>函数）</h3>

<p>空间索引介于空间操作算法和空间对象之间，它通过筛选作用，大量与特定空间操作无关的空间对象被排除，从而提高空间操作的速度和效率</p>

<p>常见空间索引类型有BSP树、K－D－B树、R树、R+树和CELL树</p>

<h3 id="toc_17">全文索引（<code>MYISAM</code>的一种特殊索引）</h3>

<pre><code>CREATE TABLE articles (id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY, title VARCHAR(200),body TEXT,FULLTEXT (title,body));
</code></pre>

<p>上面这是创建表的<code>mysql</code>语句，<strong>其中最后一句<code>FULLTEXT (title,body)</code></strong> <br/>
<code>SELECT</code>表字段<code>FROM</code>表名<code>WHERE MATCH</code>(全文搜索表字段)<code>AGAINST</code>(&#39;搜索字符串&#39;);</p>

<p><code>MATCH</code>相当于要找的列， 而<code>AGAINST</code>就是要找的内容。</p>

<h2 id="toc_18">高性能索引策略</h2>

<ul>
<li>隔离列（不是表达式的一部分，不能位于函数中）</li>
</ul>

<pre><code class="language-mysql">mysql&gt; select ... where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col)&lt;=10;
    
mysql&gt; select ... where data_cool &gt;= DATE_SUB(CURRENT_DATE,INTERVAL 10 DAY);
</code></pre>

<ul>
<li>前缀索引和索引选择性（不重复的索引值（基数）/表中所有行），唯一索引的选择率为1最佳，前缀的选择率接近<code>0.31</code></li>
</ul>

<pre><code class="language-mysql">SELECT COUNT(DISTINCT LEFT(city,3))/COUNT(*) AS SEL3,   COUNT(DISTINCT LEFT(city,4))/COUNT(*) AS SEL4, 
    COUNT(DISTINCT LEFT(city,5))/COUNT(*) AS SEL5…FROM TABLE_NAME; 
</code></pre>

<p>前缀索引不能用于<code>order by</code>或<code>group by</code></p>

<p>后缀索引，但是mysql不支持反向索引，可以保存反向字符，然后索引前缀</p>

<ul>
<li>聚集索引(<code>NONCLUSTERED</code>无论是聚集索引还是非聚集索引都是B树结构。)</li>
</ul>

<p>数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相同，聚集索引有着更快的检索速度。</p>

<p><code>innoDB</code>按照主键进行聚集，无主键使用唯一非空索引，无此索引会定义隐藏主键然后聚集，只聚集同一页的数据</p>

<p>聚类和非聚类对比图：</p>

<p><img src="media/14594286280881/201603311622.jpg" alt="201603311622"/></p>

<p>优点：</p>

<ol>
<li>相关数据保存在一起</li>
<li>数据访问快</li>
</ol>

<p>缺点:</p>

<ol>
<li>插入速度依赖于插入顺序</li>
<li>更新聚集索引代价昂贵</li>
<li>聚集索引表插入新行或行的主键被更新会占用更多的磁盘</li>
<li>聚集表可能比权标扫描慢</li>
<li>非聚类索引需要两次索引查找（找行主键-&gt;找主键保存的数据）</li>
</ol>

<p>适用情况：</p>

<ol>
<li>含有大量非重复值的列。</li>
<li>使用<code>BETWEEN</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>或<code>&lt;=</code>返回一个范围值的列</li>
<li>被连续访问的列</li>
<li>返回大型结果集的查询</li>
<li><p>经常被使用连接或<code>GROUP BY</code>子句的查询访问的列</p></li>
</ol>

<ul>
<li>覆盖索引：包含所有满足查询需要的数据的索引，<code>mysql</code>只能用<code>B-tree</code></li>
</ul>

<p>以<code>innodb</code>引擎</p>

<pre><code class="language-mysql">EXPLAIN SELECT id, name FROM table_name  WHERE name = ‘HOPPER’
</code></pre>

<p><code>Extra:Using where;Using index</code> 此处覆盖取得主键查询</p>

<ul>
<li><p>为排序使用索引扫描</p>

<p>产生排序的方式：文件排序，扫描有序索引</p></li>
</ul>

<pre><code>CREATE TABLE a(
… PRIMARY KEY(id),UNIQUE KEY date(date,nid,cid))
KEY idx_fk_nid(nid), KEY idx_fk_cid(cid)…);

SELECT id FROM table_name where date=&quot;2015-12-16&quot; ORDER BY nid,cid;
</code></pre>

<p>能工作<code>where date=&quot;2015-12-16&quot; ORDER BY nid,cid;</code>形成最左前缀</p>

<blockquote>
<p>注意事项：</p>

<p>索引<code>where</code>（非范围条件）和<code>order</code>形成最左端索引</p>

<p><code>order by</code>中的两列为最左前缀，使用相同的排序方向</p>
</blockquote>

<ul>
<li><p>前缀压缩索引（<code>PACK_KEYS</code>） 第一个值全排序，有相同前缀的，字节+后缀</p>

<p>缺点：<code>cpu</code>密集的负载慢几倍</p></li>
<li><p>避免多余和重复索引（类型相同，同样的顺序在同样的列上创建）</p>

<p>多余：索引（<code>a</code>, <code>b</code>）索引<code>a</code>多余，索引<code>b</code>不多余</p></li>
<li><p>索引和锁定 （从索引的开头开始，提取到满足第一个条件的行结束）</p></li>
</ul>

<h3 id="toc_19">索引的实例研究</h3>

<ul>
<li>支持多种过虑条件</li>
<li>避免多个范围条件只能第一个索引有效</li>
<li><p>优化排序 </p>

<p>只提取最终需要行的主键列，在把它联接回去一取得所有需要的列mysql语句：</p></li>
</ul>

<pre><code class="language-mysql">SELECT &lt;clos&gt; FROM table_name INNER JOIN (
    SELECT &lt;primary key cols&gt; FROM table_name where x.a=&quot;m&quot; ORDER BY rating LIMIT 100000,10) AS X USING(primary key cols)
</code></pre>

]]></content>
    </entry>
    
</feed>
