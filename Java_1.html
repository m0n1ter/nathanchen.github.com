<!doctype html>
<html class="no-js" lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>
        
        Java - NathanCHEN
        
    </title>
    
    
    <link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css"/>
    <link rel="stylesheet" href="asset/css/docs.css"/>
    <link rel="stylesheet" href="asset/css/my.css"/>
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>

</head>
<body class="antialiased hide-extras">

<div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">


        <nav class="top-bar docs-bar hide-for-small" data-topbar>


            <section class="top-bar-section">
                <div class="row">
                    <div style="position: relative;width:100%;">
                        <div style="position: absolute; width:100%;">
                            <ul id="main-menu" class="left">
                                <li id="menu_item_index"><a href="index.html">HOME</a></li>
                                <li id="menu_item_archives"><a href="archives.html">Archives</a></li>
                                <li id="menu_item_about"><a href="about.html">ABOUT</a></li>
                            </ul>

                            <ul class="right" id="search-wrap">
                                <li>
                                    <form target="_blank" action="http://google.com/search" method="get">
                                        <input type="hidden" name="q" value="site:nathanchen.github.io"/>
                                        <input tabindex="1" type="search" name="q" placeholder="Search"/>
                                    </form>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

        </nav>

        <nav class="tab-bar show-for-small">
            <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
                <span> &nbsp; NathanCHEN</span>
            </a>
        </nav>

        <aside class="left-off-canvas-menu">
            <ul class="off-canvas-list">

                <li><a href="index.html">HOME</a></li>
                <li><a href="archives.html">Archives</a></li>
                <li><a href="about.html">ABOUT</a></li>

                <li><label>Categories</label></li>

                
                <li><a href="Java.html">Java</a></li>
                
                <li><a href="JavaScript.html">JavaScript</a></li>
                
                <li><a href="Ngnix.html">Ngnix</a></li>
                
                <li><a href="tomcat.html">tomcat</a></li>
                
                <li><a href="spring.html">spring</a></li>
                
                <li><a href="RabbitMQ.html">RabbitMQ</a></li>
                
                <li><a href="ELK.html">ELK</a></li>
                
                <li><a href="TCP/IP.html">TCP/IP</a></li>
                
                <li><a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html">源码阅读</a></li>
                
                <li><a href="others.html">others</a></li>
                
                <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
                
                <li><a href="PAXOS.html">PAXOS</a></li>
                
                <li><a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html">深入分析Java Web技术内幕</a></li>
                

            </ul>
        </aside>

        <a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
 <script type="text/javascript">
    $(function () {
        $('#menu_item_index').addClass('is_active');
    });
</script>
<div class="row">
    <div class="large-8 medium-8 columns">
        <div class="markdown-body home-categories">
            
            <div class="article">
                <a class="clearlink" href="14588864364518.html">
                    
                    <h1>Java 基础之`final`、`static`、`transient`</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <h3 id="toc_0">一、关于<code>final</code></h3>

<p>根据程序上下文环境，<code>Java</code>关键字<code>fina</code>有<strong>这是无法改变的</strong>或者<strong>终态的</strong>含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。</p>

<blockquote>
<p><code>final</code>类不能被继承，没有子类，<code>final</code>类中的方法默认是<code>final</code>的。</p>

<p><code>final</code>方法不能被子类的方法覆盖，但可以被继承。</p>

<p><code>final</code>成员变量表示常量，只能被赋值一次，赋值后值不再改变。</p>

<p><code>final</code>不能用于修饰构造方法。</p>
</blockquote>

<p>注意：父类的<code>private</code>成员方法是不能被子类方法覆盖的，因此<code>private</code>类型的方法默认是<code>final</code>类型的。</p>

<h4 id="toc_1">1、<code>final</code>类</h4>

<p><strong><code>final</code>类不能被继承</strong>，因此<code>final</code>类的成员方法没有机会被覆盖，默认都是<code>final</code>的。在设计类时候，<strong>如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会再被扩展，那么就设计为<code>final</code>类</strong>。</p>

<h4 id="toc_2">2、<code>final</code>方法</h4>

<p><strong>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为<code>final</code>方法</strong>。</p>

<p>使用<code>final</code>方法的原因有二：</p>

<p>第一、把方法锁定，防止任何继承类修改它的意义和实现。</p>

<p>第二、高效。<strong>编译器在遇到调用<code>final</code>方法时候会转入内嵌机制</strong>，大大提高执行效率。</p>

<h4 id="toc_3">3、<code>final</code>变量（常量）</h4>

<p><strong>用<code>final</code>修饰的成员变量表示常量，值一旦给定就无法改变</strong>！</p>

<p><code>final</code>修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。</p>

<p>另外，<code>final</code>变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，<strong>无论什么情况，编译器都确保空白<code>final</code>在使用之前必须被初始化</strong>。但是，<code>final</code>空白在<code>final</code>关键字<code>final</code>的使用上提供了更大的灵活性，为此，一个类中的<code>final</code>数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p>

<h4 id="toc_4">4、<code>final</code>参数</h4>

<p><strong>当函数参数为<code>final</code>类型时，你可以读取使用该参数，但是无法改变该参数的值</strong>（网上最流行的说法）。</p>

<p><strong>特例</strong></p>

<pre><code class="language-java">public class Test {
    public static void main(String[] args)  {
        MyClass myClass = new MyClass();
        StringBuffer buffer = new StringBuffer(&quot;hello&quot;);
        myClass.changeValue(buffer);
        System.out.println(buffer.toString());
    }
}
 
class MyClass {
 
    void changeValue(final StringBuffer buffer) {
        buffer.append(&quot;world&quot;);
    }
}

====&gt; helloworld
</code></pre>

<p>Once a final variable has been assigned, it always contains the same value. <strong><em>If a final variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object.</em></strong></p>

<p>如果一个被<code>final</code>关键字修饰的变量<code>A</code>指向一个对象<code>B</code>的引用，那么这个变量<code>A</code>的状态可能会随着<code>B</code>的改变而改变，但<code>A</code>一直都指向<code>B</code>的</p>

<p>在上例中，变量<code>A</code>（<code>buffer</code>）指向一个对象<code>B</code>（<code>StringBuffer</code>）的引用，对象<code>B</code>（<code>StringBuffer</code>）的值改变了，但是他的内存地址没有改变。</p>

<pre><code class="language-java">final StringBuffer a = new StringBuffer(&quot;Hello&quot;);
a = new StringBuffer(&quot;World&quot;); //this wont compile
</code></pre>

<h3 id="toc_5">二、关于<code>static</code></h3>

<p><code>static</code>表示<strong>全局</strong>或者<strong>静态</strong>的意思，用来修饰成员变量和成员方法，也可以形成静态<code>static</code>代码块，但是<code>Java</code>语言中没有全局变量的概念。</p>

<h4 id="toc_6">1、<code>static</code>变量</h4>

<p>按照是否静态的对类成员变量进行分类可分两种：<strong>一种是被<code>static</code>修饰的变量，叫静态变量或类变量</strong>；另<strong>一种是没有被<code>static</code>修饰的变量，叫实例变量</strong>。两者的区别是：</p>

<p>对于<strong>静态变量在内存中只有一个拷贝</strong>（节省内存）， <strong>JVM 只为静态分配一次内存</strong>，在加载类的过程中完成静态变量的内存分配，<strong>可用类名直接访问</strong>（方便），当然也可以通过对象来访问（但是这是不推荐的）。</p>

<p><strong>对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响</strong>（灵活）。</p>

<p>用<code>public</code>修饰的<code>static</code>成员变量和成员方法本质是全局变量和全局方法，当声明其他类的对象时，不生成<code>static</code>变量的副本，而是类的所有实例共享同一个<code>static</code>变量。</p>

<p><code>static</code>变量前可以有<code>private</code>修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用，但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，<strong><code>private</code>是访问权限限定，<code>static</code>表示不要实例化就可以使用</strong>，这样就容易理解多了。<code>static</code>前面加上其它访问权限关键字的效果也以此类推。</p>

<h4 id="toc_7">2、<code>static</code>方法</h4>

<p>静态方法可以直接通过类名调用，任何的实例也都可以调用，因此<strong>静态方法中不能用<code>this</code>和<code>super</code>关键字，不能直接访问所属类的实例变量和实例方法(就是不带<code>static</code>的成员变量和成员成员方法)</strong>，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！</p>

<p><strong>因为<code>static</code>方法独立于任何实例，因此<code>static</code>方法必须被实现，而不能是抽象的<code>abstract</code></strong>。</p>

<h4 id="toc_8">3、<code>static</code>代码块</h4>

<p><code>static</code>代码块也叫静态代码块，是在类中独立于类成员的<code>static</code>语句块，可以有多个，位置可以随便放，它不在任何的方法体内，<strong><code>JVM</code>加载类时会执行这些静态的代码块，如果<code>static</code>代码块有多个，<code>JVM</code>将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次</strong>。</p>

<h4 id="toc_9">4、<code>static</code>和<code>final</code>一块用表示什么</h4>

<p><strong><code>static</code>、<code>final</code>用来修饰成员变量和成员方法，可简单理解为“全局常量”</strong>！</p>

<p>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。</p>

<p>对于方法，表示不可覆盖，并且可以通过类名直接访问。</p>

<p>特别要注意一个问题：</p>

<p>对于被<code>static</code>和<code>final</code>修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，<code>ArrayList</code>、<code>HashMap</code>）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。</p>

<h4 id="toc_10">5、静态内部类</h4>

<p>这里简单介绍下，什么是静态内部类。</p>

<p><strong>简单的说内部类前加<code>static</code>就是静态内部类</strong>了，上代码：</p>

<pre><code class="language-java">public class Outer { 
    static int x =1;
    static class Nest {
        void print(){
            System.out.println(&quot;Nest &quot;+x);
        }
    }
    public static void main(String[] args){
        Outer.Nest nest = new Outer.Nest();
        nest.print();
    }
}
</code></pre>

<p>当内部类是<code>static</code>时，意味着：</p>

<ul>
<li><p>要创建静态内部类的对象，并不需要其外部类的对象；</p></li>
<li><p>不能够从静态内部类的对象中访问外部类的非静态成员；</p></li>
</ul>

<p>与普通的内部类的一个区别：在非静态内部类中不可以声明静态成员，只有将某个内部类修饰为静态类，然后才能够在这个类中定义静态的成员变量与成员方法。</p>

<h4 id="toc_11">6、静态导包</h4>

<p>所谓静态导入包：<code>import static com. ... . ClassName.*</code>这样写可以导入相关类里面的所有静态方法，或者也可以直接静态导入具体到静态方法名。</p>

<p>这样写的好处是，引用静态方法不用在前面加上类名.</p>

<p>需要注意两点：</p>

<ul>
<li><p>提防含糊不清的命名<code>static</code>成员。例如，如果你对<code>Integer</code>类和<code>Long</code>类执行了静态导入，引用<code>MAX_VALUE</code>将导致一个编译器错误，因为<code>Integer</code>和<code>Long</code>都有一个<code>MAX_VALUE</code>常量，并且<code>Java</code>不会知道你在引用哪个<code>MAX_VALUE</code>。</p></li>
<li><p>方法名的命名尽量明确，让看代码的人看到名称就知道这个方法是干嘛用的，不然静态导入会让代码变的难读。</p></li>
</ul>

<blockquote>
<p>附：</p>

<p><strong>对象的初始化顺序</strong>: </p>

<ul>
<li><strong>首先执行父类静态</strong>的内容，父类静态的内容执行完毕后，</li>
<li><strong>接着去执行子类的静态</strong>的内容，当子类的静态内容执行完毕之后，</li>
<li>再去看<strong>父类有没有非静态代码块</strong>，如果有就执行父类的非静态代码块，</li>
<li>父类的非静态代码块执行完毕，<strong>接着执行父类的构造方法</strong>；</li>
<li>父类的构造方法执行完毕之后，它接着去看<strong>子类有没有非静态代码块</strong>，如果有就执行子类的非静态代码块。</li>
<li>子类的非静态代码块执行完毕再去执行<strong>子类的构造方法</strong>。</li>
</ul>

<p><mark>总之一句话，静态代码块内容先执行，接着执行父类非静态代码块和构造方法，然后执行子类非静态代码块和构造方法</mark>。</p>

<p>**注意: <strong>子类的构造方法，</strong>不管这个构造方法带不带参数，默认的它都会先去寻找父类的不带参数的构造方法**。如果父类没有不带参数的构造方法，那么子类必须用<code>super</code>关键子来调用父类带参数的构造方法，否则编译不能通过。</p>
</blockquote>

<h3 id="toc_12">三、<code>transient</code></h3>

<p>java 的<code>transient</code>关键字为我们提供了便利，你只需要实现<code>Serilizable</code>接口，将不需要序列化的属性前添加关键字<code>transient</code>，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p>

<ul>
<li><p>一旦变量被<code>transient</code>修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p></li>
<li><p><code>transient</code>关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被<code>transient</code>关键字修饰的。变量如果是用户自定义类变量，则该类需要实现<code>Serializable</code>接口。</p></li>
<li><p>被<code>transient</code>关键字修饰的变量不再能被序列化，一个静态变量不管是否被<code>transient</code>修饰，均不能被序列化。</p></li>
</ul>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/25</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14588711280200.html">
                    
                    <h1>Java内存访问重排序的研究</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <pre><code>public class PossibleReordering {
    static int x = 0, y = 0;
    static int a = 0, b = 0;
    
    public static void main(String[] args) throws InterruptedException {
        Thread one = new Thread(new Runnable() {
            public void run() {
                a = 1;
                x = b;
            }
        });
    
        Thread other = new Thread(new Runnable() {
            public void run() {
                b = 1;
                y = a;
            }
        });
        one.start();other.start();
        one.join();other.join();
        System.out.println(“(” + x + “,” + y + “)”);
    }
}
</code></pre>

<p>这段代码的执行结果也可能是（0，0），因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。</p>

<p>得到（0，0）结果的语句执行过程：</p>

<p><img src="media/14588711280200/14588715411444.jpg" alt=""/></p>

<p><code>a=1</code>和<code>x=b</code>这两个语句的赋值操作的顺序被颠倒了，或者说，发生了指令“重排序<code>(reording)</code>”</p>

<p>大多数现代微处理器都会采用将指令乱序执行的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避免获取下一条指令所需数据时造成的等待，通过乱序执行的技术，处理器可以大大提高执行效率。</p>

<h3 id="toc_0"><code>as-if-serial</code>语义</h3>

<p>所有的动作都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。</p>

<pre><code>int a = 1;
int b = 2;
int c = a + b;
</code></pre>

<p>将上面的代码编译成<code>Java</code>字节码或生成机器指令，可视为展开成了以下动作：</p>

<pre><code>1. 对a赋值1
2. 对b赋值2
3. 取a的值
4. 取b的值
5. 将取到两个值相加后存入c
</code></pre>

<p>在上面5个动作中，<code>动作1</code>可能会和<code>动作2、4</code>重排序，<code>动作2</code>可能会和<code>动作1、3</code>重排序，<code>动作3</code>可能会和<code>动作2、4</code>重排序，<code>动作4</code>可能会和<code>动作1、3</code>重排序。但<code>动作1</code>和<code>动作3、5</code>不能重排序。<code>动作2</code>和<code>动作4、5</code>不能重排序。因为它们之间存在数据依赖关系，一旦重排，<code>as-if-serial</code>语义便无法保证</p>

<h3 id="toc_1">内存访问重排序与内存可见性</h3>

<p>计算机系统中，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存（cache）以提高性能。</p>

<p><img src="media/14588711280200/14588720292789.jpg" alt=""/></p>

<p>在这种模型下会存在一个现象，即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据并不是实时同步的。从程序的视角来看，就是同一个时间点，各个线程所看到的共享变量的值可能是不一致的。</p>

<h3 id="toc_2">内存访问重排序与Java内存模型</h3>

<p>根据<code>Java</code>内存模型中的规定，可以总结出以下几条<code>happens-before</code>规则。<code>happens-before</code>的前后两个操作不会被重排序且后者对前者的内存可见。</p>

<ul>
<li>程序次序法则：线程中的每个<code>动作A</code>都<code>happens-before</code>于该线程中的每一个<code>动作B</code>，其中，在程序中，所有的<code>动作B</code>都能出现在<code>动作A</code>之后。</li>
<li>监视器锁法则：对一个监视器锁的解锁<code>happens-before</code>于每一个后续对同一监视器锁的加锁。</li>
<li><code>volatile</code>变量法则：对<code>volatile</code>域的写入操作<code>happens-before</code>于每一个后续对同一个域的读写操作。</li>
<li>线程启动法则：在一个线程里，对<code>Thread.start()</code>的调用会<code>happens-before</code>于每个启动线程的动作。</li>
<li>线程终结法则：线程中的任何动作都<code>happens-before</code>于其他线程检测到这个线程已经终结、或者从<code>Thread.join()</code>调用中成功返回，或<code>Thread.isAlive()</code>返回<code>false</code>。</li>
<li>中断法则：一个线程调用另一个线程的<code>interrupt</code> <code>happens-before</code>于被中断的线程发现中断。</li>
<li>终结法则：一个对象的构造函数的结束<code>happens-before</code>于这个对象<code>finalizer</code>的开始。</li>
<li>传递性：如果<code>A</code> <code>happens-before</code>于<code>B</code>，且<code>B</code> <code>happens-before</code>于<code>C</code>，则<code>A</code> <code>happens-before</code>于<code>C</code></li>
</ul>

<h3 id="toc_3">Reference</h3>

<p><a href="http://tech.meituan.com/java-memory-reordering.html">http://tech.meituan.com/java-memory-reordering.html</a></p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/25</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14588687241012.html">
                    
                    <h1>`HashMap`底层原理</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <h3 id="toc_0">引言</h3>

<blockquote>
<p><code>HashMap</code>基于哈希表的<code>Map</code>接口的实现。此实现提供所有可选的映射操作，并允许使用<code>null</code>值和<code>null</code>键。（除了不同步和允许使用<code>null</code>之外，<code>HashMap</code>类与<code>Hashtable</code>大致相同）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>

<p>值得注意的是<code>HashMap</code>不是线程安全的，如果想要线程安全的<code>HashMap</code>，可以通过<code>Collections</code>类的静态方法<code>synchronizedMap</code>获得线程安全的<code>HashMap</code>。</p>

<pre><code>Map map = Collections.synchronizedMap(new HashMap());
</code></pre>
</blockquote>

<h3 id="toc_1">一、数据结构与冲突</h3>

<p><code>HashMap</code>的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。<strong><code>HashMap</code>中主要是通过<code>key</code>的<code>hashCode</code>来计算<code>hash</code>值的</strong>，只要<code>hashCode</code>相同，计算出来的<code>hash</code>值就一样。<strong>如果存储的对象对多了，就有可能不同的对象所算出来的<code>hash</code>值是相同的，这就出现了所谓的<code>hash</code>冲突</strong>。解决<code>hash</code>冲突的方法有很多，<code>HashMap</code>底层是<strong>通过链表来解决<code>hash</code>冲突的</strong>。</p>

<p><img src="media/14588687241012/14588688631332.jpg" alt=""/></p>

<p>图中，左边部分代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。右边部分则显示数组内部结构，<code>HashMap</code>其实就是一个<code>Entry</code>数组，<code>Entry</code>对象中包含了键和值，其中<code>next</code>也是一个<code>Entry</code>对象，它就是用来处理<code>hash</code>冲突的，形成一个链表。</p>

<h3 id="toc_2">二、HashMap相关属性</h3>

<pre><code>transient Entry[] table;//存储元素的实体数组

transient int size;//存放元素的个数

int threshold; //临界值，当实际大小超过临界值时，会进行扩容，扩容大小为当前的2倍。threshold = 负载因子*容量

final float loadFactor; //负载因子

transient int modCount;//被修改的次数
</code></pre>

<p>其中比较重要的两个参数是容量(<code>Capacity</code>) 和 负载因子(<code>Load factor</code>)</p>

<blockquote>
<p><strong>Initial capacity</strong>: The capacity is the number of buckets in the hash table, The initial capacity is simply the capacity at the time the hash table is created.<br/>
<strong>Load factor</strong>: The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.</p>
</blockquote>

<p>简单的说，<code>Capacity</code>就是<code>bucket</code>的大小，<code>loadFactor</code>就是<code>bucket</code>填满程度的最大比例。</p>

<p><code>loadFactor</code>越大，填满的元素越多，好处是，空间利用率高了，但冲突的机会加大了，链表长度会越来越长,查找效率降低。</p>

<p>反之，<code>loadFactor</code>越小，填满的元素越少，好处是冲突的机会减小了，但空间浪费多了，表中的数据将过于稀疏（很多空间还没用，就开始扩容了）</p>

<p>因此,必须在 “冲突的机会” 与 “空间利用率” 之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的 “时-空” 矛盾的平衡与折衷.</p>

<p>如果机器内存足够，并且想要提高查询速度的话可以将<code>loadFactor</code>设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将<code>loadFactor</code>设置大一点。不过<strong>一般取默认值0.75</strong>就好。</p>

<h3 id="toc_3">三、使用频率最高的两个方法<code>put</code>和<code>get</code></h3>

<p><code>put</code>函数大致的思路为：</p>

<p>1、对<code>key</code>的<code>hashCode()</code>做<code>hash</code>，然后再计算<code>index</code>；</p>

<p>2、如果没碰撞直接放到<code>bucket</code>里；</p>

<p>3、如果碰撞了，以链表的形式存在<code>buckets</code>后；</p>

<p>4、如果碰撞导致链表过长(大于等于<code>TREEIFY_THRESHOLD</code>)，就把链表转换成红黑树；</p>

<p>5、如果节点已经存在就替换<code>old value</code>(保证<code>key</code>的唯一性)；</p>

<p>6、如果<code>bucket</code>满了(超过<code>loadFactor * current capacity</code>)，就要<code>resize</code>。</p>

<pre><code>public V put(K key, V value) 
{
    // 对key的hashCode()做hash
    return putVal(hash(key), key, value, false, true);
}
 
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) 
{
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;

    // tab为空则创建
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;

    // 计算index，并对null做处理
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);

    else 
    {
        Node&lt;K,V&gt; e; K k;

        // 节点存在
        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;

        // 该链为树
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);

        // 该链为链表
        else 
        {
            for (int binCount = 0; ; ++binCount) 
            {
                if ((e = p.next) == null) 
                {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        // 写入
        if (e != null) 
        { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    // 超过load factor*current capacity，resize
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre>

<p><code>get</code>函数大致思路如下：</p>

<p>1、<code>bucket</code>里的第一个节点，直接命中；</p>

<p>2、如果有冲突，则通过<code>key.equals(k)</code>去查找对应的<code>entry</code>；</p>

<p>3、若为树，则在树中通过<code>key.equals(k)</code>查找，<code>O(logn)</code>；</p>

<p>4、若为链表，则在链表中通过<code>key.equals(k)</code>查找，<code>O(n)</code>。</p>

<pre><code>public V get(Object key) 
{
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
 
final Node&lt;K,V&gt; getNode(int hash, Object key) 
{
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) 
    {
        // 直接命中
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        // 未命中
        if ((e = first.next) != null) 
        {
            // 在树中get
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            // 在链表中get
            do 
            {
                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre>

<h3 id="toc_4">四、<code>resize</code>的实现</h3>

<p>当<code>put</code>时，如果发现目前的<code>bucket</code>占用程度已经超过了<code>loadFactor</code>所希望的比例，那么就会发生<code>resize</code>。在<code>resize</code>的过程，简单的说就是把<code>bucket</code>扩充为2倍，之后重新计算<code>index</code>，把节点再放到新的<code>bucket</code>中。<code>resize</code>的注释是这样描述的：</p>

<blockquote>
<p>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</p>
</blockquote>

<p>大致意思就是说，<strong>当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</strong>。</p>

<p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：</p>

<p><img src="media/14588687241012/14588692702341.jpg" alt=""/></p>

<p>因此元素在重新计算<code>hash</code>之后，因为<code>n</code>变为2倍，那么<code>n-1</code>的<code>mask</code>范围在高位多<code>1bit</code>(红色)，因此新的<code>index</code>就会发生这样的变化：</p>

<p><img src="media/14588687241012/14588692827747.jpg" alt=""/></p>

<p>因此，我们在扩充<code>HashMap</code>的时候，不需要重新计算<code>hash</code>，只需要看看原来的<code>hash</code>值新增的那个<code>bit</code>是1还是0就好了，是0的话索引没变，是1的话索引变成<code>原索引+oldCap</code>。可以看看下图为16扩充为32的<code>resize</code>示意图：</p>

<p><img src="media/14588687241012/14588693335759.jpg" alt=""/></p>

<p>这个设计非常巧妙，既省去了重新计算<code>hash</code>值的时间，而且同时，由于新增的<code>1bit</code>是0还是1可以认为是随机的，因此<code>resize</code>的过程，均匀的把之前的冲突的节点分散到新的<code>bucket</code>了。</p>

<h3 id="toc_5">总结</h3>

<p>通过<code>hash</code>的方法，通过<code>put</code>和<code>get</code>存储和获取对象。存储对象时，我们将<code>K/V</code>传给<code>put</code>方法时，它调用<code>hashCode</code>计算<code>hash</code>从而得到<code>bucket</code>位置，进一步存储，<code>HashMap</code>会根据当前<code>bucket</code>的占用情况自动调整容量(超过<code>loadFactor</code>则<code>resize</code>为原来的2倍)。获取对象时，我们将<code>K</code>传给<code>get</code>，它调用<code>hashCode</code>计算<code>hash</code>从而得到<code>bucket</code>位置，并进一步调用<code>equals()</code>方法确定键值对。如果发生碰撞的时候，<code>HashMap</code>通过链表将产生碰撞冲突的元素组织起来，在<code>Java 8</code>中，如果一个<code>bucket</code>中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/25</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14585496303082.html">
                    
                    <h1>虚拟机类加载机制</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p>虚拟机把描述类的数据从Class文件加载到内存，并堆数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>

<h3 id="toc_0">类加载的时机</h3>

<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个部分统称为连接。</p>

<p>虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：</p>

<ul>
<li>遇到new、getstatic、putstatic和invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，以及调用一个类的静态方法的时候</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li>
</ul>

<p>194/412</p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/21</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14578521973777.html">
                    
                    <h1>类文件结构</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <h3 id="toc_0"><code>Class</code>类文件的结构</h3>

<p><code>Class</code>文件是<strong>一组以8位字节为基础单位的二进制流</strong>，每个数据项目严格按照顺序紧凑地排列在<code>Class</code>文件之中，中间没有添加任何分隔符。<strong>当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割若干个8位字节进行存储</strong>。</p>

<p>Class文件格式只有两种数据类型：无符号数和表。</p>

<p><img src="media/14578521973777/14580226267662.jpg" alt=""/></p>

<h5 id="toc_1">无符号数</h5>

<ul>
<li>以<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>来分别表示1个字节、2个字节、4个字节和8个字节的无符号数</li>
<li>无符号数可以用来描述数字、索引引用、数量值，或者按照<code>utf-8</code>编码构成字符串值</li>
</ul>

<h5 id="toc_2">表</h5>

<ul>
<li>由多个无符号数或其他表作为数据项构成的复合数据类型</li>
<li>所有表都习惯性地以<code>_info</code>结尾</li>
<li>表用于描述有层次关系的复合结构的数据</li>
<li>整个<code>Class</code>文件本质上就是一张表</li>
</ul>

<p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容器计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。</p>

<h4 id="toc_3">魔数与<code>Class</code>文件的版本</h4>

<p>每个<code>Class</code>文件的头4个字节称为魔数（<code>Magic Number</code>），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的<code>Class</code>文件。</p>

<p><code>Class</code>文件的魔数为：<code>0xCAFEBABE</code> （<code>Cafe Babe</code>）</p>

<p>紧接着魔数的4个字节存储的是<code>Class</code>文件的版本号：第5和第6个字节是次版本号（<code>Minor Version</code>），第7和第8个字节是主版本号（<code>Major Version</code>）</p>

<blockquote>
<p>根据表6-1：<code>magic</code>是<code>u4</code>类型，因此是从<code>offset0</code>-<code>offset3</code></p>
</blockquote>

<p><img src="media/14578521973777/14578645877419.jpg" alt=""/></p>

<p><img src="media/14578521973777/14580227286642.jpg" alt=""/></p>

<h4 id="toc_4">常量池</h4>

<p>紧接着主次版本号之后的是常量池入口，常量池是<code>Class</code>文件结构中与其他项目关联最多的数据类型，也是占用<code>Class</code>文件空间最大的数据项目之一，同时它还是在<code>Class</code>文件中第一个出现的表类型数据项目。</p>

<p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一个<code>u2</code>类型的数据，代表常量池容量计数值（<code>constant_pool_count</code>）。这个容量计数是从1而不是0开始的。</p>

<p><img src="media/14578521973777/14578648670083.jpg" alt=""/></p>

<blockquote>
<p>常量池容量为十六进制的<code>0x0016</code>，即十进制的22，这就代表常量池中有21项常量</p>
</blockquote>

<p><strong><code>Class</code>文件结构中只有常量池的容量计数是从1开始的</strong>，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都是从0开始。</p>

<p><strong>常量池之中主要存放两大类常量：字面量（<code>Literal</code>）和符号引用（<code>Symbolic References</code>）</strong>。字面量比较接近于<code>Java</code>语言层面的常量概念，如文本字符串、被声明为<code>final</code>的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>

<ul>
<li>类和接口的全限定名（<code>Fully Qualified Name</code>）</li>
<li>字段的名称和描述符（<code>Descriptor</code>）</li>
<li>方法的名称和描述符</li>
</ul>

<p><code>Java</code>代码在进行<code>javac</code>编译的时候，是在虚拟机加载<code>Class</code>文件的时候进行动态连接。也就是说，在<strong><code>Class</code>文件中不会保存各个方法和字段的最终内存布局信息</strong>，因此这些字段和方法的符号引用不经过转换的话是无法直接被虚拟机使用的。<strong>当虚拟机运行时，需要从常量池获得对应的符号引用</strong>，再在类创建时或运行时解析并翻译到具体的内存地址之中。</p>

<p>常量池中的每一项常量都是一个表，共有11种结构各不相同的表结构数据，这11种表都有一个共同的特点，就是表开始的第一位是<code>u1</code>类型的标志位，代表当前这个常量属于哪种常量类型。</p>

<p><img src="media/14578521973777/14578729659671.jpg" alt=""/></p>

<p>图6-3中常量池的第一个常量，它的标志位是<code>0x07</code>，再看表6-3会发现这个常量属于<code>CONSTANT_Class_info</code>类型，此类型的常量代表一个类或接口的符号引用。</p>

<p><img src="media/14578521973777/14580150986168.jpg" alt="CONSTANT_Class_info结构"/></p>

<p><code>tag</code>是标志位</p>

<p><code>name_index</code>是一个索引值，它指向常量池中的一个<code>CONSTANT_Utf8_info</code>类型的常量，此常量代表了这个类（或者接口）的全限定名，这里的<code>name_index</code>值（偏移地址：<code>0x0000000B</code>）为<code>0x0002</code>，即指向了常量池中的第二项常量。它的标志位（偏移地址：<code>0x0000000D</code>）是0x01，查看表6-3可知是一个CONSTANT_Utf8_info类型的常量，其结构为</p>

<p><img src="media/14578521973777/14580174577630.jpg" alt=""/></p>

<p>length值说明这个字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。</p>

<p>本例中这个字符串的length值（偏移地址：<code>0x0000000F</code>）为0x001D，也就是长29个字节，内容为<code>org/fenixsoft/clazz/TestClass</code></p>

<p><img src="media/14578521973777/14580177154247.jpg" alt=""/></p>

<p><img src="media/14578521973777/14580282573398.jpg" alt=""/></p>

<p><img src="media/14578521973777/14580282699233.jpg" alt=""/></p>

<h4 id="toc_5">访问标志</h4>

<p>在常量池结束之后，紧接着的2个字节代表访问标志（<code>access_flags</code>），这个标志用于识别一些类或接口层次的访问信息，包括：这个<code>class</code>是类还是接口；是否定义为<code>public</code>类型；是否定义为<code>abstract</code>类型；如果是类的话，是否被声明为<code>final</code>等等。</p>

<p><img src="media/14578521973777/14580284064697.jpg" alt=""/></p>

<h4 id="toc_6">类索引、父类索引和接口索引集合</h4>

<p>类索引（<code>this_class</code>）和父类索引（<code>super_class</code>）都是一个<code>u2</code>类型的数据，而接口索引集合（<code>interfaces</code>）是一组<code>u2</code>类型的数据的集合，<code>Class</code>文件中由这三项数据来确定这个类的继承关系。</p>

<p><strong>类索引用于确定这个类的全限定名</strong>，<strong>父类索引用于确定这个类的父类的全限定名</strong>。由于<code>Java</code>不允许多重继承，所以父类索引只有一个，除了<code>java.lang.Object</code>之外，所有的<code>Java</code>类都有父类，因此除了<code>java.lang.Object</code>外，所有Java类的父类索引都不为0.</p>

<p>接口索引结合就用来描述这个类实现了哪些接口，<strong>这些被实现的接口将按<code>implements</code>语句后的接口顺序从左到右排列在接口的索引集合中</strong>。</p>

<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，<strong>类索引和父类索引用两个<code>u2</code>类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的全限定名字符串</strong></p>

<p><img src="media/14578521973777/14581128653713.jpg" alt=""/></p>

<p>对于接口索引集合，入口的第一项 - <code>u2</code>类型的数据为接口计数器（<code>interfaces_count</code>），表示索引表的容量。如果该类没有实现任何接口，那么该计数器值为0，后面接口的索引表不再占用任何字节。</p>

<h4 id="toc_7">字段表集合</h4>

<p>字段表（field_info）用于描述接口或类中声明的变量。字段（field）包括了类级变量或实例级变量，但不包括在方法内部声明的变量。</p>

<p>各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>

<p><img src="media/14578521973777/14581155115280.jpg" alt=""/></p>

<p>字段修饰符放在access_flags中</p>

<p><img src="media/14578521973777/14581155742017.jpg" alt=""/></p>

<p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称及字段和方法的描述符。</p>

<p><strong>全限定名</strong>：<code>org/fenixsoft/clazz/TestClass</code>是这个类的全限定名，在使用时最后一般会加入一个<code>;</code>表示全限定名结束</p>

<p><strong>简单名称</strong>：指没有类型和参数修饰的方法或字段名称，方法<code>inc()</code>和字段<code>m</code>的简单名称分别是<code>inc</code>和<code>m</code></p>

<p>方法和字段的<strong>描述符</strong>：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，<strong>基本数据类型（<code>byte, char, double, float, int, long, short, boolean</code>）及代表无返回值的<code>void</code>类型都用一个大写字符</strong>来表示，而<strong>对象类型则用字符<code>L</code>加对象的全限定名来表示</strong>。</p>

<p><img src="media/14578521973777/14581169733475.jpg" alt=""/></p>

<p>对于数组类型，每一纬度将使用一个前置的<code>[</code>字符来描述，如一个定义为<code>java.lang.String[][]</code>类型的二维数组，将被记录为：<code>[[Ljava/lang/String</code>；一个整型数组<code>int[]</code>将被记录为<code>[I</code></p>

<p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>()</code>之内。</p>

<p>如方法<code>void inc()</code>的描述符为<code>()V</code>，方法<code>java.lang.String toString()</code>的描述符为<code>()Ljava/lang/String</code>，方法<code>int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)</code>的描述符为<code>([CII[CIIII)I</code></p>

<p><img src="media/14578521973777/14581204026529.jpg" alt=""/></p>

<ul>
<li>第一个<code>u2</code>类型的数据为容量计数器<code>fields_count</code>，其值为<code>0x0001</code>，说明这个类只有一个字段表数据。</li>
<li>接下来是<code>access_flags</code>标志，其值为<code>0x0002</code>，代表<code>private</code>修饰符的<code>ACC_PRIVATE</code>标志位为真，其他修饰符为假。</li>
<li>代表字段名称的<code>name_index</code>的值为<code>0x0005</code>，从代码清单列出的常量表中可查到第五项常量是一个<code>CONSTANT_Utf8_info</code>类型的字符串，其值为<code>m</code>；代表字段描述符的<code>descriptor_index</code>的值为<code>0x0006</code>，指向常量池的字符串<code>I</code></li>
<li>根据这些信息，我们可以推断出原代码定义的字段为<code>private int m</code></li>
</ul>

<h4 id="toc_8">方法表集合</h4>

<p>方法表的结构如同字段表一样，依次包括了访问标志（<code>access_flags</code>）、名称索引（<code>name_index</code>）、描述符索引（<code>descriptor_index</code>）、属性表集合（<code>attributes</code>）几项。</p>

<p><img src="media/14578521973777/14585396884316.jpg" alt=""/></p>

<ul>
<li>第一个<code>u2</code>类型的数据（即是计数器容量）的值为<code>0x0002</code>，代表集合中有两个方法。</li>
<li>第一个方法的访问标志值为<code>0x001</code>，也就是只有<code>ACC_PUBLIC</code>标志为真</li>
<li>名称索引值为<code>0x0007</code>，查看代码清单的常量池可得方法名为<code>&lt;init&gt;</code></li>
<li>描述符索引值为<code>0x0008</code>，对应常量为<code>()V</code></li>
<li>属性表计数器<code>attributes_count</code>的值为<code>0x0001</code>就表示此方法的属性表集合有一项属性</li>
<li>属性名称索引为<code>0x0009</code>，对应常量为<code>Code</code>，说明此属性是方法的字节码描述</li>
</ul>

<p>在<code>Java</code>语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还需要必须拥有一个与原方法不同的特征签名，<strong>特征签名就是一个方法中各个参数在常量池中的字段符号引用集合</strong>，也就是因为返回值不会包含在特征签名之中，因此<code>Java</code>语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</p>

<h4 id="toc_9">属性表集合</h4>

<p>在Class文件、字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>

<p>对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要说明属性值所占用的位数长度即可。</p>

<p><img src="media/14578521973777/14585408733389.jpg" alt=""/></p>

<h5 id="toc_10">Code 属性</h5>

<p>Java程序方法体里面的代码经过javac编译器处理之后，最终变为字节码指令存储在Code属性内。</p>

<p><img src="media/14578521973777/14585473693257.jpg" alt=""/></p>

<ul>
<li>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为Code</li>
<li>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共是6个字节，所以属性值的长度固定为整个属性表的长度减去6个字节</li>
<li>max_stack代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。</li>
<li>max_locals代表了局部变量表所需的存储空间</li>
</ul>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/3/13</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            


            <div class="row">
                <div class="large-6 columns">
                    <p class="text-left" style="padding-top:25px;">
                         <a href="Java.html">&laquo; Prev Page</a> 
                    </p>
                </div>
                <div class="large-6 columns">
                    <p class="text-right" style="padding-top:25px;">
                         <a href="Java_2.html">&raquo; Next Page</a> 
                    </p>
                </div>
            </div>
        </div>
    </div>
    <!-- large 8 -->

 <div class="large-4 medium-4 columns">
    <div class="hide-for-small">
        <div id="sidebar" class="sidebar">
            <div id="site-info" class="site-info">
                
                <h1>NathanCHEN</h1>

                <div class="site-des"></div>
                <div class="social">
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <a class="rss" href="atom.xml" title="RSS">RSS</a>

                </div>
            </div>
            <div id="site-categories" class="side-item ">
                <div class="side-header">
                    <h2>Contact</h2>
                </div>
                <div class="side-content">
                    <ul class="posts-list">
                        <li class="post">
                            <p class="email-addr">tringchen AT gmail.com</p>

                            <p class="email-addr">江苏 · 南京</p>
                        </li>
                    </ul>
                </div>
            </div>
            <div id="site-categories" class="side-item ">
                <div class="side-header">
                    <h2>Categories</h2>
                </div>
                <div class="side-content">

                    <p class="cat-list">
                        
                        <a href="Java.html"><strong>Java</strong></a>
                        
                        <a href="JavaScript.html"><strong>JavaScript</strong></a>
                        
                        <a href="Ngnix.html"><strong>Ngnix</strong></a>
                        
                        <a href="tomcat.html"><strong>tomcat</strong></a>
                        
                        <a href="spring.html"><strong>spring</strong></a>
                        
                        <a href="RabbitMQ.html"><strong>RabbitMQ</strong></a>
                        
                        <a href="ELK.html"><strong>ELK</strong></a>
                        
                        <a href="TCP/IP.html"><strong>TCP/IP</strong></a>
                        
                        <a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"><strong>源码阅读</strong></a>
                        
                        <a href="others.html"><strong>others</strong></a>
                        
                        <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
                        
                        <a href="PAXOS.html"><strong>PAXOS</strong></a>
                        
                        <a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html"><strong>深入分析Java Web技术内幕</strong></a>
                        
                    </p>


                </div>
            </div>

            <div id="site-categories" class="side-item">
                <div class="side-header">
                    <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                    <ul class="posts-list">
                        
                        
                        <li class="post">
                            <a href="14596982516208.html">StringBuilder在高性能场景下的正确用法</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14596964476354.html">分布式Unique ID的生成方法一览</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14596091370634.html">关于Java集合的小抄</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14596082686083.html">Java ArrayList工作原理及实现</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14594286280881.html">索引的相关知识</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                </div>
            </div>
        </div>
        <!-- sidebar -->
    </div>
    <!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->
 <div class="page-bottom clearfix">
    <div class="row">
        <p class="copyright">Copyright &copy; 2016
            Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp;
            Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
    </div>
</div>
</section>
</div>
</div>




<script src="asset/js/foundation.min.js"></script>
<script>
    $(document).foundation();
    function fixSidebarHeight() {
        var w1 = $('.markdown-body').height();
        var w2 = $('#sidebar').height();
        if (w1 > w2) {
            $('#sidebar').height(w1);
        }
        ;
    }
    $(function () {
        fixSidebarHeight();
    })
    $(window).load(function () {
        fixSidebarHeight();
    });

</script>





</body>
</html>
