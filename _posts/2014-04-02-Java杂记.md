---
layout: post
title: "Java杂记"
category: Reading Notes
tags: ["读文章", "Java"]
---
{% include JB/setup %}


> If I have a `try/catch` block with returns inside it, will the finally block be called?

	finally will be called.
	The only time finally won't be called is if you call System.exit() or if the JVM crashes first.


****

`final-修饰符`（关键字）如果一个类被声明为final，意味着它不能再派生出心的子类，不能作为父类被继承。因此一个类不能既被声明为abstract，又被声明为final。

将变量或方法声明为final，可以保证他们在使用中不被改变。

被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。

被声明为final的方法也同样只能使用，不能重载。

#### 几种情况

打印“123123”，指针指向`‘STRING_BUILDER’`没变，但是`‘STRING_BUILDER’`对象的值更改了

	static final StringBuilder STRING_BUILDER = new StringBuilder("123");
	
	@Test
    public void stringBuilderTest1()
    {
        STRING_BUILDER.append("123");
        System.out.println(STRING_BUILDER);
    }
	
为`STRING_BUILDER`新建一个对象是不可以的	
	
    static final StringBuilder STRING_BUILDER = new StringBuilder("123");
    
    @Test
    public void stringBuilderTest2()
    {
    	// error 不可以
        STRING_BUILDER = new StringBuilder("8888");
        System.out.println(STRING_BUILDER);
    }
    
`‘STRING_BUILDER’`之前指向的是`‘tempbu’`，`‘tempbu’`对应的值是`‘123’`；

而后`‘tempbu’`对应了一个新的值`‘8888’`，但是`‘STRING_BUILDER’`依然指向原来`‘tempbu’`对应的位置
    
	static StringBuilder tempbu = new StringBuilder("123");
    static final StringBuilder STRING_BUILDER = tempbu;
    
    @Test
    public void stringBuilderTest3()
    {
        tempbu = new StringBuilder("8888");
        System.out.println(STRING_BUILDER);
    }
    
> 所以一个对象即使有`‘final’`关键词修饰，他的值也是可以变化的，只是不能指向一个新的对象（即指向对象不能变，指向对象的值可以变）
	

****

HashMap和Hashtable的区别。 

都属于Map接口的类，实现了将惟一键映射到特定的值上。 

HashMap允许一个 null 键和多个 null 值。 

Hashtable 类似于 HashMap，但是不允许 null 键和 null 值。它也比 HashMap 慢，因为它是同步的。 

****

`short s1 = 1; s1 = s1 + 1;`有错，`s1`是`short`型，`s1+1`是`int`型,不能显式转化为`short`型。可修改为`s1 =(short)(s1 + 1)` 。

`short s1 = 1; s1 += 1`正确。 

****

`sleep()` 和 `wait() `有什么区别? 
 
`sleep()`方法是使线程停止一段时间的方法。在sleep 时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其它线程可能正在运行而且没有被调度为放弃执行，除非`(a)“醒来”`的线程具有更高的优先级 
`(b)`正在运行的线程因为其它原因而阻塞。 

`wait()`是线程交互时，如果线程对一个同步对象x 发出一个`wait()`调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。

****

- `++i` will increment the value of i, and then return the incremented value.

        i = 1;
        j = ++i;
        (i is 2, j is 2)

- `i++` will increment the value of i, but return the pre-incremented value.

        i = 1;
        j = i++;
        (i is 2, j is 1) 


	    int index = 10;
	
	    System.out.println(index--);//10
	
	    System.out.println(--index);//9

****

Java does manipulate objects by reference, and all object variables are references. However, Java doesn't pass method arguments by reference, it passes them by value.

    public void badSwap(int var1, int var2)
    {
      int temp = var1;
      var1 = var2;
      var2 = temp;
    }

When `badSwap()` returns, the variables passed as arguments will still hold their original values.

Here is where it gets tricky:

    public void tricky(Point arg1, Point arg2)
    {
      arg1.x = 100;
      arg1.y = 100;
      Point temp = arg1;
      arg1 = arg2;
      arg2 = temp;
    }
    public static void main(String [] args)
    {
      Point pnt1 = new Point(0,0);
      Point pnt2 = new Point(0,0);
      System.out.println("X: " + pnt1.x + " Y: " +pnt1.y); 
      System.out.println("X: " + pnt2.x + " Y: " +pnt2.y);
      System.out.println(" ");
      tricky(pnt1,pnt2);
      System.out.println("X: " + pnt1.x + " Y:" + pnt1.y); 
      System.out.println("X: " + pnt2.x + " Y: " +pnt2.y);  
    }

If we execute this `main()` method, we see the following output:

    X: 0 Y: 0
    X: 0 Y: 0
    X: 100 Y: 100
    X: 0 Y: 0

![](img/Java杂记1.gif)