---
layout: post
title: "设计模式——工厂模式"
category: Reading Notes
tags: ["读文章", “设计模式”]
---
{% include JB/setup %}

## 工厂模式

### 主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的

### Factory design pattern is used for creating an object based on different parameters. The example below is about creating human in a factory. If we ask the factory for a boy, the factory will produce a boy; if we ask for a girl, the factory will produce a girl. Based on different parameters, the factory produce different stuff.

### 简单工厂模式

#### 组成：

1. 工厂类角色：含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现
2. 抽象产品角色：一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现
3. 具体产品角色：

    
		//抽象产品角色
		public interface Car {
			public void drive(); 
		}
	 
	
		//具体产品角色
		public class Benz implements Car{
			public void drive()  {
				System.out.println("Driving Benz ");
			}
		}

		public class Bmw implements Car{
			public void drive()  {
				System.out.println("Driving Bmw ");
			}
		}

		....

	
		//工厂类角色
		public class Driver 
		{
			//工厂方法.注意 返回类型为抽象产品角色
			public static Car driverCar(String s)throws Exception {
				//判断逻辑，返回具体的产品角色给Client
				if(s.equalsIgnoreCase("Benz"))  
					return new Benz();
				else if(s.equalsIgnoreCase("Bmw"))
					return new Bmw();
	
				.... 
	
				else 
					throw new Exception();

		....
		
		//欢迎暴发户出场......
		public class Magnate {
			public static void main(String[] args){
				try
				{ 
					//告诉司机我今天坐奔驰  
					Car car = Driver.driverCar("benz"); 
					//下命令：开车   
					car.drive();
		....

当暴发户增加了一辆车的时候，只要符合抽象产品制定的合同，那么只要通知工厂类知道就可以被客户使用了。

**但是工厂部分好像不太理想，因为每增加一辆车，都要在工厂类中增加相应的业务逻辑或者判断逻辑，这显然是违背开闭原则的。**

### 工厂方法模式

工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承。

#### 组成

1. 抽象工厂角色：是具体工厂角色必须实现的接口或者继承的父类。在java中它由抽象类或者接口来实现
2. 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象
3. 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现
4. 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现


		//抽象产品角色
		public interface Car {
			public void drive(); 
		}

		public class Benz implements Car{
			public void drive()  {
				System.out.println("Driving Benz ");
			}
		}

		public class Bmw implements Car{
			public void drive()  {
				System.out.println("Driving Bmw ");
			}
		}

		//抽象工厂角色
		public interface Driver{
	       public Car driverCar();
		}

		public class BenzDriver implements Driver{
	       public Car driverCar() {
	              return new Benz();
	       }
		}
		public class BmwDriver implements Driver{
	       public Car driverCar() {
				return new Bmw(); 
	       }
		}

		public class Magnate
		{
              public static void main(String[] args)
              {
                     try
					 { 
                            Driver driver = new BenzDriver();
                            Car car = driver.driverCar();
                            car.drive();
                     }
       	……
		}

