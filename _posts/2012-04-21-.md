---
layout: post
title: "线程与进程"
category: 
tags: []
---
{% include JB/setup %}

##Introduction to threads and processes
##进程与线程简介

Programs consist of a number of processes, each of which contains one or more conceptually concurrent threads of execution.
程序包含了若干进程，每一个进程包含了一个或多个概念上知执行的线程。

A thread is the unit of execution within a process. Every time a process is initialised, a primary thread is created. For many applications the primary thread is the only one that the application requires; however, processes can create additional threads.
线程是进程的执行单元。当进程被初始化后，主线程就被创建了。对于绝大多数的应用程序来说，通常仅要求有一个主线程。尽管如此进程也可以创建额外的线程。


Each user process has its own private address space, i.e. a collection of memory regions which that process can access. A user process cannot directly address memory areas in the address space of another process. There is also a special process, the Kernel process, whose threads run at supervisor privilege level. This process normally contains two threads:
每一个用户进程拥有自己私有的地址空间，也就是说，进程拥有一定的可被其访问的内存区域。一个用户进程不可以直接访问其他进程的地址空间。另外还有一个特殊的进程,内核进程，它运行在超级用户权限模式。这个进程通常包括两个线程：

Threads execute individually and are unaware of other threads in a process. The scheduling of threads is pre-emptive, i.e. a currently executing thread may be suspended at any time to allow another thread to run.

线程是独立运行的，它且并不知道进程中还有其他线程存在。线程的执行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。

Each thread is assigned a priority; at any time, the thread running is the highest priority thread which is ready to run. Threads with equal priority are time-sliced on a round-robin basis. Context switching between threads involves saving and restoring the state of threads. This state includes not only the processor registers (the thread context) but also the address space accessible to the thread (the process context). The process context only needs switching if a reschedule is between threads in different processes.
每一个线程都设置了优先限权；在任何时候，只要线程已经准备就绪，具有高优先权的线程总是首先运行。如果线程具有相同的优先权，则根据时间片进行轮转调度。上下文的切换包括了保存和恢复线程状态。这个状态不仅仅包含了处理器寄存器（进程上下文）而且还包含了线程可访问的地址空间（进程上下文）。只有在重新调度是在两个进程间进行的时候，进程上下文才被切换。

Compare this with active objects which allow non pre-emptive multi-tasking within a single thread.
把这个与活动对象比较，活动对象允许在一个线程中实现非强占式的多任务调度。
A thread can suspend, resume, panic and kill another thread.
一个线程可以被挂起，唤醒、异常抛出和结束其他线程。
