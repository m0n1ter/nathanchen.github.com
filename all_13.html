<!doctype html>
<html class="no-js" lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>
        
        NathanCHEN
        
    </title>
    
    
    <link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css"/>
    <link rel="stylesheet" href="asset/css/docs.css"/>
    <link rel="stylesheet" href="asset/css/my.css"/>
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>

</head>
<body class="antialiased hide-extras">

<div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">


        <nav class="top-bar docs-bar hide-for-small" data-topbar>


            <section class="top-bar-section">
                <div class="row">
                    <div style="position: relative;width:100%;">
                        <div style="position: absolute; width:100%;">
                            <ul id="main-menu" class="left">
                                <li id="menu_item_index"><a href="index.html">HOME</a></li>
                                <li id="menu_item_archives"><a href="archives.html">Archives</a></li>
                                <li id="menu_item_about"><a href="about.html">ABOUT</a></li>
                            </ul>

                            <ul class="right" id="search-wrap">
                                <li>
                                    <form target="_blank" action="http://google.com/search" method="get">
                                        <input type="hidden" name="q" value="site:nathanchen.github.io"/>
                                        <input tabindex="1" type="search" name="q" placeholder="Search"/>
                                    </form>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

        </nav>

        <nav class="tab-bar show-for-small">
            <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
                <span> &nbsp; NathanCHEN</span>
            </a>
        </nav>

        <aside class="left-off-canvas-menu">
            <ul class="off-canvas-list">

                <li><a href="index.html">HOME</a></li>
                <li><a href="archives.html">Archives</a></li>
                <li><a href="about.html">ABOUT</a></li>

                <li><label>Categories</label></li>

                
                <li><a href="Java.html">Java</a></li>
                
                <li><a href="JavaScript.html">JavaScript</a></li>
                
                <li><a href="Ngnix.html">Ngnix</a></li>
                
                <li><a href="tomcat.html">tomcat</a></li>
                
                <li><a href="spring.html">spring</a></li>
                
                <li><a href="RabbitMQ.html">RabbitMQ</a></li>
                
                <li><a href="ELK.html">ELK</a></li>
                
                <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
                
                <li><a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html">源码阅读</a></li>
                
                <li><a href="others.html">others</a></li>
                
                <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
                
                <li><a href="PAXOS.html">PAXOS</a></li>
                
                <li><a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html">深入分析Java Web技术内幕</a></li>
                
                <li><a href="Java7%20Concurrency%20Cookbook.html">Java7 Concurrency Cookbook</a></li>
                
                <li><a href="GoogleDevelopersWebFundamentals.html">GoogleDevelopersWebFundamentals</a></li>
                

            </ul>
        </aside>

        <a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
 <script type="text/javascript">
    $(function () {
        $('#menu_item_index').addClass('is_active');
    });
</script>
<div class="row">
    <div class="large-8 medium-8 columns">
        <div class="markdown-body home-categories">
            
            <div class="article">
                <a class="clearlink" href="14547603646438.html">
                    
                    <h1>Logstash</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p>A Logstash pipeline has two required elements, <code>input</code> and <code>output</code>, and one optional element, <code>filter</code>. The <code>input</code> plugins consume data from a source, the <code>filter</code> plugins modify the data as you specify, and the <code>output</code> plugins write the data to a destination.</p>

<p><img src="media/14547603646438/14547604765057.jpg" alt=""/></p>

<pre><code>input {
    file {
        path =&gt; &quot;/path/to/logstash-tutorial.log&quot;
        start_position =&gt; beginning 
    }
}
</code></pre>

<p>The default behavior of the file input plugin is to monitor a file for new information, in a manner similar to the UNIX <code>tail -f</code> command. To change this default behavior and process the entire file, we need to specify the position where Logstash starts processing the file.</p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/2/6</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='ELK.html'>ELK</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14545663221729.html">
                    
                    <h1>Introduction</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p><code>RabbitMQ</code> is a message broker. In essence, it accepts messages from producers, and delivers them to consumers.</p>

<p><code>Producing</code> means nothing more than sending. A program that sends messages is a producer.</p>

<p>A <code>queue</code> is the name for a <strong>mailbox</strong>. It lives inside RabbitMQ. <strong>Although messages flow through RabbitMQ and your applications, they can be stored only inside a queue</strong>. A queue is not bound by any limits, it can store as many messages as you like - it&#39;s essentially <strong>an infinite buffer</strong>. Many producers can send messages that go to one queue - many consumers can try to receive data from one queue.</p>

<p><code>Consuming</code> has a similar meaning to receiving. A consumer is a program that mostly waits to receive messages.</p>

<h3 id="toc_0">Sending</h3>

<p><img src="media/14545663221729/14579605946992.jpg" alt=""/></p>

<pre><code class="language-java">public class Send {
  private final static String QUEUE_NAME = &quot;hello&quot;;

  public static void main(String[] argv)
      throws java.io.IOException {
      ...
  }
}
</code></pre>

<p>then we can create a connection to the server:</p>

<pre><code class="language-java">        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
</code></pre>

<p>The connection abstracts the socket connection, and takes care of protocol version negotiation and authentication and so on for us. </p>

<p>Next we create a channel, which is where most of the API for getting things done resides.</p>

<p><strong>To send, we must declare a queue for us to send to; then we can publish a message to the queue</strong>:</p>

<pre><code class="language-java">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
        System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);
</code></pre>

<p>Declaring a queue is idempotent - it will only be created if it doesn&#39;t exist already.</p>

<h3 id="toc_1">Receiving</h3>

<p><img src="media/14545663221729/14579606349386.jpg" alt=""/></p>

<p>Setting up is the same as the sender; we open a connection and a channel, and <strong>declare the queue from which we&#39;re going to consume</strong>.</p>

<h3 id="toc_2">Message acknowledgement</h3>

<p>In order to make sure a message is never lost, RabbotMQ supports message acknowledgments. <strong>An ack is sent back from the consumer to tell RabbitMQ that a particular message has been received</strong>, processed and that RabbitMQ is free to delete it.</p>

<p>If a consumer dies without sending an ack, RabbitMQ will understand that a message wasn&#39;t processed fully and will re-queue it. If there are other consumers online at the same time, it will then quickly redeliver it to another consumer. That way you can be sure that no message is lost, even if the workers occasionally die.</p>

<p>When RabbitMQ quits or crashes it will forget the queues and messages unless you tell it not to. Two things are required to make sure that meesages aren&#39;t lost: we need to make both the queue and messages as durable.</p>

<p>First, we need to make sure that RabbitMQ will never lose our queue. In order to do so, we need to declare it as durable:</p>

<pre><code class="language-java">    boolean durable = true;
    channel.queueDeclare(&quot;task_queue&quot;, durable, false, false, null);
</code></pre>

<p>RabbitMQ doesn&#39;t allow you to redefine an existing queue with different parameters and will return an error to any program that tries to do that.</p>

<p>At this point we&#39;re sure that the task_queue won&#39;t be lost even if RabbitMQ restarts. Now we need to make our messages as persistent - by setting MessageProperties to the value PERSISTENT_TEXT_PLAIN.</p>

<pre><code class="language-java">    channel.basicPublish(&quot;&quot;, &quot;task_queue&quot;,
            MessageProperties.PERSISTENT_TEXT_PLAIN,
            message.getBytes());
</code></pre>

<p>RabbitMQ dispatches a mesage when the message enters the queue. It doesn&#39;t look at the number of unacknowledged messages for a consumer. It just blindly dispatches every n-th message to the n-th consumer.</p>

<p>In order to defeat that we can use the basicQos method with the prefetchCount = 1 setting. This tells RabbitMQ not to give more than one message to a worker at a time. Or, in other words, don&#39;t dispatch a new message to a worker until it has processed and acknowledged the previous one. Instead, it will dispatch it to the next worker that is not still busy.</p>

<pre><code class="language-java">    int prefetchCount = 1;
    channel.basicQos(prefetchCount);  
</code></pre>

<p>The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue. Actually, quite often the producer doesn&#39;t even know if a message will be delivered to any queue at all. </p>

<p>Instead, the producer can only send messages to an exchange. An exchange is a very simple thing. On one side it receives messages from producers and the other side it pushes them to queues. The exchange must know exactly what to do with a message it receives.</p>

<p>In previous parts of the tutorial we knew nothing about exchanges, but still were able to send messages to queues. That was possile because we were using a default exchange, which we identify by the empty string (&quot;&quot;)</p>

<pre><code class="language-java">    channel.basicPublish(&quot;&quot;, &quot;hello&quot;, null, message.getBytes());
</code></pre>

<p>A binding is a relationship between an exchange and a queue. This can be simply read as: the queue is interested in messages from this exchange.</p>

<p>Bindings can take an extra routingKey parameter. To avoid the confusion with a basic_publish parameter we&#39;re going to call it a bingding key.</p>

<pre><code class="language-java">    channel.queueBind(queueName, EXCHANGE_NAME, &quot;black&quot;);
</code></pre>

<p>The meaning of a binding key depends on the exchange type. The fanout exchanges simply ignored its value.</p>

<p>The routing algorithm behind a direct exchange is simple - a message foes to the queues whose binding key exactly matches the routing key of the message.</p>

<p>Although using the direct exchange improved our system, it still has limitations - it can&#39;t do routing based on multiple criteria.</p>

<p>Messages sent to a topic exchange can&#39;t have an arbitrary routing_key - it must be a list of words, delimited by dots. The words can be anything, but usually they specify some features connected to the message. There can be as many words in the routing key as you like, up to the limit of 255 bytes.</p>

<p>The binding key must also be in the same form. The logic behind the topic exchange is similar to a direct one - a message sent with a particular routing key will be delivered to all the queues that are bound with a matching binding key. However there are two important special cases for bing keys:</p>

<ul>
<li>* (star) can be substitute for exactly one word</li>
<li># (hash) can substitute for zero or more words</li>
</ul>

<h3 id="toc_3">Exchanges</h3>

<ul>
<li>A producer is a user application that sends message.</li>
<li>A queue is a buffer that stores messages.</li>
<li>A consumer is a user application that receives messages.</li>
</ul>

<p>The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue. Actually, quite often the producer doesn&#39;t even know if a message will be delivered to any queue at all.</p>

<p>Instead, the producer can only send messages to an exchange. On one side the <strong>exchange receives messages from producers</strong> and the other side <strong>it pushes them to queues</strong>. The exchange must know exactly what to do with a message it receives.</p>

<p><img src="media/14545663221729/14579615633125.jpg" alt=""/></p>

<h3 id="toc_4">Temporary queues</h3>

<p>Giving a queue a name is important when you want to share the queue between producers and consumers.</p>

<ul>
<li><p>Firstly, whenever we connect to Rabbit we need a fresh, empty queue. To do this we could create a queue with a random name.</p></li>
<li><p>Secondly, once we disconnect the consumer the queue should be automatically deleted.</p></li>
</ul>

<h4 id="toc_5">发送消息</h4>

<pre><code class="language-java">import java.io.IOException;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

public class EmitLog {

    private static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] argv)
                  throws java.io.IOException {
            // 新建一个连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 定义连接工厂的host地址（RabbitMQ Server）
        factory.setHost(&quot;localhost&quot;);
        // 生成一个新连接
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
            // 设定指定exhange的消息发送格式
        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);

        String message = getMessage(argv);
            // 对exchange发送消息
        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
        System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);

        channel.close();
        connection.close();
    }
    //...
}
</code></pre>

<h4 id="toc_6">接收消息</h4>

<pre><code class="language-java">import com.rabbitmq.client.*;

import java.io.IOException;

public class ReceiveLogs {
  private static final String EXCHANGE_NAME = &quot;logs&quot;;

  public static void main(String[] argv) throws Exception {
    ConnectionFactory factory = new ConnectionFactory();
    factory.setHost(&quot;localhost&quot;);
    Connection connection = factory.newConnection();
    Channel channel = connection.createChannel();

    channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);
    // 生成一个queue
    String queueName = channel.queueDeclare().getQueue();
    // 将这个queue绑定到指定的exchange上去
    channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);

    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);

    Consumer consumer = new DefaultConsumer(channel) {
      @Override
      public void handleDelivery(String consumerTag, Envelope envelope,
                                 AMQP.BasicProperties properties, byte[] body) throws IOException {
        String message = new String(body, &quot;UTF-8&quot;);
        System.out.println(&quot; [x] Received &#39;&quot; + message + &quot;&#39;&quot;);
      }
    };
    channel.basicConsume(queueName, true, consumer);
  }
}
</code></pre>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/2/4</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='RabbitMQ.html'>RabbitMQ</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14544046745526.html">
                    
                    <h1>创建Spring MVC之器</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p>HttpServletBean、FrameworkServlet和DispatcherServlet这三个类直接实现三个接口：EnvironmentCapable、EnvironmentAware和ApplicationContextAware。XXXAware在spring里表示对XXX可以感知，通俗点解释就是：如果某个类里面想要使用spring的一些东西，就可以通过实现XXXAware接口告诉spring，spring看到后就会给你送过来，而接收的方式是通过实现接口唯一的方法set-XXX。</p>

<p>比如，有一个类想要使用当前的ApplicationContext，那么我们只需要让它实现ApplicationContextAware接口，然后实现接口中唯一的方法<code>void setApplicationContext(ApplicationContext applicationContext)</code>就可以了，spring会自动调用这个方法将applicationContext传给我们，我们只需要接收就可以了。</p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/2/2</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='spring.html'>spring</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14543968078787.html">
                    
                    <h1>`Connector`分析</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p><code>Connector</code>用于接受请求并将请求封装成<code>Request</code>和<code>Response</code>来具体处理，最底层是使用<code>Socket</code>来进行连接的，<code>Request</code>和<code>Response</code>是按照<code>HTTP协议</code>来封装的，所以<code>Connector</code>同时实现了<code>TCP/IP</code>协议和<code>HTTP</code>协议。</p>

<p><code>Request</code>和<code>Response</code>封装之后交给<code>Container</code>进行处理。<code>Container</code>就是<code>Servlet</code>的容器。</p>

<p><code>Container</code>处理完之后返回给<code>Connector</code>，最后<code>Connector</code>使用<code>Socket</code>将处理结果返回给客户端，这样整个请求就处理完了。</p>

<h4 id="toc_0"><code>Connector</code>的结构</h4>

<p><code>Connector</code>中具体是用<code>ProtocolHandler</code>来处理请求的，不同的<code>ProtocolHandler</code>代表不同的连接类型。</p>

<p><code>ProtocolHandler</code>里面有3个非常重要的组件：<code>Endpoint</code>、<code>Processor</code>和<code>Adapter</code>。<br/>
- <code>Endpoint</code>用于处理底层<code>Socket</code>的网络连接 - 用来实现<code>TCP/IP</code>协议<br/>
- <code>Processor</code>用于将<code>Endpoint</code>接收到的<code>Socket</code>封装成<code>Request</code> - 用来实现<code>HTTP</code>协议<br/>
- <code>Adapter</code>用于将封装好的<code>Request</code>交给<code>Container</code>进行具体处理 - 将请求适配到<code>Servlet</code>容器进行具体处理</p>

<p><code>Endpoint</code>的抽象实现<code>AbstractEndpoint</code>里面定义的<code>Acceptor</code>和<code>AsyncTimeout</code>两个内部类和一个<code>Handler</code>接口。<code>Acceptor</code>用于监听请求，<code>AsyncTimeout</code>用于检查异步<code>request</code>的超时，<code>Handler</code>用于处理接收到的<code>Socket</code>，在内部调用了<code>Processor</code>进行处理。</p>

<p><code>Connector</code>的使用方法是通过<code>Connector</code>标签配置在<code>conf/server.xml</code>文件中，所以<code>Connector</code>是在<code>Catalina</code>的<code>load</code>方法中根据<code>conf/server.xml</code>配置文件创建<code>Server</code>对象时创建的。<code>Connector</code>的生命周期方法是在<code>Service</code>中调用的。</p>

<p><code>Connector</code>的创建过程主要是初始化<code>ProtocolHandler</code>。<code>server.xml</code>配置文件中<code>Connector</code>标签的<code>protocol</code>属性会设置到<code>Connector</code>构造函数的参数中。</p>

<p><code>Connector</code>的生命周期处理方法中主要调用了<code>ProtocolHandler</code>的相应生命周期方法。<br/>
- 在<code>initInternal</code>方法中首先新建了一个<code>Adapter</code>并设置到<code>ProtocolHandler</code>中，然后对<code>ProtocolHandler</code>进行初始化；<br/>
- 在<code>startInternal</code>方法中首先判断设置的端口是否小于0，如果小于0就抛出异常，否则就调用<code>ProtocolHandler</code>的<code>start</code>方法来启动；<br/>
- 在<code>stopInternal</code>方法中先设置了生命周期状态，然后调用了<code>ProtocolHandler</code>的<code>stop</code>方法；<br/>
- 在<code>destroyInternal</code>方法中除了调用<code>ProtocolHandler</code>的<code>destroy</code>方法，还会将当前的<code>Connector</code>从<code>Service</code>中剔除并调用父类的<code>destroyInternal</code>方法。</p>

<p>Endpoint用于处理具体连接和传输数据</p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/2/2</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='tomcat.html'>tomcat</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            
            <div class="article">
                <a class="clearlink" href="14536837472407.html">
                    
                    <h1>深入分析Volatile的实现原理</h1>

                    <div class="a-content">
                        
                        <div class="a-content-text">
                            
                            <p><code>Volatile</code>是轻量级的<code>synchronized</code>，它在多处理器开发中保证了共享变量的可见性。它在某些情况下比<code>synchronized</code>的开销更小（因为它不会引起线程上下文的切换和调度）。</p>

<p>可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p>

<p><code>Java</code>编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。<code>Java</code>提供了<code>Volatile</code>，在某些情况下比锁更加方便。如果一个字段被声明成<code>Volatile</code>，<code>Java</code>线程内存模型确保所有线程看到这个变量的值是一致的。</p>

<pre><code>Java代码： 
instance = new Singleton();//instance是volatile变量

汇编代码：   
0x01a3de1d: movb $0×0,0×1104800(%esi);
0x01a3de24: lock addl $0×0,(%esp);
</code></pre>

<p>有<code>volatile</code>变量修饰的共享变量进行写操作的时候会多第二行汇编代码，<code>lock</code>前缀的指令在多核处理器下会引发两件事情：<br/>
- 将当前处理器缓存行的数据写回到系统内存<br/>
- 这个歇会内存的操作会引起其他<code>CPU</code>里缓存该内存地址的数据无效</p>

<p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（<code>L1</code>，<code>L2</code>或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了<code>volatile</code>变量进行写操作，<code>JVM</code>就会向处理器发送一条<code>Lock</code>前缀的指令，将这个变量所在的缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。</p>

<p>所以在多处理器下，<strong>为了保证每个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线程上传播的数据来检查自己缓存的值是不是过期了</strong>，当处理器发现自动缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存把数据读到处理器缓存里。</p>

                            
                        </div>
                    </div>
                </a>

                <div class="read-more clearfix">
                    <div class="more-left left">
                        
                        <span class="date">2016/1/25</span>
                        <span>posted in&nbsp;</span> 
                        
                        <span class="posted-in"><a href='Java.html'>Java</a></span>
                        
                    </div>
                    <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                    </div>
                </div>
            </div>
            <!-- article -->
            


            <div class="row">
                <div class="large-6 columns">
                    <p class="text-left" style="padding-top:25px;">
                         <a href="all_12.html">&laquo; Prev Page</a> 
                    </p>
                </div>
                <div class="large-6 columns">
                    <p class="text-right" style="padding-top:25px;">
                         <a href="all_14.html">&raquo; Next Page</a> 
                    </p>
                </div>
            </div>
        </div>
    </div>
    <!-- large 8 -->

 <div class="large-4 medium-4 columns">
    <div class="hide-for-small">
        <div id="sidebar" class="sidebar">
            <div id="site-info" class="site-info">
                
                <h1>NathanCHEN</h1>

                <div class="site-des"></div>
                <div class="social">
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <a class="rss" href="atom.xml" title="RSS">RSS</a>

                </div>
            </div>
            <div id="site-categories" class="side-item ">
                <div class="side-header">
                    <h2>Contact</h2>
                </div>
                <div class="side-content">
                    <ul class="posts-list">
                        <li class="post">
                            <p class="email-addr">tringchen AT gmail.com</p>

                            <p class="email-addr">江苏 · 南京</p>
                        </li>
                    </ul>
                </div>
            </div>
            <div id="site-categories" class="side-item ">
                <div class="side-header">
                    <h2>Categories</h2>
                </div>
                <div class="side-content">

                    <p class="cat-list">
                        
                        <a href="Java.html"><strong>Java</strong></a>
                        
                        <a href="JavaScript.html"><strong>JavaScript</strong></a>
                        
                        <a href="Ngnix.html"><strong>Ngnix</strong></a>
                        
                        <a href="tomcat.html"><strong>tomcat</strong></a>
                        
                        <a href="spring.html"><strong>spring</strong></a>
                        
                        <a href="RabbitMQ.html"><strong>RabbitMQ</strong></a>
                        
                        <a href="ELK.html"><strong>ELK</strong></a>
                        
                        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
                        
                        <a href="%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"><strong>源码阅读</strong></a>
                        
                        <a href="others.html"><strong>others</strong></a>
                        
                        <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
                        
                        <a href="PAXOS.html"><strong>PAXOS</strong></a>
                        
                        <a href="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html"><strong>深入分析Java Web技术内幕</strong></a>
                        
                        <a href="Java7%20Concurrency%20Cookbook.html"><strong>Java7 Concurrency Cookbook</strong></a>
                        
                        <a href="GoogleDevelopersWebFundamentals.html"><strong>GoogleDevelopersWebFundamentals</strong></a>
                        
                    </p>


                </div>
            </div>

            <div id="site-categories" class="side-item">
                <div class="side-header">
                    <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                    <ul class="posts-list">
                        
                        
                        <li class="post">
                            <a href="14608176804744.html">HTTP/2</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14606892007159.html">Web页面缓存</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14606396114001.html">Java中的Object对象</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14606028630903.html">深入Class文件结构</a>
                        </li>
                        
                        
                        
                        <li class="post">
                            <a href="14605288849994.html">Thread Synchronization Utilities</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                </div>
            </div>
        </div>
        <!-- sidebar -->
    </div>
    <!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->
 <div class="page-bottom clearfix">
    <div class="row">
        <p class="copyright">Copyright &copy; 2016
            Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp;
            Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
    </div>
</div>
</section>
</div>
</div>




<script src="asset/js/foundation.min.js"></script>
<script>
    $(document).foundation();
    function fixSidebarHeight() {
        var w1 = $('.markdown-body').height();
        var w2 = $('#sidebar').height();
        if (w1 > w2) {
            $('#sidebar').height(w1);
        }
        ;
    }
    $(function () {
        fixSidebarHeight();
    })
    $(window).load(function () {
        fixSidebarHeight();
    });

</script>





</body>
</html>
