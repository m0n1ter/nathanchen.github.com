<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	数据库 - NathanCHEN
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html">NathanCHEN</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-27T00:30:44+08:00" itemprop="datePublished">2016/3/27</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			
			    <a class='category' href='Ngnix.html'>Ngnix</a>&nbsp;
			
			    <a class='category' href='PAXOS.html'>PAXOS</a>&nbsp;
			
			    <a class='category' href='spring.html'>spring</a>&nbsp;
			
			    <a class='category' href='JavaScript.html'>JavaScript</a>&nbsp;
			
			    <a class='category' href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a>&nbsp;
			
			    <a class='category' href='%E7%AE%97%E6%B3%95.html'>算法</a>&nbsp;
			
			    <a class='category' href='others.html'>others</a>&nbsp;
			
			    <a class='category' href='%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html'>源码阅读</a>&nbsp;
			
			    <a class='category' href='tomcat.html'>tomcat</a>&nbsp;
			
			    <a class='category' href='TCP/IP.html'>TCP/IP</a>&nbsp;
			
			    <a class='category' href='%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html'>深入分析Java Web技术内幕</a>&nbsp;
			
			    <a class='category' href='ELK.html'>ELK</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14590098445355.html" itemprop="url">
		应用多级缓存模式支撑海量读服务</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">如何缓存数据</h3>

<h4 id="toc_1">过期与不过期</h4>

<p>不过期缓存的场景一般思路如下：</p>

<p><img src="media/14590098445355/14590098715786.jpg" alt=""/></p>

<p>首先写数据库，如果成功则写缓存。这种机制存在一些问题：</p>

<ul>
<li>事务在提交时失败则写缓存是不会回滚的，造成DB和缓存数据不一致</li>
<li>多个人并发写缓存可能出现脏数据</li>
<li>同步写对性能有一定影响，异步写又存在丢数据的风险</li>
</ul>

<p>如果对缓存数据一致性要求不是那么高，数据量也不是很大，可以考虑定期全量同步缓存。</p>

<p><img src="media/14590098445355/14590100613107.jpg" alt=""/></p>

<ol>
<li>把写缓存改成写消息，通过消息通知数据变更</li>
<li>同步缓存系统会订阅消息，并根据消息进行更新缓存</li>
<li>数据一致性可以采用：消息体只包括ID，然后查库获取最新版本数据；通过时间戳和内容摘要机制（MD5）进行缓存更新</li>
<li>如上方法也不能保证消息不丢失，可以采用：应用在本地记录更新日志，当消息丢失了，回放更新日志</li>
</ol>

<p>过期缓存机制的常见步骤是：首先读取缓存，如果不命中，则查询数据，然后异步写入缓存并设置过期时间，下次读取将命中缓存。</p>

<h3 id="toc_2">Reference</h3>

<p><a href="http://jinnianshilongnian.iteye.com/blog/2283670">http://jinnianshilongnian.iteye.com/blog/2283670</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-25T14:01:42+08:00" itemprop="datePublished">2016/3/25</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14588857020339.html" itemprop="url">
		高性能MySQL - 创建高性能的索引</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">索引基础</h3>

<p>索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为<strong>MySQL只能高效地使用索引的最左前缀列</strong>。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。</p>

<h4 id="toc_1">索引的类型</h4>

<h5 id="toc_2">B-Tree索引</h5>

<p>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-25T09:48:35+08:00" itemprop="datePublished">2016/3/25</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14588705157449.html" itemprop="url">
		`MySQL`索引原理及慢查询优化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">MySQL索引原理</h3>

<h4 id="toc_1">索引目的</h4>

<p>在于提高查询效率，可以类比字典，如果要查<code>mysql</code>这个单词，我们肯定需要定位到<code>m</code>字母，然后从下往上找到<code>y</code>字母，再找到剩下的<code>sql</code>。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的。</p>

<h4 id="toc_2">索引原理</h4>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-21T21:40:47+08:00" itemprop="datePublished">2016/3/21</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14585676478158.html" itemprop="url">
		高性能MySQL - Schema与数据类型优化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">选择优化的数据类型</h3>

<h4 id="toc_1">字符串类型</h4>

<h5 id="toc_2">VARCHAR</h5>

<p><code>VARCHAR</code>类型用于存储可变长字符串。它比定长类型更节省空间，因为它仅使用必要的空间。</p>

<p><code>VARCHAR</code>需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示；否则使用2个字节。</p>

<h5 id="toc_3">CHAR</h5>

<p><code>CHAR</code>类型是定长的：<code>MySQL</code>总是根据定义的字符串长度分配足够的空间。当存储<code>CHAR</code>值时，<code>MySQL</code>会删除所有的末尾空格。</p>

<p><code>CHAR</code>适合存储很短的字符串，或者所有值都接近同一个长度。；对于经常变更的数据，<code>CHAR</code>也比<code>VARCHAR</code>更好，因为定长的<code>CHAR</code>类型不容易产生碎片。对于非常短的列，<code>CHAR</code>比<code>VARCHAR</code>在存储空间上也更有效率。</p>

<h4 id="toc_4">日期和时间类型</h4>

<p>除了特殊情况，通常应该尽量使用<code>TIMESTAMP</code>，因为它比<code>DATETIME</code>空间效率更高。</p>

<h4 id="toc_5">特殊类型数据</h4>

<p>人们经常使用<code>VARCHAR(15)</code>列来存储<code>IP</code>地址。然而，它们实际上是32位无符号整数，不是字符串。用小数点将地址分成四段的表示方法只是为了让人们阅读容易。所以应该用无符号整数存储<code>IP</code>地址。</p>

<h3 id="toc_6">范式和反范式</h3>

<h4 id="toc_7">范式的优点和缺点</h4>

<p><strong>范式化通常能够带来的好处</strong>：</p>

<ul>
<li>范式化的更新操作通常比反范式化要快</li>
<li>当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据</li>
<li>范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快</li>
<li>很少有多余的数据意味着检索列表数据时更少需要<code>DISTINCT</code>或者<code>GROUP BY</code>语句。</li>
</ul>

<p><strong>范式化设计的<code>schema</code>的缺点是通常需要关联</strong>。稍微复杂一些的查询语句在符合范式的<code>schema</code>上都可能需要至少一次关联，也许更多。</p>

<h4 id="toc_8">反范式的优点和缺点</h4>

<p>反范式化的<code>schema</code>因为所有数据都在一张表中，可以很好地避免关联。</p>

<p>如果不需要关联表，则对大部分查询最差的情况——即使表没有使用索引——是全表扫描。当数据比内存大时，这可能比关联要快得多，因为这样避免了随机I/O。</p>

<blockquote>
<p>混用范式化和反范式化</p>
</blockquote>

<h3 id="toc_9">加快ALTER TABLE操作的速度</h3>

<p>不是所有的<code>ALTER TABLE</code>操作都会引起表重建。例如，有两种方法可以改变或者删除一个列的默认值（一种方法很快，另一种则很慢）。</p>

<p>假如要修改电影的默认租赁期限，从三天改到五天。下面是很慢的方式：</p>

<pre><code class="language-sql">ALTER TABLE sakila.film
MODIFY COLUMN rental_duration TINYINT(3) NOT NULL DEFAULT 5;
</code></pre>

<p><code>SHOW STATUS</code>显示这个语句做了1000次读和1000次插入操作。换句话说，它拷贝了整张表到一张新表，甚至列的类型、大小和可否为<code>NULL</code>属性都没改变。</p>

<p>另外一种方法是通过<code>ALTER COLUMN</code>操作来改变列的默认值：</p>

<pre><code class="language-sql">ALTER TABLE sakila.film
ALTER COLUMN rental_duration SET DEFAULT 5;
</code></pre>

<p>这个语句会直接修改<code>.frm</code>文件而不涉及表数据。所以，这个操作是非常快的。</p>

<h4 id="toc_10">只修改.frm文件</h4>

<p>下面这些操作是有可能不需要重建表的：</p>

<ul>
<li>移除（不是增加）一个列的<code>AUTO_INCREMENT</code>属性</li>
<li>增加、移除，或更改<code>ENUM</code>和<code>SET</code>常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字符串值</li>
</ul>

<p>基本的技术是为想要的表结构创建一个新的<code>.frm</code>文件，然后用它替换掉已经存在的那张表的<code>.frm</code>文件，像下面这样：</p>

<ul>
<li>创建一张有相同结构的空表，并进行所需要的修改</li>
<li>执行<code>FLUSH TABLES WITH READ LOCK</code>。这将会关闭所有正在使用的表，并且禁止任何表被打开。</li>
<li>交换<code>.frm</code>文件</li>
<li>执行<code>UNLOCK TABLES</code>来释放第二步的读锁</li>
</ul>

<h4 id="toc_11">快速创建<code>MyISAM</code>索引</h4>

<p>为了高效地载入数据到MyISAM表中，有一个常用的技巧是先禁用、载入数据，然后重新启用索引：</p>

<pre><code>ALTER TABLE test.load_data DISABLE KEYS;
-- load the data
ALTER TABLE test.load_data ENABLE KEYS;
</code></pre>

<p>这个技巧能够发挥作用，是因为构建索引的工作被延迟到数据完全载入以后，这个时候已经可以通过排序来构建索引了。这样做会快很多，并且使得索引树的碎片更少、更紧凑。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-21T17:17:22+08:00" itemprop="datePublished">2016/3/21</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14585518429633.html" itemprop="url">
		高性能MySQL - MySQL架构与历史</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4 id="toc_0">连接管理与安全性</h4>

<p>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销魂线程。</p>

<h4 id="toc_1">优化与执行</h4>

<p>MySQL会解析查询，并 创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置。</p>

<p>对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（Query Cache），如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</p>

<h4 id="toc_2">读写锁</h4>

<p>读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取统一资源，而互不干扰。</p>

<p>写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。</p>

<h4 id="toc_3">锁粒度</h4>

<p>一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。</p>

<h5 id="toc_4">表锁</h5>

<p>MySQL最基本的锁策略，并且是开销最小的策略。</p>

<p>一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。</p>

<h5 id="toc_5">行级锁</h5>

<p>最大程度地支持并发处理，同时也带来了最大的锁开销。</p>

<h4 id="toc_6">死锁</h4>

<p>InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</p>

<p>死锁发生以后，只有部分或者完全回滚其中一个事务。</p>

<h4 id="toc_7">事务日志</h4>

<p>使用事务日志，存储引擎在修改表的数据时，只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到硬盘。</p>

<p>事务日志采用的是追加的方式，因此写日志的操作是磁盘上的一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方法相对来说要快得多。</p>

<p>事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到硬盘。</p>

<p>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。</p>

<h4 id="toc_8">MySQL的事务</h4>

<p>MySQL默认采用自动提交模式。</p>

<h5 id="toc_9">隐式和显式锁定</h5>

<p>InnoDB采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。</p>

<h4 id="toc_10">多版本并发控制</h4>

<p>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>

<p>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。</p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	 <a class="next" href="数据库_1.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>