<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	others - NathanCHEN
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html">NathanCHEN</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-27T00:30:44+08:00" itemprop="datePublished">2016/3/27</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			
			    <a class='category' href='Ngnix.html'>Ngnix</a>&nbsp;
			
			    <a class='category' href='PAXOS.html'>PAXOS</a>&nbsp;
			
			    <a class='category' href='spring.html'>spring</a>&nbsp;
			
			    <a class='category' href='JavaScript.html'>JavaScript</a>&nbsp;
			
			    <a class='category' href='%E6%95%B0%E6%8D%AE%E5%BA%93.html'>数据库</a>&nbsp;
			
			    <a class='category' href='%E7%AE%97%E6%B3%95.html'>算法</a>&nbsp;
			
			    <a class='category' href='others.html'>others</a>&nbsp;
			
			    <a class='category' href='%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html'>源码阅读</a>&nbsp;
			
			    <a class='category' href='tomcat.html'>tomcat</a>&nbsp;
			
			    <a class='category' href='TCP/IP.html'>TCP/IP</a>&nbsp;
			
			    <a class='category' href='%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95.html'>深入分析Java Web技术内幕</a>&nbsp;
			
			    <a class='category' href='ELK.html'>ELK</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14590098445355.html" itemprop="url">
		应用多级缓存模式支撑海量读服务</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">如何缓存数据</h3>

<h4 id="toc_1">过期与不过期</h4>

<p>不过期缓存的场景一般思路如下：</p>

<p><img src="media/14590098445355/14590098715786.jpg" alt=""/></p>

<p>首先写数据库，如果成功则写缓存。这种机制存在一些问题：</p>

<ul>
<li>事务在提交时失败则写缓存是不会回滚的，造成DB和缓存数据不一致</li>
<li>多个人并发写缓存可能出现脏数据</li>
<li>同步写对性能有一定影响，异步写又存在丢数据的风险</li>
</ul>

<p>如果对缓存数据一致性要求不是那么高，数据量也不是很大，可以考虑定期全量同步缓存。</p>

<p><img src="media/14590098445355/14590100613107.jpg" alt=""/></p>

<ol>
<li>把写缓存改成写消息，通过消息通知数据变更</li>
<li>同步缓存系统会订阅消息，并根据消息进行更新缓存</li>
<li>数据一致性可以采用：消息体只包括ID，然后查库获取最新版本数据；通过时间戳和内容摘要机制（MD5）进行缓存更新</li>
<li>如上方法也不能保证消息不丢失，可以采用：应用在本地记录更新日志，当消息丢失了，回放更新日志</li>
</ol>

<p>过期缓存机制的常见步骤是：首先读取缓存，如果不命中，则查询数据，然后异步写入缓存并设置过期时间，下次读取将命中缓存。</p>

<h3 id="toc_2">Reference</h3>

<p><a href="http://jinnianshilongnian.iteye.com/blog/2283670">http://jinnianshilongnian.iteye.com/blog/2283670</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-26T21:27:11+08:00" itemprop="datePublished">2016/3/26</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='others.html'>others</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14589988314853.html" itemprop="url">
		浅谈Web缓存</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">浏览器缓存</h3>

<h4 id="toc_1">Cache-Control</h4>

<p>1、<code>max-age</code>（单位为<code>s</code>）当浏览器向服务器发送请求后，在<code>max-age</code>这段时间里浏览器就不会再向服务器发送请求了。<code>max-age</code>会覆盖掉<code>Expires</code>。</p>

<pre><code>max-age=2592000
</code></pre>

<p>也就是说缓存有效期为2592000秒（也就是30天）。于是在30天内都会使用这个版本的资源，即使服务器上的资源发生了变化，浏览器也不会得到通知。</p>

<p>2、<code>s-maxage</code>（单位为<code>s</code>），只用于共享缓存（比如<code>CDN</code>）</p>

<pre><code>s-maxage=60
</code></pre>

<p>在这60秒中，即使更新了<code>CDN</code>的内容，浏览器也不会进行请求。如果存在<code>s-maxage</code>，则会覆盖掉<code>max-age</code>和<code>Expires header</code>。</p>

<p>3、<code>public</code>指定响应会被缓存，并且在多用户间共享。如果没有指定<code>public</code>还是<code>private</code>，则默认为<code>public</code></p>

<p>4、<code>private</code>响应只作为私有的缓存，不能在用户间共享。</p>

<p>5、<code>no-cache</code>指定不缓存响应，表明资源不进行缓存。设置了<code>no-cache</code>之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置<code>no-cache</code>防止缓存还是不够保险，还可以加上<code>private</code>指令，将过期时间设为过去的时间。</p>

<p>6、<code>no-store</code>绝对禁止缓存</p>

<h4 id="toc_2">Expires</h4>

<p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，<code>Expires = max-age + 请求时间</code>，需要和<code>Last-modified</code>结合使用。</p>

<h4 id="toc_3">Last-modified</h4>

<p>服务器端文件的最后修改时间，需要和<code>cache-control</code>共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送<code>If-Modified-Since</code>报头，询问<code>Last-Modified</code>时间点之后资源是否被修改过。如果没有修改，则返回码为<code>304</code>，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为<code>200</code>，资源为服务器最新资源。</p>

<h4 id="toc_4">ETag</h4>

<p>根据实体内容生成一段<code>hash</code>字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改</p>

<p><img src="media/14589988314853/14589994585073.jpg" alt=""/></p>

<p>使用<code>ETag</code>可以解决<code>Last-modified</code>存在的一些问题：</p>

<ul>
<li>某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 </li>
<li>如果资源修改非常频繁，在秒以下的时间内进行修改，而<code>Last-modified</code>只能精确到秒 </li>
<li>一些资源的最后修改时间改变了，但是内容没改变，使用<code>ETag</code>就认为资源还是没有修改的。</li>
</ul>

<h3 id="toc_5">使用缓存流程</h3>

<p><img src="media/14589988314853/14589996373194.jpg" alt=""/></p>

<h3 id="toc_6">其他</h3>

<p><code>LocalStorage</code>是一种本地存储的公共资源，域名下很多应用共享这份资源会有风险；<code>LocalStorage</code>是以页面域名划分的，如果有多个等价域名之间的<code>LocalStorage</code>不互通，则会造成缓存多份浪费。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-25T10:36:08+08:00" itemprop="datePublished">2016/3/25</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='others.html'>others</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14588733684599.html" itemprop="url">
		搜索引擎关键字智能提示的一种实现</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">解决方案</h3>

<h5 id="toc_1">关键字收集</h5>

<p>当用户输入一个前缀时，碰到提示的候选词很多的时候，如何取舍，哪些展示在前面，哪些展示在后面？</p>

<p>用户在使用搜索引擎查找商家时，会输入大量的关键字，每一次输入就是对关键字的一次投票，那么关键字被输入的次数越多，它对应的查询就比较热门，所以需要查询的关键字记录下来，并且统计出每个关键字的频率，方便提示结果按照频率排序。</p>

<p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来。</p>

<h5 id="toc_2">拼音缩写提取</h5>

<p><code>chongqing</code>, <code>zhongqing</code> -&gt; <code>cq</code>, <code>zq</code></p>

<h3 id="toc_3">索引与前缀查询</h3>

<h4 id="toc_4">方案一：Trie树 + TopK算法</h4>

<p><strong>Trie树</strong>即字典树，又称单词查找树或键树，是一种树形结构，一种哈希树的变种。</p>

<p>它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p>

<p><img src="media/14588733684599/14588739187774.jpg" alt=""/></p>

<p>从上图可知，当用户输入前缀<code>i</code>的时候，搜索框可能会展示以<code>i</code>为前缀的<code>in</code>，<code>inn</code>，<code>int</code>等关键词，再当用户输入前缀<code>a</code>的时候，搜索框里面可能会提示以<code>a</code>为前缀的<code>ate</code>等关键词。如此，实现搜索引擎智能提示<code>suggestion</code>的第一个步骤便清晰了</p>

<p><strong>TopK算法</strong>用于解决统计热词的问题。解决TopK问题主要有两种策略：HashMap统计+排序（堆排序）。</p>

<p><code>HashMap</code>统计：先对这批海量数据预处理。具体方法是：维护一个<code>Key</code>为<code>Query</code>字串，<code>Value</code>为该<code>Query</code>出现次数的<code>HashMap</code>。</p>

<p><strong>该方案存在的问题</strong>是：</p>

<ul>
<li>需要维护拼音、缩写两棵<code>Trie</code>树。</li>
</ul>

<h4 id="toc_5">方案二：<code>Solr</code>自带<code>Suggest</code>智能提示</h4>

<p><strong>该方案存在的问题</strong>是：</p>

<ul>
<li>返回的结果是基于索引中字段的词频进行排序，不是用户搜索关键字的频率，因此不能将一些热门关键字排在前面。</li>
<li>拼音提示，多音字，缩写还是要另外加索引字段。</li>
</ul>

<h4 id="toc_6">方案三 <code>Solrcloud</code>建立单独的<code>collection</code>,利用<code>Solr</code>前缀查询实现</h4>

<p>专门为关键字建立一个索引<code>collection</code>，利用<code>Solr</code>前缀查询实现。<code>Solr</code>中的<code>copyField</code>能很好解决我们同时索引多个字段(汉字、<code>pinyin</code>, <code>abbre</code>)的需求，且<code>field</code>的<code>multiValued</code>属性设置为<code>true</code>时能解决同一个关键字的多音字组合问题。</p>

<h3 id="toc_7">Reference</h3>

<p><a href="http://tech.meituan.com/pinyin-suggest.html">http://tech.meituan.com/pinyin-suggest.html</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-23T15:14:46+08:00" itemprop="datePublished">2016/3/23</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='others.html'>others</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14587172862630.html" itemprop="url">
		倒排索引及`tf-idf`算法简介</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h1 id="toc_0">倒排索引简介</h1>

<p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(<code>inverted index</code>)。带有倒排索引的文件我们称为倒排索引文件，简称倒排文件(<code>inverted file</code>)。</p>

<p>倒排文件（倒排索引），索引对象是文档或者文档集合中的单词等，用来存储这些单词在一个文档或者一组文档中的存储位置，是对文档或者文档集合的一种最常用的索引机制。</p>

<p>搜索引擎的关键步骤就是建立倒排索引，倒排索引一般表示为一个关键词，然后是它的频度（出现的次数），位置（出现在哪一篇文章或网页中，及有关的日期，作者等信息），它相当于为互联网上几千亿页网页做了一个索引，<strong>好比一本书的目录、标签一般</strong>。读者想看哪一个主题相关的章节，直接根据目录即可找到相关的页面。不必再从书的第一页到最后一页，一页一页的查找。</p>

<h2 id="toc_1">Lucene倒排索引原理</h2>

<p>Lucene是一个开放源代码的高性能的Java全文检索引擎工具包，不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。目的是为软件开发人员提供一个简单易用的工具包，以方便在目标系统中实现全文检索的功能，或者以此为基础建立起完整的全文检索引擎。</p>

<p>Lucene使用的是倒排文件索引结构。该结构及相应的生成算法如下：  　　</p>

<p>设有两篇文章1和2：</p>

<p>文章1的内容为：</p>

<pre><code>    Tom lives in Guangzhou, I live in Guangzhou too.
</code></pre>

<p>文章2的内容为：</p>

<pre><code>    He once lived in Shanghai.
</code></pre>

<h3 id="toc_2">取得关键词</h3>

<p>由于Lucene是基于关键词索引和查询的，首先我们要取得这两篇文章的关键词，通常我们需要如下处理措施： 　　</p>

<ul>
<li><p>我们现在有的是文章内容，即一个字符串，我们先要找出字符串中的所有单词，即<strong>分词</strong>。英文单词由于用空格分隔，比较好处理。中文单词间是连在一起的需要特殊的分词处理 　 　</p></li>
<li><p><strong>去掉没有意义的大众词汇</strong>。文章中的<code>in</code>, <code>once</code>, <code>too</code>等词没有什么实际意义，中文中的<code>的</code>、<code>是</code>等字通常也无具体含义，这些不代表概念的词可以过滤掉 　　</p></li>
<li><p>用户通常希望查<code>He</code>时能把含<code>he</code>，<code>HE</code>的文章也找出来，所以所有单词需要<strong>统一大小写</strong>。 　　</p></li>
<li><p><strong>单词的统一化</strong>。用户通常希望查<code>live</code>时能把含<code>lives</code>，<code>lived</code>的文章也找出来，所以需要把<code>lives</code>，<code>lived</code>还原成<code>live</code> 　　</p></li>
<li><p>文章中的<strong>标点符号</strong>通常不表示某种概念，也可以过滤掉 　　</p></li>
</ul>

<p>在Lucene中以上措施由<code>Analyzer</code>类完成。 经过上面处理后，</p>

<p>文章1的所有关键词为：</p>

<pre><code>    [tom] [live] [guangzhou] [i] [live] [guangzhou]
</code></pre>

<p>文章2的所有关键词为：</p>

<pre><code>    [he] [live] [shanghai]
</code></pre>

<h3 id="toc_3">建立倒排索引</h3>

<p>有了关键词后，我们就可以建立倒排索引了。上面的对应关系是：<code>文章号</code>对<code>文章中所有关键词</code>。倒排索引把这个关系倒过来，变成: <code>关键词</code>对<code>拥有该关键词的所有文章号</code>。</p>

<p>文章1，2经过倒排后变成 　　</p>

<pre><code>关键词            文章号 　　
guangzhou        1
he               2 
i                1 
live             1,2
shanghai         2
tom              1 
</code></pre>

<p><strong>通常仅知道关键词在哪些文章中出现还不够，我们还需要知道关键词在文章中出现次数和出现的位置</strong>，通常有两种位置：</p>

<ul>
<li><p>字符位置，即记录该词是文章中第几个字符（优点是关键词亮显时定位快）</p></li>
<li><p>关键词位置，即记录该词是文章中第几个关键词（优点是节约索引空间、词组（phase）查询快），lucene中记录的就是这种位置　　</p></li>
</ul>

<p>加上<code>出现频率</code>和<code>出现位置</code>信息后，我们的索引结构变为： 　　</p>

<pre><code>关键词               文章号[出现频率]            出现位置 
guangzhou           1[2]                      3, 6 　
he                  2[1]                      1
i                   1[1]                      4
live                1[2]                      2, 5
                    2[1]                      2 
shanghai            2[1]                      3
tom                 1[1]                      1 
</code></pre>

<p>以<code>live</code>这行为例我们说明一下该结构：<code>live</code>在<code>文章1</code>中出现了2次，<code>文章2</code>中出现了一次，它的出现位置为<code>2,5,2</code>这表示什么呢？我们需要结合文章号和出现频率来分析，<code>文章1</code>中出现了2次，那么<code>2,5</code>就表示<code>live</code>在<code>文章1</code>中出现的两个位置，<code>文章2</code>中出现了一次，剩下的<code>2</code>就表示<code>live</code>是<code>文章2</code>中第2个关键字。 　　</p>

<p>以上就是Lucene索引结构中最核心的部分。我们注意到关键字是按字符顺序排列的（Lucene没有使用B树结构），因此Lucene可以用二元搜索算法快速定位关键词。</p>

<h3 id="toc_4">实现</h3>

<p>实现时，Lucene将上面三列分别作为词典文件<code>（Term Dictionary）</code>、频率文件<code>(frequencies)</code>、位置文件<code>(positions)</code>保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。 　　</p>

<p>Lucene中使用了<code>field</code>的概念，用于表达信息所在位置（如标题中，文章中，url中），在建索引中，该<code>field</code>信息也记录在词典文件中，每个关键词都有一个<code>field</code>信息(因为每个关键字一定属于一个或多个<code>field</code>)。</p>

<h3 id="toc_5">压缩算法</h3>

<p>为了减小索引文件的大小，Lucene对索引还使用了压缩技术。</p>

<p>首先，<strong>对词典文件中的关键词进行了压缩</strong>，关键词压缩为&lt;前缀长度，后缀&gt;</p>

<pre><code>    例如：当前词为“阿拉伯语”，上一个词为“阿拉伯”，那么“阿拉伯语”压缩为&lt;3，语&gt;。
</code></pre>

<p>其次大量用到的是<strong>对数字的压缩</strong>，<strong>数字只保存与上一个值的差值</strong>（这样可以减小数字的长度，进而减少保存该数字需要的字节数）。例如当前文章号是16389（不压缩要用3个字节保存），上一文章号是16382，压缩后保存7（只用一个字节）。</p>

<h3 id="toc_6">应用原因</h3>

<p>下面我们可以通过对该索引的查询来解释一下为什么要建立索引。 　　</p>

<p>假设要查询单词<code>live</code>，Lucene先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果。词典通常非常小，因而，整个过程的时间是毫秒级的。 　　</p>

<p>而用普通的顺序匹配算法，不建索引，而是对所有文章的内容进行字符串匹配，这个过程将会相当缓慢，当文章数目很大时，时间往往是无法忍受的。</p>

<h2 id="toc_7">TF-IDF及其算法</h2>

<p><code>TF-IDF（term frequency – inverted document frequency）</code>是一种用于资讯检索与资讯探勘的常用加权技术。<code>TF-IDF</code>是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。<strong>字词的重要性随着它在文件中出现的次数成正比增加</strong>，但同时会<strong>随着它在语料库中出现的频率成反比下降</strong>。TF-IDF加权的各种形式常被搜寻引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了TF-IDF以外，因特网上的搜寻引擎还会使用基于连结分析的评级方法，以确定文件在搜寻结果中出现的顺序。</p>

<h3 id="toc_8">原理</h3>

<p>在一份给定的文件里，<strong>词频 (term frequency, TF)</strong>指的是某一个给定的词语在该文件中出现的次数。<strong>这个数字通常会被归一化</strong>（分子一般小于分母区别于IDF），<strong>以防止它偏向长的文件</strong>。（同一个词语在长文件里可能会比短文件有更高的词频，而不管该词语重要与否。）</p>

<p><strong>逆向文件频率 (inverse document frequency, IDF)</strong>是一个词语普遍重要性的度量。某一特定词语的IDF，可以<strong>由总文件数目除以包含该词语之文件的数目，再将得到的商取对数</strong>得到。</p>

<p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。</p>

<p><strong>TFIDF的主要思想是</strong>：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。TFIDF实际上是：<code>TF * IDF</code>，TF词频(Term Frequency)，IDF反文档频率(Inverse Document Frequency)。<strong>TF</strong>表示词条在文档d中出现的频率（另一说：TF词频(Term Frequency)指的是<strong>某一个给定的词语在该文件中出现的次数</strong>）。<strong>IDF的主要思想是：如果包含词条t的文档越少，也就是n越小，IDF越大</strong>，则说明词条t具有很好的类别区分能力。如果某一类文档C中包含词条t的文档数为m，而其它类包含t的文档总数为k，显然所有包含t的文档数n=m+k，当m大的时候，n也大，按照IDF公式得到的IDF的值会小，就说明该词条t类别区分能力不强。（另一说：IDF反文档频率(Inverse Document Frequency)是指果包含词条的文档越少，IDF越大，则说明词条具有很好的类别区分能力。）但是实际上，如果一个词条在一个类的文档中频繁出现，则说明该词条能够很好代表这个类的文本的特征，这样的词条应该给它们赋予较高的权重，并选来作为该类文本的特征词以区别与其它类文档。这就是IDF的不足之处.</p>

<p>在一份给定的文件里，<strong>词频（term frequency，TF）</strong>指的是某一个给定的词语在该文件中出现的频率。这个数字是对<strong>词数(term count)</strong>的归一化，以防止它偏向长的文件。（同一个词语在长文件里可能会比短文件有更高的词数，而不管该词语重要与否。）</p>

<p>对于在某一特定文件 d<sub>j</sub> 里的词语  t<sub>i</sub>  来说，它的重要性可表示为：</p>

<p><img src="media/14587172862630/14587192129158.jpg" alt=""/></p>

<blockquote>
<p>以上式子中 <img src="media/14587172862630/14587192460077.jpg" alt=""/><br/>
是该词在文件<img src="media/14587172862630/14587192606951.jpg" alt=""/><br/>
中的出现次数，而分母则是在文件<img src="media/14587172862630/14587192606951.jpg" alt=""/>中所有字词的出现次数之和。</p>
</blockquote>

<p><strong>逆向文件频率（inverse document frequency，IDF）</strong>是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到：</p>

<p><img src="media/14587172862630/14587193987421.jpg" alt=""/></p>

<p>其中</p>

<blockquote>
<ul>
<li><strong>|D|</strong>：语料库中的文件总数</li>
<li><img src="media/14587172862630/14587194172144.jpg" alt=""/>
：包含词语 <img src="media/14587172862630/14587194452522.jpg" alt=""/>
的文件数目（即 <img src="media/14587172862630/14587194565514.jpg" alt=""/>
的文件数目）如果该词语不在语料库中，就会导致被除数为零，因此一般情况下使用 <img src="media/14587172862630/14587194771634.jpg" alt=""/></li>
</ul>
</blockquote>

<p>然后</p>

<p><img src="media/14587172862630/14587195313386.jpg" alt=""/></p>

<blockquote>
<p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。</p>
</blockquote>

<h3 id="toc_9">示例</h3>

<h4 id="toc_10">示例一</h4>

<p>假如一篇文件的总词语数是100个，而词语<code>母牛</code>出现了3次，那么<code>母牛</code>一词在该文件中的词频<strong>tf就是3/100=0.03</strong>。一个计算文件频率 (DF) 的方法是测定有多少份文件出现过<code>母牛</code>一词，然后除以文件集里包含的文件总数。所以，如果<code>母牛</code>一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是 <strong>log(10,000,000 / 1,000)=4</strong>。最后的TF-IDF的分数为0.03 * 4=0.12。</p>

<h4 id="toc_11">示例二</h4>

<p><strong>根据关键字k1,k2,k3进行搜索结果的相关性就变成 TF1 x IDF1 + TF2 x IDF2 + TF3 x IDF3</strong>。比如document1的term总量为1000，k1,k2,k3在document1出现的次数是100，200，50。包含了 k1, k2, k3的docuement总量分别是 1000， 10000，5000。document set的总量为10000。 TF1 = 100/1000 = 0.1 TF2 = 200/1000 = 0.2 TF3 = 50/1000 = 0.05 IDF1 = log(10000/1000) = log(10) = 2.3 IDF2 = log(10000/100000) = log(1) = 0; IDF3 = log(10000/5000) = log(2) = 0.69 这样关键字k1,k2,k3与docuement1的相关性= <code>0.1*2.3 + 0.2*0 + 0.05*0.69 = 0.2645</code>其中k1比k3的比重在document1要大，k2的比重是0.</p>

<h4 id="toc_12">示例三</h4>

<p>在某个一共有一千词的网页中<code>原子能</code>、<code>的</code>和<code>应用</code>分别出现了2次、35次和5次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用” 相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,...,wN, 它们在一篇特定网页中的词频分别是: TF1, TF2, ..., TFN。 （TF: term frequency)。 那么，这个查询和该网页的相关性就是:TF1 + TF2 + ... + TFN。</p>

<p>读者可能已经发现了又一个漏洞。在上面的例子中，词<code>的</code>站了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫<strong><code>应删除词（Stopwords)</code></strong>，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删除词后，上述网页的相似度就变成了0.007，其中“原子能”贡献了 0.002，“应用”贡献了 0.005。细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词，而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：</p>

<blockquote>
<ol>
<li><p>一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次，对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。</p></li>
<li><p>应删除词的权重应该是零。</p></li>
</ol>
</blockquote>

<p>我们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们看到它仍然不很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键词 ｗ 在 Ｄｗ 个网页中出现过，那么 Ｄｗ 越大，ｗ的权重越小，反之亦然。在信息检索中，使用最多的权重是“逆文本频率指数” （Inverse document frequency 缩写为ＩＤＦ），它的公式为ｌｏｇ（Ｄ／Ｄｗ）其中Ｄ是全部网页数。比如，我们假定中文网页数是Ｄ＝１０亿，应删除词“的”在所有的网页中都出现，即Ｄｗ＝１０亿，那么它的ＩＤＦ＝log(10亿/10亿）= log (1) = ０。<strong>假如专用词<code>原子能</code>在两百万个网页中出现，即Ｄｗ＝２００万，则它的权重ＩＤＦ＝log(500) =6.2。又假定通用词<code>应用</code>，出现在五亿个网页中，它的权重ＩＤＦ = log(2)则只有 0.7。也就只说，在网页中找到一个<code>原子能</code>的比配相当于找到九个<code>应用</code>的匹配。</strong>利用 IDF，上述相关性计算个公式就由词频的简单求和变成了加权求和，即 <code>TF1*IDF1 +　TF2*IDF2 ＋... + TFN*IDFN</code>。在上面的例子中，该网页和“原子能的应用”的相关性为 0.0161，其中“原子能”贡献了 0.0126，而“应用”只贡献了0.0035。这个比例和我们的直觉比较一致了。</p>

<h3 id="toc_13">附录：ElasticSearch相关查询</h3>

<h5 id="toc_14">文档内容</h5>

<pre><code>curl -XGET &#39;172.168.5.110:9200/logstash-wap-2016.03.22/wap/AVOcKIIFPPR76qlEVfH2?pretty&#39;
</code></pre>

<p>结果</p>

<p>{<br/>
  <q>_index</q> : <q>logstash-wap-2016.03.22</q>,<br/>
  <q>_type</q> : <q>wap</q>,<br/>
  <q>_id</q> : <q>AVOcKIIFPPR76qlEVfH2</q>,<br/>
  <q>_version</q> : 1,<br/>
  <q>found</q> : true,<br/>
  <q>_source</q> : {<br/>
    <q>message</q> : <q>2016-03-22 10:30:12 - [ INFO ] [appName: wap] 172.168.5.224 - [cn.hao24.mobile.aop.RequestAOP] Beginning method: cn.hao24.mobile.controller.goods.GoodsController.getGoodsExtendDescAPP\tRequest end. This request cost [26 ms] time. =&gt; [SID: MasmqDCe1iFiullGvJWHPe8VIfzIJjeZk] [CustId: ] [CustIp: ] [OsVersion: ] [PhoneModel: ] V1</q>,<br/>
    <q>@version</q> : <q>1</q>,<br/>
    <q>@timestamp</q> : <q>2016-03-22T02:30:13.287Z</q>,<br/>
    <q>host</q> : <q>template-CentOS6.5</q>,<br/>
    <q>path</q> : <q>/hao24/logs/admin-log.log</q>,<br/>
    <q>timestamp</q> : <q>2016-03-22 10:30:12</q>,<br/>
    <q>loglevel</q> : <q>INFO</q>,<br/>
    <q>appName</q> : <q>wap</q>,<br/>
    <q>serverip</q> : <q>172.168.5.224</q>,<br/>
    <q>class</q> : <q>cn.hao24.mobile.aop</q>,<br/>
    <q>method</q> : <q>RequestAOP</q>,<br/>
    <q>status</q> : <q>Beginning method: cn.hao24.mobile.controller.goods.GoodsController.getGoodsExtendDescAPP\tRequest end. This request cost [26 ms] time.</q>,<br/>
    <q>sid</q> : <q>MasmqDCe1iFiullGvJWHPe8VIfzIJjeZk</q><br/>
  }<br/>
}</p>

<h5 id="toc_15">查看Status字段分词</h5>

<pre><code>curl -XPOST &#39;172.168.5.110:9200/logstash-wap-2016.03.22/_analyze?pretty&#39; -d &#39;
{
    &quot;text&quot;: &quot;Beginning method: cn.hao24.mobile.controller.category.CategoryController.listAjax  Request end. This request cost [268 ms] time.&quot;
}&#39;
</code></pre>

<h5 id="toc_16">结果</h5>

<pre><code>{
  &quot;tokens&quot; : [ {
    &quot;token&quot; : &quot;beginning&quot;,
    &quot;start_offset&quot; : 0,
    &quot;end_offset&quot; : 9,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 0
  }, {
    &quot;token&quot; : &quot;method&quot;,
    &quot;start_offset&quot; : 10,
    &quot;end_offset&quot; : 16,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 1
  }, {
    &quot;token&quot; : &quot;cn.hao24&quot;,
    &quot;start_offset&quot; : 18,
    &quot;end_offset&quot; : 26,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 2
  }, {
    &quot;token&quot; : &quot;mobile.controller.category.categorycontroller.listajaxrequest&quot;,
    &quot;start_offset&quot; : 27,
    &quot;end_offset&quot; : 88,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 3
  }, {
    &quot;token&quot; : &quot;end&quot;,
    &quot;start_offset&quot; : 89,
    &quot;end_offset&quot; : 92,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 4
  }, {
    &quot;token&quot; : &quot;this&quot;,
    &quot;start_offset&quot; : 94,
    &quot;end_offset&quot; : 98,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 5
  }, {
    &quot;token&quot; : &quot;request&quot;,
    &quot;start_offset&quot; : 99,
    &quot;end_offset&quot; : 106,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 6
  }, {
    &quot;token&quot; : &quot;cost&quot;,
    &quot;start_offset&quot; : 107,
    &quot;end_offset&quot; : 111,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 7
  }, {
    &quot;token&quot; : &quot;268&quot;,
    &quot;start_offset&quot; : 113,
    &quot;end_offset&quot; : 116,
    &quot;type&quot; : &quot;&lt;NUM&gt;&quot;,
    &quot;position&quot; : 8
  }, {
    &quot;token&quot; : &quot;ms&quot;,
    &quot;start_offset&quot; : 117,
    &quot;end_offset&quot; : 119,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 9
  }, {
    &quot;token&quot; : &quot;time&quot;,
    &quot;start_offset&quot; : 121,
    &quot;end_offset&quot; : 125,
    &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
    &quot;position&quot; : 10
  } ]
}
</code></pre>

<h5 id="toc_17">TF-IDF分值</h5>

<pre><code>curl -XGET &#39;172.168.5.110:9200/logstash-wap-2016.03.22/wap/AVOcKIIFPPR76qlEVfH2/_explain?pretty&#39; -d &#39;{
      &quot;query&quot; : {
        &quot;term&quot; : { &quot;status&quot; : &quot;request&quot; }
      }
}&#39;
</code></pre>

<h5 id="toc_18">结果</h5>

<p>{<br/>
  <q>_index</q> : <q>logstash-wap-2016.03.22</q>,<br/>
  <q>_type</q> : <q>wap</q>,<br/>
  <q>_id</q> : <q>AVOcKIIFPPR76qlEVfH2</q>,<br/>
  <q>matched</q> : true,<br/>
  <q>explanation</q> : {<br/>
    <q>value</q> : 2.5711107,<br/>
    <q>description</q> : <q>sum of:</q>,<br/>
    <q>details</q> : [ {<br/>
      <q>value</q> : 2.5711107,<br/>
      <q>description</q> : <q>weight(status:request in 31) [PerFieldSimilarity], result of:</q>,<br/>
      <q>details</q> : [ {<br/>
        <q>value</q> : <mark><strong>2.5711107</strong></mark>,<br/>
        <q>description</q> : <q>fieldWeight in 31, product of:</q>,<br/>
        <q>details</q> : [ {<br/>
          <mark><q>value</q> : 1.4142135,</mark><br/>
          <q>description</q> : <q><mark><strong>tf</strong></mark>(freq=2.0), with freq of:</q>,<br/>
          <q>details</q> : [ {<br/>
            <q>value</q> : 2.0,<br/>
            <q>description</q> : <q>termFreq=2.0</q>,<br/>
            <q>details</q> : [ ]<br/>
          } ]<br/>
        }, {<br/>
          <mark><q>value</q> : 1.8180498,</mark><br/>
          <q>description</q> : <q><mark><strong>idf</strong></mark>(docFreq=439561, maxDocs=996081)</q>,<br/>
          <q>details</q> : [ ]<br/>
        }, {<br/>
          <q>value</q> : 1.0,<br/>
          <q>description</q> : <q>fieldNorm(doc=31)</q>,<br/>
          <q>details</q> : [ ]<br/>
        } ]<br/>
      } ]<br/>
    }, {<br/>
      <q>value</q> : 0.0,<br/>
      <q>description</q> : <q>match on required clause, product of:</q>,<br/>
      <q>details</q> : [ {<br/>
        <q>value</q> : 0.0,<br/>
        <q>description</q> : <q># clause</q>,<br/>
        <q>details</q> : [ ]<br/>
      }, {<br/>
        <q>value</q> : 0.55003995,<br/>
        <q>description</q> : <q>_type:wap, product of:</q>,<br/>
        <q>details</q> : [ {<br/>
          <q>value</q> : 1.0,<br/>
          <q>description</q> : <q>boost</q>,<br/>
          <q>details</q> : [ ]<br/>
        }, {<br/>
          <q>value</q> : 0.55003995,<br/>
          <q>description</q> : <q>queryNorm</q>,<br/>
          <q>details</q> : [ ]<br/>
        } ]<br/>
      } ]<br/>
    } ]<br/>
  }<br/>
}</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-03-20T18:57:03+08:00" itemprop="datePublished">2016/3/20</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='others.html'>others</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14584714230833.html" itemprop="url">
		Linux常用命令</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">free</h3>

<pre><code>                   1      2        3       4      5         6
1              total     used     free  shared  buffers  cached
2 Mem:      24677460 23276064  1401396       0  870540 12084008
3 -/+ buffers/cache: 10321516  14355944
4 Swap:     25151484    224188  24927296
</code></pre>

<p><code>buffers</code>是用于存放要输出到<code>disk</code>（块设备）的数据的，<br/>
<code>cached</code>是存放从<code>disk</code>上读出的数据</p>

<p><code>-buffers/cache</code>，表示一个应用程序认为系统被用掉多少内存；<br/>
<code>+buffers/cache</code>，表示一个应用程序认为系统还有多少内存；</p>

<p>在linux中有这么一种思想，<strong>内存不用白不用</strong>，因此它尽可能的<code>cached</code>和<code>buffer</code>一些数据，以方便下次使用。但实际上这些内存也是可以立刻拿来使用的。<br/>
因为被系统<code>cached</code>和<code>buffer</code>占用的内存可以被快速回收，所以通常<code>FO[3][3]</code>比<code>FO[2][3]</code>会大很多</p>

<pre><code>FO[2][1] = FO[2][2] + FO[2][3]
FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]
FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]
</code></pre>

<h3 id="toc_1">du -h --max-depth=1</h3>

<p>查看硬盘占用情况</p>

<p><code>--max-depth=1</code>下一级目录</p>

<h3 id="toc_2">df -h</h3>

<p>查看整机硬盘使用情况</p>

<h3 id="toc_3">df -hl</h3>

<p>查看整机硬盘使用情况（G, M, K为单位）</p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	 <a class="next" href="others_1.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>