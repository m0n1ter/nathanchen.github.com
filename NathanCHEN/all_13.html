<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	NathanCHEN
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html">NathanCHEN</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-12-17T21:35:19+08:00" itemprop="datePublished">2015/12/17</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Java.html'>Java</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14503593199530.html" itemprop="url">
		看透Spring MVC</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>缓存的失效可以定期失效，也可以在数据发生变化的时候失效，如果按数据发生变化让缓存失效，还可以分粗粒度失效和细粒度失效。</p>

<p>像快递送货一样，货单上填写地址的规则以及怎么根据填写的内容找到客户，这就相当于IP协议，而送货时要先打电话，然后将货物送过去，最后客户签收时要签字就相当于TCP协议。</p>

<p>三次握手和四次挥手保证了连接的可靠性，不过这种模式也有它的缺点，首先是在传输效率上会比较低，另外三次握手的过程中客户端需要发送两次数据才可以建立连接，这种特征可能被一些别有用心的人利用，比如，发出第一次握手后就不回应第三次握手了，这时服务端会以为是第二次握手的数据在传输过程中丢失了，然后重新发送第二次握手，默认情况下会一直发送五次，如果发送五次后还收不到第三次握手则会丢弃请求。这就是<code>DDOS</code>攻击中的<code>SYN Flood</code>攻击，对于这种攻击的一种应对方法是设置第二次请求的重发次数，不过重发的次数大小也可能导致正常的请求中因为网络没有收到第二次握手而连接失败的情况。</p>

<p>通过<code>TCP/IP</code>协议、<code>HTTP</code>协议已经可以得到数据了，<code>Servlet</code>的作用是对接收到的数据进行处理并生成要返回给客户端的结果。</p>

<p>域名解析有很多种解析的类型，如常用的A记录和CNAME记录。A记录是将域名解析到IP（一个域名可以有多条A记录），CNAME记录是将域名解析到另一个域名（也就是作为另一个域名的别名），查找时会返回目标域名所对应的IP</p>

<p><code>ServerSocket</code>的使用可以分为三步：<br/>
- 创建<code>ServerSocket</code>：<br/>
- 调用创建出来的<code>ServerSocket</code>的<code>accept</code>方法进行监听。<code>accept</code>方法是阻塞方法，也就是说调用<code>accept</code>方法后程序会停下来等待连接请求，在接收到请求之前程序都不会往下走；当接收到请求后<code>accept</code>方法会返回一个<code>Socket</code><br/>
- 使用<code>accept</code>方法返回的<code>Socket</code>与客户端进行通信</p>

<p>普通<code>Socket</code>处理请求的模式：收到请求，处理，处理好了，收下一个请求。</p>

<p><code>NIOSocket</code>处理请求的模式：快递并不会一件一件地送，而是将很多件货一起拿去送，而且在中转站都有专门的分拣员负责按配送范围将货物分给不同的送货员，这样效率就提高了很多。</p>

<p><code>NIOSocket</code>使用中首先要创建<code>ServerSocketChannel</code>，然后注册<code>Selector</code>，接下来就可以用<code>Selector</code>接受请求并处理了。</p>

<p><code>NIOSocket</code>中服务端的处理过程可以分为5步：<br/>
1、创建<code>ServerSocketChannel</code>并设置相应参数<br/>
2、创建<code>Selector</code>并注册到<code>ServerSocketChannel</code>上<br/>
3、调用<code>Selector</code>的<code>select</code>方法等待请求<br/>
4、<code>Selector</code>接收到请求后使用<code>selectedKeys</code>返回<code>SelectionKey</code>集合<br/>
5、使用<code>SelectionKey</code>获取到<code>Channel</code>，<code>Selector</code>和操作类型并进行具体操作</p>

<pre><code>// 恢复到初始状态
public final Buffer clear()
{
    position = 0;
    limit = capacity;
    mark = -1;
    return this;
}

// 开启读的模式
public final Buffer flip()
{
    limit = position;
    position = 0;
    mark = -1;
    return this;
}
</code></pre>

<p><code>Servlet</code>接口<br/>
- <code>init</code>方法在容器启动时被容器调用（当<code>load-on-startup</code>设置为负数或者不设置时会在<code>Servlet</code>第一次用到时才被调用），只会调用一次<br/>
- <code>getServletConfig</code>方法用于获取<code>ServletConfig</code><br/>
- <code>service</code>方法用于具体处理一个请求<br/>
- <code>getServletInfo</code>方法可以获取一些<code>Servlet</code>相关的信息，默认返回空字符串<br/>
- <code>destroy</code>主要用于在<code>Servlet</code>销毁（一般指关闭服务器）时释放一些资源，只会调用一次</p>

<p><code>getServletName</code>用于获取Servlet的名字，也就是我们在<code>web.xml</code>中定义的<code>servlet-name</code>；<code>getInitParameter</code>方法用于获取<code>init-param</code>配置的参数；<code>getInitParameterNames</code>用于获取配置的所有<code>init-param</code>的名字集合；<code>getServletContext</code>的返回值代表的是我们这个应用本身。<code>ServletConfig</code>是<code>Servlet</code>级的，而<code>ServletContext</code>是<code>Context</code>（也就是<code>Application</code>）级的。</p>

<pre><code>String contextLocation = getServletConfig().getServletContext().getInitParameter(&quot;contextConfigLocation&quot;);
String servletLocation = getServletConfig().getInitParameter(&quot;contextConfigLocation&quot;);
</code></pre>

<h4 id="toc_0">GenericServlet</h4>

<p><code>GenericServlet</code>是<code>Servlet</code>的默认实现，主要是做了三件事：<br/>
- 实现了<code>ServletConfig</code>接口，我们可以直接调用<code>ServletConfig</code>里面的方法<br/>
- 提供了无参的<code>init</code>方法<br/>
- 提供了<code>log</code>方法</p>

<p><code>GenericServlet</code>实现了<code>Servlet</code>的<code>init(ServletConfig config)</code>方法，在里面将<code>config</code>设置给了内部变量<code>config</code>，然后调用了无参的<code>init()</code>方法</p>

<pre><code>public void init(ServletConfig config) throws ServletException {
    this.config = config;
    this.init();
}
public void init() throws ServletException {

}
</code></pre>

<h4 id="toc_1">HttpServlet</h4>

<p><code>HttpServlet</code>是用<code>HTTP</code>协议实现的<code>Servlet</code>的基类。<code>HttpServlet</code>主要重写了<code>service</code>方法。在<code>service</code>方法中首先将<code>ServletRequest</code>和<code>ServletResponse</code>转换为了<code>HttpServletRequest</code>和<code>HttpServletResponse</code>，然后根据<code>Http</code>请求的类型不同将请求路由到了不同的处理方法</p>

<h4 id="toc_2">Tomcat的顶层结构</h4>

<p><code>Tomcat</code>中最顶层的容器叫<code>Server</code>，代表整个服务器，<code>Server</code>中包含至少一个<code>Service</code>，用于具体提供服务。<code>Service</code>主要包含两部分：<code>Connector</code>和<code>Container</code>。<code>Connector</code>用于处理连接相关的事情，并提供<code>Socket</code>与<code>request</code>、<code>response</code>的转换，<code>Container</code>用于封装和管理<code>Servlet</code>，以及具体处理<code>request</code>请求。</p>

<p>一个<code>Tomcat</code>中只有一个<code>Server</code>，一个<code>Server</code>可以包含多个<code>Service</code>，一个<code>Service</code>只有一个<code>Container</code>，但可以有多个<code>Connectors</code>（因为一个服务可以有多个连接）</p>

<h4 id="toc_3">Server的启动过程</h4>

<p>await方法处理的大概逻辑是首先判断端口号port，然后根据port的值分为三种处理方法：<br/>
- port为-2，则会直接退出，不进入循环<br/>
- port为-1，则会进入一个while(!stopAwait)的循环，只有在外部调用stop方法才会退出循环<br/>
- port为其他值，则也会进入一个while(!stopAwait)的循环，不过同时会在port所在的端口启动一个ServerSocket来监听关闭命令，如果姐收到了则会使用break跳出循环</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-12-17T16:49:44+08:00" itemprop="datePublished">2015/12/17</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14503421841704.html" itemprop="url">
		H5 缓存机制浅析 移动端 Web 加载性能优化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">H5缓存机制原理分析</h3>

<p>浏览器缓存机制是指通过HTTP协议头里的<code>Cache-Control</code>(或<code>Expires</code>)和<code>Last-Modified</code>（或<code>Etag</code>）等字段来控制文件缓存的机制。</p>

<p><code>Cache-Control</code>用于控制文件在本地缓存有效时长。比如服务器回包：<code>Cache-Control:max-age=600</code> 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。在接下来600秒内，如果有请求这个资源，浏览器不会发出 <code>HTTP</code>请求，而是直接使用本地缓存的文件。</p>

<p><code>Last-Modified</code>是标识文件在服务器上的最新更新时间。下次请求时，如果文件缓存过期，浏览器通过 <code>If-Modified-Since</code> 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。</p>

<h5 id="toc_1">Reference</h5>

<p><a href="http://my.oschina.net/bugly/blog/542883">http://my.oschina.net/bugly/blog/542883</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-12-14T20:15:28+08:00" itemprop="datePublished">2015/12/14</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14500953284759.html" itemprop="url">
		RabbitMQ</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>RabbitMQ is a message broker. </p>

<p>RabbitMQ, and messaging in general, uses some jargon.</p>

<ul>
<li>Producing means nothing more than sedning. A program that sends messages is a producer.</li>
<li>A queue is the name for a mailbox. It lives inside RabbitMQ. Although messages flow through RabbitMQ and your applications, they can be stored only inside a queue. A queue is not bound by any limits, it can store as many messages as you like - it&#39;s essentially an infinite buffer. Many producers can send messages that go to one queue, many consumers can try to receive data from on queue. </li>
<li>Consuming has a similar meaning to receiving. A consumer is a program that mostly waits to receive messages.</li>
</ul>

<p>The main idea behind Work Queues (Task Queues) is to avoid doing a resource-intensive task immediately and having to wait for it to complete. We encapsulate a task as a message and send it to a queue. A worker process running in the background will pop the tasks and eventually execute the job. When you run many workers the tasks will be shared between them.</p>

<p>One of the adventages of using a Task Queue is the ability to easily parallelise work. If we are building up a backlog of work, we can just add more workers and that way, scale easily.</p>

<p>By default, RabbitMQ will send each message to the next consumer, in sequence. On average every consumer will get the same number of messages. This way of distributing messages is called round-robin.</p>

<h3 id="toc_0">Message Acknowledgments</h3>

<p>We don&#39;t want to lose any tasks. If a worker dies, we&#39;d like the task to be delivered to another worker. In order to make sure a message is never lost, RabbitMQ supports message acknowledgments. An ack is sent back from the consumer to tell RabbitMQ that a particular message has been received, processed and that RabbitMQ is free to delete it.</p>

<p>If a consumer dies (its channel is closed, connection is closed, or TCP connection is lost) without sending an ACK, RabbitMQ will understand that a message wasn&#39;t processed fully and will re-queue it. If there are other consumers online at the same time, it will then quickly redeliver it to another consumer. That way you can be sure that no message is lost, even if the workers occasionally die.</p>

<p>There aren&#39;t any message timeouts; RabbitMQ will redeliver the message only when the worker connection dies. It&#39;s fine even if processing a message takes a very, very long time.</p>

<p>Message acknowledgments are turned on by default.</p>

<h3 id="toc_1">Message durability</h3>

<p>When RabbitMQ quits or crashes it will forget the queues and messages unless you tell it not to. Two things are required to make sure that messages aren&#39;t lost: we need to mark both the queue and messages as durable.</p>

<p>First, we need to make sure that RabbitMQ will never lose our queue. In order to do so, we need to declare it as <code>durable</code>:</p>

<p>RabbitMQ doesnt allow you to redefine an existing queue with different parameters and will return an error to any program that tries to do that.</p>

<p>Marking messages as persistent doesnt fully guarantee that a message wont be lost. Although it tells RabbitMQ to save the message to disk, there is still a short time window when RabbitMQ has accepted a message and hasnt saved it yet. If you need a stronger guarantee then you can use publisher confirms.</p>

<h3 id="toc_2">Fair dispatch</h3>

<p>In a situation with two workers, when all odd messages are heavy and even messages are light, one worker will constantly busy and the other one will do hardly any work. RabbitMQ doesnt know anything about that and will still dispatch messages evenly.</p>

<p>This happens because RabbitMQ just dispatches a message when the message enters the queue. It doesnt look at the number of unacknowledged messages for a consumer. It just blindly dispatches every n-th message to the n-th consumer.</p>

<p>In order to defeat that we can use the <code>basicQos</code> method with the <code>prefetchCount = 1</code> setting. This tells RabbitMQ not to give more than one message to a worker at a time. Or, in other words, dont dispatch a new message to a worker until it has processed and acknowledged the previous one. Instead, it will dispatch it to the next worker that is not still busy.</p>

<h3 id="toc_3">Exchanges</h3>

<p>The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue. Actually, quite often the producer doesnt even know if a message will be delivered to any queue at all. </p>

<p>Instead, the producer can only send messages to an exchange. On one side it receives messages from producers and the other side it pushes them to queues. The exchange must know exactly what to do with a message it receives.</p>

<p>We need to tell the exchange to send messages to our queue. That relationship between exchange and a queue is called a binding.</p>

<h3 id="toc_4">Direct exchange</h3>

<p>The routing algorithm behind a <code>direct</code> exchange is simple - a message goes to the queues whose <code>binding key</code> exactly matches the <code>routing key</code> of the message.</p>

<h3 id="toc_5">Multiple bindings</h3>

<p>the <code>direct</code> exchange will behave like <code>fanout</code> and will broadcast the message to all the matching queues.</p>

<h3 id="toc_6">Topic exchange</h3>

<p>Messages sent tp a topic exchange cant have an arbitrary routing_key - it must be a list of words, delimited by dots. The words can be anything, but usually they specify some features connected to the message.</p>

<p>The binding key must also be in the same form. The logic behind the topic exchange is similar to a direct one - a message sent with a particular routing key will be delivered to all the queues that are bound with a matching binding key. However there are two important special cases for binding keys:</p>

<ul>
<li><code>*</code> can substitute for exactly one word</li>
<li><code>#</code> can substitute for zero or more words</li>
</ul>

<p>Queues are bound to an exchange using a &#39;Binding&#39;. A publisher sends a message to an exchange. The exchange will accept the message and routes it to one or more queues (or another exchange) based on the bindings. An exchange completely decouples a publisher from queues and the consumers that consumes from those queues.</p>

<p>A queue will store the messages in memory or disk and deliver them to consumers. A queue binds itself to an exchange using a &#39;Binding&#39; which describes the criteria for the type of messages it is interested in.</p>

<p>A binding defines the relationship between an exchange and a queue. The most simple case is where the binding equals the queue name. A binding decouples a queue from an exchange. The same queue can be bound to any number of exchanges using the same criteria or different criteria. Different queues can be bound to the same exchange using the same routing criteria as well.</p>

<p>A message can be matched with more than one queue if two or more queues are bound with the same routing criteria.</p>

<h4 id="toc_7">Direct Exchange</h4>

<p>The exchange does a direct match between the routing key provided in the message and the routing criteria used when a queue is bound to this exchange.</p>

<p>The most common use case is to bind the queue to the exchange using the queue name.</p>

<h4 id="toc_8">Topic Exchange</h4>

<p>The exchange does a wildcard match between the routing key and the routing pattern specified in the binding. The routing key is treated as zero or more words, delimited by &#39;.&#39; and supports special wildcard characters. <q>*</q> matches a single word and &#39;#&#39; matches zero or more words.</p>

<h4 id="toc_9">Fanout Exchange</h4>

<p>Queues are bound to this exchange with no arguments. Hence any message sent to this exchange will be forwarded to all queues bound to this exchange.</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-11-11T09:30:44+08:00" itemprop="datePublished">2015/11/11</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14472054449072.html" itemprop="url">
		商品搜索系统架构</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li>最初只有1列searcher组成在线检索服务</li>
<li>由于用户体验的需要，首先增加Query Processor服务，负责查询意图分析，提升搜索的准确性。</li>
<li>随着访问量的增长，接着增加缓存模块，提升请求处理性能。</li>
<li>随着数据量（商品量）的增长，将包装服务从检索服务中独立出去，成为detail server服务。数据量的进一步增长，对数据进行类似数据库分库分表的分片操作。这时候，在线检索服务由多个分片的searcher列组成。自然而然，需要一个merger服务，将多个分片的结果进行合并。</li>
</ul>

<h3 id="toc_0">Reference</h3>

<p><a href="http://www.infoq.com/cn/articles/jingdong-11-11-commodity-search-system-architecture-design">http://www.infoq.com/cn/articles/jingdong-11-11-commodity-search-system-architecture-design</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-11-05T09:14:33+08:00" itemprop="datePublished">2015/11/5</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14466860736069.html" itemprop="url">
		Java Servlet工作原理</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">ServletContext</h3>

<p>When the servlet container (like <code>Apache Tomcat</code>) starts up, it will deploy and load all web applications. When a web application get loaded, the servlet container will create the <code>ServletContext</code> once and keep in server&#39;s memory. The webapp&#39;s <code>web.xml</code> will be parsed and every <code>&lt;servlet&gt;</code>, <code>&lt;filter&gt;</code> and <code>&lt;listener&gt;</code> found in <code>web.xml</code>, or annotated with respectively <code>@WebServlet</code>, <code>@WebFilter</code> and <code>@WebListener</code>, will be created once and kept in server&#39;s memory as well. For all filters, the <code>init()</code> method will also be invoked immediately. When the servlet container shuts down, it will unload all web applications, invoke the <code>destroy()</code> of all initialized servlets and filters, and finally the ServletContext and all Servlet, Filter and Listener instances will be trashed.</p>

<p>When the Servlet in question has a <code>&lt;servlet&gt;&lt;load-on-startup&gt;</code> or <code>@WebServlet(loadOnStartup)</code> value greater than 0, then its <code>init()</code> method will also immediately be invoked during startup. Those servlets are initialized in the same order as <code>load-on-startup</code> value represents, or if they are the same, then the order in the <code>web.xml</code> or <code>@WebServlet</code> classloading. Or, if the <q>load-on-startup</q> value us absent, then the <code>init()</code> method will only be invoked on very first HTTP request hitting the servlet in question.</p>

<h3 id="toc_1">HttpServletRequest and HttpServletResponse</h3>

<p>The servlet container is attached to a web server which listens on HTTP requests on a certain port number, which is usually 8080 in development and 80 in production. <strong>When a client sends a HTTP request, the servlet container will create new HttpServletRequest and HttpServletResponse objects</strong> and pass it through the methods of the already-created Filter and Servlet instances whose url-pattern matches the request URL, all in the same thread.</p>

<p>The request object provides access to all information of the HTTP request, such as the request headers and the request body. The response object provides facility to control and send the HTTP response the way you want, such as setting headers and the body. When the HTTP response is committed and finished, then both the request and response objects will be trashed.</p>

<h3 id="toc_2">HttpSession</h3>

<p>When a client visits the webapp for the first time and the HttpSession is to be obtained for the first time by <code>request.getSession()</code>, then the servlet container will create it, generate a long and unique ID (which you can get by session.getId()) and store it in server&#39;s memory. <strong>The servlet container will also set a Cookie in the Set-Cookie header of the HTTP response with JSESSIONID as cookie name and the unique session ID as cookie value</strong>.</p>

<p>As per the HTTP cookie specification, the client is required to send this cookie back in the subsequent requests in the Cookie header as long as the cookie is valid. The servlet container will determine the Cookie header of every incoming HTTP request for the presence of the cookie with the name JSESSIONID and use its value (the session ID) to get the associated HttpSession from server&#39;s memory.</p>

<p><strong>The HttpSession lives until it has not been used for more than the <session-timeout> time</strong>, a setting you can specify in web.xml, which defaults to 30 minutes. <strong>So when the client doesn&#39;t visit the webapp anymore for over 30 minutes, then the servlet container will trash the session</strong>. Every subsequent request, even though with the cookie specified, will not have access to the same session anymore. The servlet container will create a new one.</p>

<p>On the other hand, the session cookie on the client side has a default lifetime which is as long as the browser instance is running. So when the client closes the browser instance, then the session will be trashed at the client side. In a new browser instance the cookie associated with the session won&#39;t be sent anymore. A new request.getSession() would return a brand new HttpSession and set a cookie with a brand new session ID.</p>

<h3 id="toc_3">In a nutshell</h3>

<ul>
<li>The ServletContext lives as long as the webapp lives. It&#39;s been shared among all requests in all sessions.</li>
<li>The HttpSession lives as long as the client is interacting with the webapp with the same browser instance and the session hasn&#39;t timed out at the server side yet. It&#39;s been shared among all requests in the same session.</li>
<li>The HttpServletRequest and HttpServletResponse lives as long as the client has sent it until the complete response (the webpage) is arrived. It is not being shared elsewhere.</li>
<li>Any Servlet, Filter and Listener lives as long as the webapp lives. They are being shared among all requests in all sessions.</li>
<li>Any attribute which you set in ServletContext, HttpServletRequest and HttpSession will live as long as the object in question lives.</li>
</ul>

<h3 id="toc_4">ThreadSafety</h3>

<p>It&#39;s multithreaded and different threads can make use of the same instance. It would otherwise have been too expensive to recreate it on every request.</p>

<pre><code>public class ExampleServlet extends HttpServlet {

    private Object thisIsNOTThreadSafe;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Object thisIsThreadSafe;

        thisIsNOTThreadSafe = request.getParameter(&quot;foo&quot;); // BAD!! Shared among all requests!
        thisIsThreadSafe = request.getParameter(&quot;foo&quot;); // OK, this is thread safe.
    } 
}
</code></pre>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_12.html">Prev</a>  
	 <a class="next" href="all_14.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>