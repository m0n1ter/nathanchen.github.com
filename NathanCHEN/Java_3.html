<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Java - NathanCHEN
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html">NathanCHEN</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-01-20T12:49:57+08:00" itemprop="datePublished">2016/1/20</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Java.html'>Java</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14532653973981.html" itemprop="url">
		Java `CyclicBarrier`</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>The <code>CyclicBarrier</code> class is a synchronization mechanism that can synchronize threads progressing through some algorithm. In other words, it is a barrrier that all threads must wait at, until all threads reach it, before any of the threads can continue.</p>

<h3 id="toc_0">Creating a <code>CyclicBarrier</code></h3>

<pre><code>CyclicBarrier cyclicBarrier = new CyclicBarrier(2);
</code></pre>

<h3 id="toc_1">Waiting at a <code>CyclicBarrier</code></h3>

<p>Here is how a thread waits at <code>CyclicBarrier</code>:</p>

<pre><code>cyclicBarrier.await();
</code></pre>

<p>You can also specify a timeout for the waiting thread. When the timeout has passed the thread is also released, even if not all N thread are waiting at the <code>CyclicBarrier</code>. Here is how you specify a timeout:</p>

<pre><code>cyclicBarrier.await(10, TimeUnit.SECONDS);
</code></pre>

<h3 id="toc_2"><code>CyclicBarrier</code> Action</h3>

<pre><code>Runnable barrierAction = ...;
CyclicBarrier barrier = new CyclicBarrier(2, barrierAction);
</code></pre>

<h3 id="toc_3"><code>CyclicBarrier</code> Example</h3>

<pre><code>Runnable barrier1Action = new Runnable() {
    public void run() {
        System.out.println(&quot;BarrierAction 1 executed &quot;);
    }
};
Runnable barrier2Action = new Runnable() {
    public void run() {
        System.out.println(&quot;BarrierAction 2 executed &quot;);
    }
};

CyclicBarrier barrier1 = new CyclicBarrier(2, barrier1Action);
CyclicBarrier barrier2 = new CyclicBarrier(2, barrier2Action);

CyclicBarrierRunnable barrierRunnable1 =
        new CyclicBarrierRunnable(barrier1, barrier2);
CyclicBarrierRunnable barrierRunnable2 =
        new CyclicBarrierRunnable(barrier1, barrier2);

new Thread(barrierRunnable1).start();
new Thread(barrierRunnable2).start();   
</code></pre>

<p>Here is the <code>CyclicBarrierRunnable</code> class:</p>

<pre><code>public class CyclicBarrierRunnable implements Runnable{

    CyclicBarrier barrier1 = null;
    CyclicBarrier barrier2 = null;

    public CyclicBarrierRunnable(
            CyclicBarrier barrier1,
            CyclicBarrier barrier2) {

        this.barrier1 = barrier1;
        this.barrier2 = barrier2;
    }

    public void run() {
        try {
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() +
                                &quot; waiting at barrier 1&quot;);
            this.barrier1.await();

            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() +
                                &quot; waiting at barrier 2&quot;);
            this.barrier2.await();

            System.out.println(Thread.currentThread().getName() +
                                &quot; done!&quot;);

        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}   
</code></pre>

<hr/>

<pre><code>Thread-0 waiting at barrier 1
Thread-1 waiting at barrier 1
BarrierAction 1 executed
Thread-1 waiting at barrier 2
Thread-0 waiting at barrier 2
BarrierAction 2 executed
Thread-0 done!
Thread-1 done!
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-01-20T12:39:49+08:00" itemprop="datePublished">2016/1/20</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Java.html'>Java</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14532647897341.html" itemprop="url">
		Java CountDownLatch</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>A <code>CountDownLatch</code> is a concurrency construct that allows one or more threads to wait for a given set of operations to complete.</p>

<p>A <code>CountDownLatch</code> is initialized with a given count. This count is decremented by calls to the <code>countDown()</code> method. Threads waiting for this count to reach zero can call one of the <code>await()</code> methods. Calling <code>await()</code> blocks the thread until the count reaches zero.</p>

<p>Below is a simple example. After the <code>Decrementer</code> has called <code>coundDown()</code> 3 times on the <code>CountDownLatch</code>, the waiting <code>Waiter</code> is released from the <code>await()</code> call.</p>

<pre><code>CountDownLatch latch = new CountDownLatch(3);

Waiter      waiter      = new Waiter(latch);
Decrementer decrementer = new Decrementer(latch);

new Thread(waiter)     .start();
new Thread(decrementer).start();

Thread.sleep(4000);
</code></pre>

<hr/>

<pre><code>public class Waiter implements Runnable{

    CountDownLatch latch = null;

    public Waiter(CountDownLatch latch) {
        this.latch = latch;
    }

    public void run() {
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(&quot;Waiter Released&quot;);
    }
}
</code></pre>

<hr/>

<pre><code>public class Decrementer implements Runnable {

    CountDownLatch latch = null;

    public Decrementer(CountDownLatch latch) {
        this.latch = latch;
    }

    public void run() {

        try {
            Thread.sleep(1000);
            this.latch.countDown();

            Thread.sleep(1000);
            this.latch.countDown();

            Thread.sleep(1000);
            this.latch.countDown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-01-20T12:33:29+08:00" itemprop="datePublished">2016/1/20</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Java.html'>Java</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14532644091316.html" itemprop="url">
		Java ConcurrentMap</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>The ConcurrentMap represents a Map which is capable of handling concurrent access (puts and gets) to it.</p>

<p>The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.</p>

<h3 id="toc_0">ConcurrentHashMap</h3>

<p>The <code>ConcurrentHashMap</code> is very similar to the <code>java.util.HashTable</code> class, except that <code>ConcurrentHashMap</code> offers better concurrency than <code>HashTable</code> does. <code>ConcurrentHashMap</code> does not lock the <code>Map</code> while you are reading from it. Additionally, <code>ConcurrentHashMap</code> does not lock the entire <code>Map</code> when writing to it. It only locks the part of the Map that is being written to, internally.</p>

<pre><code>ConcurrentMap concurrentMap = new ConcurrentHashMap();

concurrentMap.put(&quot;key&quot;, &quot;value&quot;);

Object value = concurrentMap.get(&quot;key&quot;);
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-01-20T11:22:58+08:00" itemprop="datePublished">2016/1/20</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Java.html'>Java</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14532601780333.html" itemprop="url">
		Java BlockingDeque</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">BlockingDeque</h3>

<p>The <code>BlockingDeque</code> interface represents a deque which is thread safe to put into, and take instances from.</p>

<p>The <code>BlockingDeque</code> class is a <code>Deque</code> which blocks threads trying to insert or remove elements from the deque, in case it is either not possible to insert or remove elements from the deque.</p>

<p>A <code>deque</code> is short for &#39;Double Ended Queue&#39;. Thus, a <code>deque</code> is a queue which you can insert and take elements from, from both ends.</p>

<h3 id="toc_1">BlockingDeque Usage</h3>

<p>A BlockingDeque could be used if threads are both producing and consuming elements of the same queue. It could also just be used if the producing thread needs to insert at both ends of the queue, and the consuming thread needs to remove from both ends of the queue.</p>

<p>A thread will produce elements and insert them into either end of the queue. If the deque is currently full, the inserting thread will be blocked until a removing thread takes an element out of the deque. If the deque is currently empty, a removing thread will be blocked until an inserting thread inserts an element into the deque.</p>

<pre><code>BlockingDeque&lt;String&gt; deque = new LinkedBlockingDeque&lt;String&gt;();

deque.addFirst(&quot;1&quot;);
deque.addLast(&quot;2&quot;);

String two = deque.takeLast();
String one = deque.takeFirst();
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-01-19T21:49:22+08:00" itemprop="datePublished">2016/1/19</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Java.html'>Java</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14532113623892.html" itemprop="url">
		Java BlockingQueue</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">BlockingQueue Usage</h3>

<p>A <code>BlockingQueue</code> is typically used to have on thread produce objects, which another thread consumes.</p>

<p>The producing thread will keep producing new objects and insert them into the queue, until the queue reaches some upper bound on what it can contain. If the blocking queue reaches its upper limit, the producing thread is blocked while trying to insert the new object. It remains blocked until a consuming thread takes an object out of the queue.</p>

<p>The consuming thread keeps taking objects out of the blocking queue, and processes them. If the consuming thread tries to take an object out of an empty queue, the consuming thread is blocked until a producing thread puts an object into the queue.</p>

<p>It is not possible to insert <code>null</code> into a <code>BlockingQueue</code>. If you try to insert <code>null</code>, the <code>BlockingQueue</code> will throw a <code>NullPointerException</code>.</p>

<p>It is also possible to access all the elements inside a <code>BlockingQueue</code>, and not just the elements at the start and end. For instance, say you have queued an object for processing, but your application decides to cancel it. You can then call <code>remove(o)</code> to remove a specific object in the queue. However, this is not done very efficiently.</p>

<pre><code>public class BlockingQueueExample {

    public static void main(String[] args) throws Exception {

        BlockingQueue queue = new ArrayBlockingQueue(1024);

        Producer producer = new Producer(queue);
        Consumer consumer = new Consumer(queue);

        new Thread(producer).start();
        new Thread(consumer).start();

        Thread.sleep(4000);
    }
}

public class Producer implements Runnable{

protected BlockingQueue queue = null;

public Producer(BlockingQueue queue) {
    this.queue = queue;
}

public void run() {
    try {
        queue.put(&quot;1&quot;);
        Thread.sleep(1000);
        queue.put(&quot;2&quot;);
        Thread.sleep(1000);
        queue.put(&quot;3&quot;);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
}
</code></pre>

<h3 id="toc_1">ArrayBlockingQueue</h3>

<p><code>ArrayBlockingQueue</code> is a bounded, blocking queue that stores the elements internally in an array. That it is bounded means that it cannot store unlimited amounts of elements. There is an upper bound on the number of elements it can store at the same time. You set the upper bound at instantiation time, and after that it cannot be changed.</p>

<p>The <code>ArrayBlockingQueue</code> stores the elements internally in FIFO order. The <code>head</code> of the queue is the element which has been in queue the longest time, and the <code>tail</code> of the queue is the element which has been in the queue the shortest time.</p>

<pre><code>BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(1024);

queue.put(&quot;1&quot;);

String string = queue.take();
</code></pre>

<h3 id="toc_2">DelayQueue</h3>

<p>The <code>DelayQueue</code> blocks the elements internally until a certain delay has expired. The elements must implement the interface <code>java.util.concurrent.Delayed</code> </p>

<pre><code>public interface Delayed extends Comparable&lt;Delayed&lt; {
 public long getDelay(TimeUnit timeUnit);
}   
</code></pre>

<p>The value returned by the <code>getDelay()</code> method should be the delay remaining before this element can be released. If 0 or a negative value is returned, the delay will be considered expired, and the element released at the next <code>take()</code> etc. call on the DelayQueue.</p>

<h3 id="toc_3">LinkedBlockingQueue</h3>

<p>The <code>LinkedBlockingQueue</code> keeps the elements internally in a linked structure (linked nodes). This linked structure can optionally have an upper bound if desired. If no upper bound is specified, <code>Integer.MAX_VALUE</code> is used as the upper bound.</p>

<p>The <code>LinkedBlockingQueue</code> stores the elements internally in FIFO order.</p>

<pre><code>BlockingQueue&lt;String&gt; unbounded = new LinkedBlockingQueue&lt;String&gt;();
BlockingQueue&lt;String&gt; bounded   = new LinkedBlockingQueue&lt;String&gt;(1024);

bounded.put(&quot;Value&quot;);

String value = bounded.take();
</code></pre>

<h3 id="toc_4">PriorityBlockingQueue</h3>

<p>The <code>PriorityBlockingQueue</code> is an unbounded concurrent queue. It uses the same ordering rules as the <code>java.util.PriorityQueue</code> class. You cannot insert null into this queue.</p>

<p>All elements inserted into the <code>PriorityBlockingQueue</code> must implement the <code>java.lang.Comparable</code> interface. The elements thus order themselves according to whatever priority you decide in your <code>Comparable</code> implementation.</p>

<p>In case you obtain an <code>Iterator</code> from a <code>PriorityBlockingQueue</code>, the <code>Iterator</code> does not guarantee to iterate the elements in priority order.</p>

<pre><code>BlockingQueue queue   = new PriorityBlockingQueue();
//String implements java.lang.Comparable
queue.put(&quot;Value&quot;);
String value = queue.take();
</code></pre>

<h3 id="toc_5">SynchronousQueue</h3>

<p>The SynchronousQueue is a queue that can only contain a single element internally. A thread inserting an element into the queueis blocked until another thread takes that element from the queue. </p>

<p>Likewise, if a thread tries to take an element and no element is currently present, that thread is blocked until a thread insert an element into the queue.</p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="Java_2.html">Prev</a>  
	 <a class="next" href="Java_4.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>