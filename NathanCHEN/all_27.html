<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	NathanCHEN
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="NathanCHEN" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html">NathanCHEN</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-10-25T10:47:23+08:00" itemprop="datePublished">2015/10/25</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14457412434425.html" itemprop="url">
		---</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>layout: post<br/>
title: <q>云计算之分布式表格系统</q><br/>
category: Reading Notes </p>

<h2 id="toc_0">tags: [<q>读文章</q>, <q>Big Table</q>, <q>分布式系统</q>]</h2>

<p>{% include JB/setup %}</p>

<p>云计算的分布式表格依赖于下层的分布式文件系统（如Google的GFS）提供可靠和高效的数据存储，也是分布式文件系统的主要使用者。</p>

<h4 id="toc_1">行</h4>

<p>行是二进制串，最大长度为64Kb。对统一行内的数据的读写总是原子的。</p>

<p>分布式表格系统总是把整个表格按照行排序（字典序），然后按整行动态划分，每个划分后的块称为一个子表（tablet，在google的Bigtable中，每个子表一般不超过256MB），子表也是分布式表格系统的worker加载/卸载和负载平衡的基本单元。</p>

<p>例如在网页库表格中，行是网页的URL，但其中的域名部分被颠倒了，</p>

<pre><code>例如maps.google.com/index.html变成了com.google.maps/index.html，
</code></pre>

<p><strong>这样使得域名相似的网页聚集在一起，由于域名相似的网页在内容上往往有一定的相似性，因此可以产生更高的压缩倍率</strong>，并使得一些应用程序更加高效。</p>

<h4 id="toc_2">列</h4>

<p>列按(column family)列族分组，同一列族内的单元格的内容常常相同，并用修饰词(qualifier)区分不同的单元格，即column=<q>family:qualifier</q>。一个表格内的列族个数是有限的且一般由可打印字符组成，但修饰词（qualifier）的个数没有任何限制且可以是任意字符。</p>

<p>Bigtable还允许用户把内容相似或相关的列族组成局部群组（locality group），<strong>同一局部群组内的列族的数据常常存放在一起</strong>，这样可以加快他们的访问速度；用户还可以把某些局部群组设定为装入内存。</p>

<p>列族是权限控制的基本单元。也就是说数据添加，查找，修改都要合适的权限。</p>

<p>局部群组则是数据压缩的基本单元，用户可以对不同的局部群组指定不同的压缩算法或者同一压缩算法的不同参数。</p>

<p>时间戳是64位整数，可以用来表示真正的时间，这时它的单位是微秒，时间戳也可以是用户指定的任意值。</p>

<p>Bigtable采用了3层B+树结构来存储表格数据，第三层为用户数据层（user data tablets），第二层为元数据索引层（metadata tablets），用来索引用户数据tablets，第一层为根索引层（root tablet），用来索引第二层数据。根索引层和元数据索引层的主要数据被设置为装入内存，应用程序需要访问用户数据时，Bigtable会根据需要依次访问root tablet和metadata tablets，这使得系统仅仅在访问用户数据时才访问磁盘。</p>

<h3 id="toc_3">REFERENCE</h3>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-10-25T10:47:23+08:00" itemprop="datePublished">2015/10/25</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14457412434383.html" itemprop="url">
		---</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>layout: post<br/>
title: <q>大规模云计算平台的技术挑战</q><br/>
category: Reading Notes</p>

<h2 id="toc_0">tags: [<q>读文章</q>, “云计算”]</h2>

<p>{% include JB/setup %}</p>

<p>飞天大规模分布式计算平台是一个由多个组件所构成的复杂的分布式系统，其中的核心组件是以下两个子系统：</p>

<ol>
<li>计算资源调度系统：管理和调度集群计算资源；在多个云服务间动态分配计算资源；自动检测服务器故障并迁移故障服务器上的服务。</li>
<li>分布式文件系统：管理集群的所有硬盘；合理地安排数据存放位置以兼顾性能和数据安全性；自动检测磁盘故障并复制数据以保证安全。</li>
</ol>

<p>实现云计算平台的过程中所面临的技术挑战：</p>

<ol>
<li>在不可靠硬件基础上提供高可靠的计算能力和存储能力；</li>
<li>提供高可用服务；</li>
<li>低成本运维海量硬件；</li>
<li>在线应用与离线应用共存；</li>
<li>克服节点间宽带的限制；</li>
<li>最大化利用计算资源，等等</li>
</ol>

<h4 id="toc_1">一、不可靠的硬件是最基本的挑战：</h4>

<p>集群规模达到上千台后，单机上的小规模事件变成了必然的、频繁发声的事件。我们称之为“硬”故障。还有一类称之为“软”故障，例如，硬盘可访问但速度只有正常的1/10、服务器没有宕机但程序运行缓慢、网络时好时坏等。</p>

<p>硬、软故障发声都会对系统的可靠性甚至可用性造成不良影响，因此如何及时有效地进行故障检测和恢复就变得比较关键。</p>

<p>检测“软”故障有两种思路。</p>

<p>一种是针对每种具体故障设计检测方法。</p>

<p>一种是从宏观现象来检测。</p>

<pre><code>例子1：检测作业在某个服务器上执行特别缓慢的情况。
统计每个作业在每台服务器上的执行事件。因为输入数据被均匀地切片，每台服务器上的执行时间应该大致相同。如果某台服务器上的执行时间超过了平均时间的三倍，它就被标记为“缓慢”。如果各种不同作业在某台服务器上都“缓慢”，那么我们有充分的理由怀疑这台服务器有问题。调度系统会自动把这台服务器**加入黑名单**，不再用它执行作业。之后再自动或人工检查这些可疑服务器的具体故障原因。

例子2：检测磁盘读写慢的情况。
我们在分布式文件系统里也会统计每次磁盘访问的时间。如果某块磁盘有大比率的访问时间远远超过系统平均值，那么很有可能是这块磁盘快要发声故障了。文件系统此时会做三件事：
* 停止写新数据到这块磁盘，防止更多数据处于危险中；
* 开始为这块磁盘上的数据增加更多副本；
* 当这块磁盘上的所有数据都有额外的副本，就可以将它下线，待运维处理。
</code></pre>

<h4 id="toc_2">二、故障自动恢复的策略：</h4>

<pre><code>Amazon EC2大规模停机事件
事故起因是Amazon对集群网络做日常维护升级时操作错误，网络流量被全部切换到备用网络，导致备用网络过载。自动故障恢复机制检测到网络不同，以为服务器大量宕机，马上开始数据复制以替换‘宕机’的服务器上的数据副本，引发了‘镜像风暴’（大量服务器同时尝试创建数据镜像）。而由此增加的数据流量更加剧了网络过载，从而使故障在集群中蔓延，进入恶性循环。最终采取了包括暂时关闭自动故障恢复系统和增加硬件在内的多个措施。
</code></pre>

<p>我们的策略是限制故障自动恢复机制的作用范围：</p>

<ul>
<li>正常情况下，任何时候集群中都有且仅有很小比例的服务器发生故障，此时自动恢复有效，即使无效也不会造成灾难（上限是1%的硬盘）；</li>
<li>如果发生大规模故障，明智的策略是尽量降低系统负载，暂时禁止掉前面提到的自动恢复逻辑。</li>
</ul>

<h4 id="toc_3">三、数据可靠性和实时性能优化：</h4>

<p>为了保证数据安全性，文件系统对所有的数据均采用了<strong>多份拷贝</strong>。在创建文件时，用户可以指定文件数据的拷贝数目，文件系统会保证数据分布在不同节点和不同的机架上，使得单个硬件故障不会造成数据无法访问。</p>

<p><strong>多副本技术被广泛采用但是会导致数据写入的延迟增大，因为只有当所有副本都写成功后才能结束一个写操作</strong>。</p>

<p><strong>可以通过文件日志文件来解决此问题。把日志文件写入磁盘，只要数据文件进入指定数量服务器的内存即可认为是写成功；后天线程随后会把内存中的数据批量写入磁盘。</strong></p>

<h3 id="toc_4">REFERENCE</h3>

<p>刘缙，朱家稷，张海勇，“大规模云平台的技术挑战”，淘宝，2012</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-10-25T10:47:23+08:00" itemprop="datePublished">2015/10/25</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14457412434348.html" itemprop="url">
		---</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>layout: post<br/>
title: <q>Sql中的ACID</q><br/>
category: Reading Notes </p>

<h2 id="toc_0">tags: [<q>关系型数据库</q>, <q>读文章</q>]</h2>

<p>{% include JB/setup %}</p>

<h3 id="toc_1">理解原子性（Atomicity）</h3>

<p><strong>原子性意味着数据中的事务执行是作为原子。即不可再分，整个语句要么执行，要么不执行，不会有中间状态。</strong></p>

<pre><code>    CREATE TABLE  TestForAtom
    {
        col1 int
        CONSTRAINT chk_TestForAtom
        CHECK(col1 = 5)
    }
</code></pre>

<p>-- 插入的两个数据中有一个违反了check约束</p>

<pre><code>    INSERT INTO TestForAtom(col1) values(5),(6)
</code></pre>

<p>-- 虽然有一条数据符合规范，但另一条数据6并不符合check约束</p>

<p>-- 从而造成没有任何数据可以插入，保证了原子性</p>

<pre><code>    SELECT * FROM TestForAtom
</code></pre>

<p><strong>SQL SERVER提供了两大类方式来保证自定义事务的原子性：</strong><br/>
1. 通过SET XACT_ABORT ON来设置事务必须符合原子性<br/>
    利用设置XACT_ABORT选项设置为ON，来设置所有事务都作为一个原子处理。</p>

<pre><code>    SET XACT_ABORT ON
    BEGIN TRANSACTION
    -- 正确的语句
    INSERT INTO TestForAtom(col1)
    VALUES (5)
    -- 违反check约束的语句
    INSERT INTO TestForAtom(col1)
    VALUES (6)
    COMMIT
    go
    SELECT * FROM TestForAtom
</code></pre>

<ol>
<li><p>按照用户设置进行回滚（ROLLBACK）<br/>
这种方式具有更高的灵活性，开发人员可以自定义在什么情况进行ROLLBACK，利用TRY CATCH语句和@@ERROR进行判断都属于这种方式</p>

<pre><code>BEGIN TRANSACTION
-- Try语句成功则Commit
BEGIN TRY
-- 正确的语句
INSERT INTO TestForAtom(col1)
VALUES (5)
-- 违反check约束的语句
INSERT INTO TestForAtom(col1)
VALUES (6)
COMMIT
END TRY
-- 捕捉到错误后执行Catch中的Rollback
BEGIN CATCH
ROLLBACK
END CATCH
</code></pre></li>
</ol>

<h3 id="toc_2">理解一致性（Consistency）</h3>

<p>一致性，即在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。</p>

<p>一致性分成两个层面</p>

<ol>
<li>数据库机制层面
数据库层面的一致性是，在一个事务执行之前和之后，数据会符合你设置的约束和触发器设置，这一点是有SQL SERVER进行保证的。</li>
<li>业务层面
对于业务层面来说，一致性是保持业务的一致性。这个业务一致性需要由开发人员进行保证，很多业务方面的一致性可以通过转移到数据库机制层面进行保证。比如，产品只有两个型号，则可以转移到使用CHECK约束使某一列必须只能村这两个型号。</li>
</ol>

<h3 id="toc_3">理解隔离性（Isolation）</h3>

<p>隔离性。<strong>事务的执行是互不干扰的，一个事务不可能看到其他事务运行时，中间某一时刻的数据。</strong></p>

<p>事务之间的互相影响的情况分为几种，分别为<strong>脏读（Dirty Read），不可重复读，幻读</strong>。</p>

<ul>
<li>脏读：脏读意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的。</li>
</ul>

<p>两个事务，事务A插入一条数据，但未提交，事务B在此期间进行了读取，读取到了事务A未提交的数据，造成脏读。</p>

<ul>
<li>不可重复读（Unrepeatable Read）：不可重复读意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。</li>
</ul>

<p>事务B中对某个查询执行两次，当第一次执行完时，事务A对其数据进行了修改。事务B中再次查询时，数据发声了改变。</p>

<ul>
<li><strong>幻读（phantom read）</strong>：幻读是指事务不是独立执行时发生的一种现象。例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发声操作第一个事务的用户发现表中还有没有修改的数据行，就好像发声了幻觉一样。</li>
</ul>

<p>事务B更新表中所有数据，在此期间事务A插入了一条数据，事务B再次查询后，发现居然还有没有修改的数据，产生幻读。</p>

<p>为了避免上述几种事务之间的影响，SQL Server通过设置不同的隔离等级来进行不同程度的避免。因为高的隔离等级意味着更多的锁。<br/>
SQL Server提供了5种选项来避免不同级别的事务之间的影响</p>

<p>隔离等级由低到高分别为</p>

<ul>
<li>Read Uncommited（最高的性能，但可能出现脏读，不可重复读，幻读）</li>
<li>Read commited（可能出现不可重复读，幻读）</li>
<li>Repeatable Read（可能出现幻读）</li>
<li>Serializable（最低的性能，一次只能执行一个事务，但避免了上述所有情况）</li>
<li>SNOPSHOT（这个是通过在tempDB中创建一个额外的副本来避免脏读，不可重复读，会给tempDB造成额外负担）</li>
</ul>

<h3 id="toc_4">理解持久性（Durability）：</h3>

<p>持久性，意味着事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>

<p>SQL SERVER通过write-ahead transaction log来保证持久性。write-ahead transaction log的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者</p>

<h3 id="toc_5">REFERENCE</h3>

<p>CareySon. <q>浅谈SQL SERVER中事务的ACID</q>, 博客园, 2012</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-10-25T10:47:23+08:00" itemprop="datePublished">2015/10/25</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14457412434300.html" itemprop="url">
		---</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>layout: post<br/>
title: <q>javaCollection和Map源码分析</q><br/>
category: Study Notes </p>

<h2 id="toc_0">tags: [<q>读书</q>, <q>源码阅读</q>, <q>Java</q>]</h2>

<p>{% include JB/setup %}</p>

<p>集合包中最常用的是Collection和Map两个接口的实现类。Collection用于存放多个单对象，Map用于存放Key-Value形式的键值对。</p>

<p>Collection中常用的是两种类型的接口：List和Set。两者最明显的差别是List支持放入重复的对象，而Set不支持。</p>

<h3 id="toc_1">1. ArrayList</h3>

<p>实现方式：<br/>
ArrayList采用的是数组方式来存放数据。在调用空构造器的情况下会创建一个大小为10的Object数组。</p>

<h4 id="toc_2">插入对象：</h4>

<ul>
<li>add（E）</li>
</ul>

<p>如果插入一个对象以后，ArrayList依然没有满，那就是单纯的将数组中某个元素的值赋值为传入的对象。</p>

<p>如果插入一个对象后，ArrayList会产生溢出，则要将数组的容量扩大。新的数组的容量计算方法为：<strong>旧数组容量 * 1.5 + 1</strong>。在得到新的数组容量以后，<strong>将原数据的数据拷贝到新数组中Arrays.copyOf</strong>。</p>

<ul>
<li>add（int，E）</li>
</ul>

<p>允许将元素直接插入指定的int位置上。这个方法的实现首先要确保插入的位置是当前Array数组中存在的，之后还要确保数组的容量是够用的。</p>

<p>在完成以上动作后，<strong>它要将数据对象进行一次复制</strong>，然后将int指定的index后面的数据往后挪动一位，然后才能将指定的index位置的复制为传入的对象。</p>

<pre><code>{
    fastRemove（）
    将index后的对象往前复制一位
}
</code></pre>

<h4 id="toc_3">删除对象：</h4>

<ul>
<li>remove（E）</li>
</ul>

<p>ArrayList首先判断对象是否为null。</p>

<p>如果是null，则遍历数组中已有值的元素，并比较其是否为null，若为null，则调用fastRemove来删除相应位置的对象。<strong>fastRemove（）会将index后的对象往前复制一位，并将数组中的最后一个元素的值设置为null，即释放了对此对象的引用</strong>。</p>

<p>如果这个对象不是null，<strong>唯一的不同在于通过E的equals来比较元素的值是否相同</strong>，如相同则认为是需要删除对象的位置，然后同样是通过调用fastRemove来完成对象的删除。</p>

<ul>
<li>remove（int）</li>
</ul>

<p>的实现比remove（E）多了一个数组范围的检测，但少了对象位置的查找，因此性能会更好。</p>

<h4 id="toc_4">遍历对象：</h4>

<ul>
<li>iterator（）</li>
</ul>

<p>当调用hasNext（）方法时，<strong>比较当前指向的数组的位置是否和数组中已有的元素的大小相等</strong>，如相等则返回false，否则返回true。</p>

<p>当调用next方法时，首先<strong>比较</strong>在创建此Iterator时获取的<strong>modCount与当前的modCount</strong>，<strong>如果这两个modCount不相等，则说明在获取next元素时，发生了对于集合大小产生影响（新增，删除）的动作。当产生这种情况时，则抛出ConcurrentModificationException</strong>。如果modCount相等，则调用get方法来获取相应位置的元素。</p>

<h4 id="toc_5">判断对象是否存在：</h4>

<ul>
<li>contains（E）</li>
</ul>

<p>做法为遍历整个ArrayList中已有的元素，通过equals来判断是否和元素相等。</p>

<p>indexOf和lastIndexOf是ArrayList中用于获得对象所在位置的方法，其中<strong>indexOf为从前往后寻找</strong>，而<strong>lastIndexOf为从后往前寻找</strong>。</p>

<h3 id="toc_6">注意要点：</h3>

<ul>
<li>ArrayList基于数组方式实现，无容量的限制</li>
<li>ArrayList<strong>在执行插入元素时可能要扩容</strong>，<strong>在删除元素时并不会减小数组的容量</strong>（如希望相应的减少数组容量，可以调用ArrayList的trimToSize（）），在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。</li>
<li>ArrayList是<strong>非线程安全</strong>的。</li>
</ul>

<h3 id="toc_7">2. LinkedList</h3>

<p>linkedList基于双向链表机制，所谓双向链表机制是指集合中的每个元素都知道其前一个元素及其后一个元素的位置。这样的机制可以快速实现集合中元素的移动。</p>

<h4 id="toc_8">LinkedList（）</h4>

<p>在创建LinkedList对象时，应首先创建一个element属性为null，next属性为null及previous属性为null的Entry对象，并赋值给全局的header属性。在执行构造器时，LinkedList将header的next及previous都指向header。</p>

<h4 id="toc_9">add（E）</h4>

<p>LinkedList的add方法不用像ArrayList那样，要考虑扩容及复制数组的问题，但它<strong>每增加一个元素，都要创建一个新的Entry对象，并要修改相邻的两个元素的属性</strong>。</p>

<h4 id="toc_10">remove（E）</h4>

<p>删除时只须直接删除链表上的当前元素，并将当前元素中的element，previous及next属性设置为null，即可完成对象的删除。</p>

<h4 id="toc_11">get（int）</h4>

<p>由于<strong>LinkedList的元素并没有存储在一个数组中</strong>，因此<strong>其get操作过程比ArrayList更为复杂</strong>。</p>

<p><strong>首先判断当前要获取的位置是否小于LinkedList值的一半</strong>，如小于，则从头一直找到index位置所对象的next元素；如大于，则从队列的尾部往前，一直找到index位置所对应的previous元素。</p>

<h4 id="toc_12">iterator（）</h4>

<p>由于<strong>LinkedList是基于双向链接实现的</strong>，因此其在遍历时还可往前遍历，通过调用hasPrevious和previous来完成遍历过程。</p>

<h3 id="toc_13">注意要点：</h3>

<ul>
<li>LinkedList基于双向链表机制实现。</li>
<li>LinkedList在插入元素时，须创建一个新的Entry对象，并切换相应元素的前后元素的引用；在查找元素时，须遍历链表；在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可</li>
<li>LinkedList是非线程安全</li>
</ul>

<h3 id="toc_14">REFERENCE:</h3>

<p>林昊，《分布式Java应用》，电子工业出版社，2011</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-10-25T10:47:23+08:00" itemprop="datePublished">2015/10/25</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14457412434265.html" itemprop="url">
		---</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>layout: post<br/>
title: <q>分布式系统漫谈 Google三驾马车：GFS</q><br/>
category: Reading Notes </p>

<h2 id="toc_0">tags: [<q>读文章</q>, <q>分布式系统</q>, <q>GFS</q>]</h2>

<p>{% include JB/setup %}</p>

<h2 id="toc_1">Google File System</h2>

<p>GFS是一个<strong>可扩展</strong>的分布式文件系统，用于大型的，<strong>分布式</strong>，<strong>对大量数据进行访问</strong>的应用。它运行于<strong>廉价的普通硬件</strong>上，提供容错功能。</p>

<p>Google设置<strong>一个主（master）来保存目录和索引信息</strong>，这是为了简化系统结果，提高性能来考虑的，<strong>但是这就会造成主（master）成为单点故障或者瓶颈</strong>。为了消除主（master）的单点故障Google<strong>把每个chunk设置的很大</strong>（64M），这样，由于<strong>代码访问数据的本地性，application端和master的交互会减少</strong>，而<strong>主要数据流量都是Application和chunkserver之间的访问</strong>。</p>

<p>master所有信息都储存在内存里，启动时信息从chunkserver中获取。</p>

<p><strong>The master stores thress major types of metadata: the file and chunk namespaces,the mapping from files to chunks, and the locations of each chunk&#39;s replicas</strong>.</p>

<p>Having a single master vastly simplifies our design and enables the master to make sophisticated chunk placement and replication decisions using global knowledge. However, <strong>we must minimize its involvement in reads and writes so that it does not become a bottleneck</strong>. <strong>Clients never read and write file data through the master</strong>. Instead, <strong>a client asks the master which chunkservers it should contact</strong>. It caches this information for a limited time and interacts with the chunkservers directly for many subsequent operations.</p>

<p>Neither the client nor the chunkserver caches file data. Client caches offer little benefit because most applications stream through huge files or have working sets too large to be cached. Not having them simplifies the client and the overall system by eliminating cache coherence issues. Clients do cache metadata, however. Chunkservers need not cache file data because chunks are stored as local files and so Linux&#39;s buffer cache already keeps frequently accessed data in memory.</p>

<p>宿主储存三种元文件，文件和chunk的名字，文件和chunk的关联关系，还有每个chunk的位置。</p>

<p>拥有一个宿主很大程度上简化了设计并且能让宿主利用全局的知识来做必要的chunk处理。但是我们也必须减少宿主在读写操作中的参与度以防止宿主变成瓶颈。clients不从宿主中读写文件，而是只向宿主查询chunkserver的信息。client 缓存这个信息一段时间并且直接对chunkserver进行操作。</p>

<p>client和chunkserver都不缓存文件。<strong>之所以都不缓存文件是因为很多应用所用的文件都太大去让client缓存</strong>，但client缓存元文件。chunkserver也不去缓存文件，因为chunks都储存为本地文件并且linux系统已经将经常使用的数据缓存在内存中了。</p>

<p>GFS对外提供create, delete, open, close, read和write操作，同时还有snapshot和record append.</p>

<p><strong>Snapshot creates a copy of a file or a directory tree at low cost.</strong></p>

<p>Record append allows multiple clients to applend data to the same file concurrently while guaranteeing the atomicity of each individual client&#39;s append. 能让多个clients在同一文件后同时添加数据只要每个client所要加的东西都在一起，不会client a和client b要加的数据交叉。client a写了一半写起client b，client b写了一半又开始写client a了。</p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_26.html">Prev</a>  
	 <a class="next" href="all_28.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>